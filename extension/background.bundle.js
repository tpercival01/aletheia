/*! For license information please see background.bundle.js.LICENSE.txt */
(()=>{var __webpack_modules__={9:()=>{},31:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xorwow=o}(0,e=n.nmd(e),n.amdD)},52:()=>{},67:function(e,t,n){var r;!function(e,s){function a(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],n^=(e^=e<<13)^e<<9,r[s]=n,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.x&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xorshift7=o}(0,e=n.nmd(e),n.amdD)},108:()=>{},143:()=>{},180:function(e,t,n){var r;!function(e,s){function a(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new a(e),r=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.alea=o}(0,e=n.nmd(e),n.amdD)},181:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xor128=o}(0,e=n.nmd(e),n.amdD)},234:()=>{},264:(module,__unused_webpack_exports,__webpack_require__)=>{var e;self,e=__WEBPACK_EXTERNAL_MODULE__1670__=>(()=>{var __webpack_modules__={3474:(e,t,n)=>{var r,s=(r=(r="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return O.buffer!=D&&H(O.buffer),F}function s(){return O.buffer!=D&&H(O.buffer),P}function a(){return O.buffer!=D&&H(O.buffer),M}function i(){return O.buffer!=D&&H(O.buffer),L}function o(){return O.buffer!=D&&H(O.buffer),z}var u,l,c;e=e||{},u||(u=void 0!==e?e:{}),u.ready=new Promise(function(e,t){l=e,c=t});var h,d,p,f,m,g,b=Object.assign({},u),y="./this.program",x=(e,t)=>{throw t},w="object"==typeof window,v="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,k=u.ENVIRONMENT_IS_PTHREAD||!1,T="";function S(e){return u.locateFile?u.locateFile(e,T):T+e}if(_){let t;T=v?n(908).dirname(T)+"/":"//",g=()=>{m||(f=n(1384),m=n(908))},h=function(e,t){return g(),e=m.normalize(e),f.readFileSync(e,t?void 0:"utf8")},p=e=>((e=h(e,!0)).buffer||(e=new Uint8Array(e)),e),d=(e,t,n)=>{g(),e=m.normalize(e),f.readFile(e,function(e,r){e?n(e):t(r.buffer)})},1<process.argv.length&&(y=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(e){if(!(e instanceof le))throw e}),process.on("unhandledRejection",function(e){throw e}),x=(e,t)=>{if(Q())throw process.exitCode=e,t;t instanceof le||A("exiting due to exception: "+t),process.exit(e)},u.inspect=function(){return"[Emscripten Module object]"};try{t=n(9925)}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}n.g.Worker=t.Worker}else(w||v)&&(v?T=self.location.href:"undefined"!=typeof document&&document.currentScript&&(T=document.currentScript.src),r&&(T=r),T=0!==T.indexOf("blob:")?T.substr(0,T.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(h=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},v&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),d=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(6953).performance);var I=console.log.bind(console),N=console.warn.bind(console);_&&(g(),I=e=>f.writeSync(1,e+"\n"),N=e=>f.writeSync(2,e+"\n"));var E,$=u.print||I,A=u.printErr||N;Object.assign(u,b),b=null,u.thisProgram&&(y=u.thisProgram),u.quit&&(x=u.quit),u.wasmBinary&&(E=u.wasmBinary);var C=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&ae("no native wasm support detected");var O,R,D,F,P,M,L,z,B=!1,U="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function V(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&U)return U.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var s=e[t++];if(128&s){var a=63&e[t++];if(192==(224&s))r+=String.fromCharCode((31&s)<<6|a);else{var i=63&e[t++];65536>(s=224==(240&s)?(15&s)<<12|a<<6|i:(7&s)<<18|a<<12|i<<6|63&e[t++])?r+=String.fromCharCode(s):(s-=65536,r+=String.fromCharCode(55296|s>>10,56320|1023&s))}}else r+=String.fromCharCode(s)}return r}function W(e,t){return(e>>>=0)?V(s(),e,t):""}function j(e,t,n,r){if(!(0<r))return 0;var s=n>>>=0;r=n+r-1;for(var a=0;a<e.length;++a){var i=e.charCodeAt(a);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++a)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-s}function G(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function H(e){D=e,u.HEAP8=F=new Int8Array(e),u.HEAP16=new Int16Array(e),u.HEAP32=M=new Int32Array(e),u.HEAPU8=P=new Uint8Array(e),u.HEAPU16=new Uint16Array(e),u.HEAPU32=L=new Uint32Array(e),u.HEAPF32=new Float32Array(e),u.HEAPF64=z=new Float64Array(e)}k&&(D=u.buffer);var q=u.INITIAL_MEMORY||16777216;if(k)O=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)O=u.wasmMemory;else if(!((O=new WebAssembly.Memory({initial:q/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw A("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");O&&(D=O.buffer),q=D.byteLength,H(D);var K,X=[],Y=[],Z=[],J=[];function Q(){return C||!1}function ee(){var e=u.preRun.shift();X.unshift(e)}var te,ne=0,re=null,se=null;function ae(e){throw k?postMessage({cmd:"onAbort",arg:e}):u.onAbort&&u.onAbort(e),A(e="Aborted("+e+")"),B=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),c(e),e}function ie(){return te.startsWith("data:application/octet-stream;base64,")}function oe(){var e=te;try{if(e==te&&E)return new Uint8Array(E);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(e){ae(e)}}te="ort-wasm-threaded.wasm",ie()||(te=S(te));var ue={};function le(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function ce(e){(e=fe.Vb[e])||ae(),fe.mc(e)}function he(e){var t=fe.Cc();if(!t)return 6;fe.ac.push(t),fe.Vb[e.Ub]=t,t.Ub=e.Ub;var n={cmd:"run",start_routine:e.Ic,arg:e.zc,pthread_ptr:e.Ub};return t.$b=()=>{n.time=performance.now(),t.postMessage(n,e.Nc)},t.loaded&&(t.$b(),delete t.$b),0}function de(e){if(k)return qe(1,1,e);Q()||(fe.oc(),u.onExit&&u.onExit(e),B=!0),x(e,new le(e))}function pe(e,t){if(!t&&k)throw ge(e),"unwind";Q()||k||(bt(),me(Z),gt(0),rt[1].length&&st(1,10),rt[2].length&&st(2,10),fe.oc()),de(e)}var fe={Yb:[],ac:[],qc:[],Vb:{},fc:function(){k&&fe.Ec()},Pc:function(){},Ec:function(){fe.receiveObjectTransfer=fe.Gc,fe.threadInitTLS=fe.pc,fe.setExitStatus=fe.nc,C=!1},nc:function(){},oc:function(){for(var e of Object.values(fe.Vb))fe.mc(e);for(e of fe.Yb)e.terminate();fe.Yb=[]},mc:function(e){var t=e.Ub;delete fe.Vb[t],fe.Yb.push(e),fe.ac.splice(fe.ac.indexOf(e),1),e.Ub=0,_t(t)},Gc:function(){},pc:function(){fe.qc.forEach(e=>e())},Fc:function(e,t){e.onmessage=n=>{var r=(n=n.data).cmd;if(e.Ub&&(fe.Bc=e.Ub),n.targetThread&&n.targetThread!=pt()){var s=fe.Vb[n.Qc];s?s.postMessage(n,n.transferList):A('Internal error! Worker sent a message "'+r+'" to target pthread '+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?Ue(n.queue):"spawnThread"===r?he(n):"cleanupThread"===r?ce(n.thread):"killThread"===r?(n=n.thread,r=fe.Vb[n],delete fe.Vb[n],r.terminate(),_t(n),fe.ac.splice(fe.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?fe.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t&&t(e),e.$b&&(e.$b(),delete e.$b)):"print"===r?$("Thread "+n.threadId+": "+n.text):"printErr"===r?A("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&A("worker sent an unknown command "+r);fe.Bc=void 0},e.onerror=e=>{throw A("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},_&&(e.on("message",function(t){e.onmessage({data:t})}),e.on("error",function(t){e.onerror(t)}),e.on("detachedExit",function(){})),e.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||r,wasmMemory:O,wasmModule:R})},yc:function(){var e=S("ort-wasm-threaded.worker.js");fe.Yb.push(new Worker(e))},Cc:function(){return 0==fe.Yb.length&&(fe.yc(),fe.Fc(fe.Yb[0])),fe.Yb.pop()}};function me(e){for(;0<e.length;)e.shift()(u)}function ge(e){if(k)return qe(2,0,e);try{pe(e)}catch(e){e instanceof le||"unwind"==e||x(1,e)}}u.PThread=fe,u.establishStackSpace=function(){var e=pt(),t=a()[e+44>>2>>>0];e=a()[e+48>>2>>>0],St(t,t-e),Nt(t)};var be=[];function ye(e){var t=be[e];return t||(e>=be.length&&(be.length=e+1),be[e]=t=K.get(e)),t}u.invokeEntryPoint=function(e,t){e=ye(e)(t),Q()?fe.nc(e):kt(e)};var xe,we,ve=[],_e=0,ke=0;function Te(e){this.Zb=e,this.Sb=e-24,this.xc=function(e){i()[this.Sb+4>>2>>>0]=e},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(e){i()[this.Sb+8>>2>>>0]=e},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(e){e=e?1:0,t()[(this.Sb+12|0)>>>0]=e},this.uc=function(){return 0!=t()[(this.Sb+12|0)>>>0]},this.ic=function(e){e=e?1:0,t()[(this.Sb+13|0)>>>0]=e},this.kc=function(){return 0!=t()[(this.Sb+13|0)>>>0]},this.fc=function(e,t){this.cc(0),this.xc(e),this.wc(t),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(e){i()[this.Sb+16>>2>>>0]=e},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(At(this.bc()))return i()[this.Zb>>2>>>0];var e=this.tc();return 0!==e?e:this.Zb}}function Se(e){return mt(new Te(e).Sb)}function Ie(e,t,n,r){return k?qe(3,1,e,t,n,r):Ne(e,t,n,r)}function Ne(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return A("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var s=[];return k&&0===s.length?Ie(e,t,n,r):(e={Ic:n,Ub:e,zc:r,Nc:s},k?(e.Oc="spawnThread",postMessage(e,s),0):he(e))}function Ee(e,t,n){return k?qe(4,1,e,t,n):0}function $e(e,t){if(k)return qe(5,1,e,t)}function Ae(e,t){if(k)return qe(6,1,e,t)}function Ce(e,t,n){if(k)return qe(7,1,e,t,n)}function Oe(e,t,n){return k?qe(8,1,e,t,n):0}function Re(e,t){if(k)return qe(9,1,e,t)}function De(e,t,n){if(k)return qe(10,1,e,t,n)}function Fe(e,t,n,r){if(k)return qe(11,1,e,t,n,r)}function Pe(e,t,n,r){if(k)return qe(12,1,e,t,n,r)}function Me(e,t,n,r){if(k)return qe(13,1,e,t,n,r)}function Le(e){if(k)return qe(14,1,e)}function ze(e,t){if(k)return qe(15,1,e,t)}function Be(e,t,n){if(k)return qe(16,1,e,t,n)}function Ue(e){Atomics.store(a(),e>>2,1),pt()&&vt(e),Atomics.compareExchange(a(),e>>2,1,0)}function Ve(e){return i()[e>>>2]+4294967296*a()[e+4>>>2]}function We(e,t,n,r,s,a){return k?qe(17,1,e,t,n,r,s,a):-52}function je(e,t,n,r,s,a){if(k)return qe(18,1,e,t,n,r,s,a)}function Ge(e){var n=G(e)+1,r=ft(n);return r&&j(e,t(),r,n),r}function He(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}if(k)return qe(19,1,e,t,n);var s=(new Date).getFullYear(),o=new Date(s,0,1),u=new Date(s,6,1);s=o.getTimezoneOffset();var l=u.getTimezoneOffset(),c=Math.max(s,l);a()[e>>2>>>0]=60*c,a()[t>>2>>>0]=Number(s!=l),e=r(o),t=r(u),e=Ge(e),t=Ge(t),l<s?(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t):(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e)}function qe(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=It();return e=e(),Nt(t),e}(()=>{for(var s=Et(8*n),a=s>>3,i=0;i<n;i++){var u=r[2+i];o()[a+i>>>0]=u}return wt(e,n,s,t)})}u.executeNotifiedProxyingQueue=Ue,we=_?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:k?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var Ke,Xe=[],Ye={};function Ze(){if(!Ke){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:y||"./this.program"};for(e in Ye)void 0===Ye[e]?delete t[e]:t[e]=Ye[e];var n=[];for(e in t)n.push(e+"="+t[e]);Ke=n}return Ke}function Je(e,n){if(k)return qe(20,1,e,n);var r=0;return Ze().forEach(function(s,a){var o=n+r;for(a=i()[e+4*a>>2>>>0]=o,o=0;o<s.length;++o)t()[(0|a++)>>>0]=s.charCodeAt(o);t()[(0|a)>>>0]=0,r+=s.length+1}),0}function Qe(e,t){if(k)return qe(21,1,e,t);var n=Ze();i()[e>>2>>>0]=n.length;var r=0;return n.forEach(function(e){r+=e.length+1}),i()[t>>2>>>0]=r,0}function et(e){return k?qe(22,1,e):52}function tt(e,t,n,r){return k?qe(23,1,e,t,n,r):52}function nt(e,t,n,r,s){return k?qe(24,1,e,t,n,r,s):70}var rt=[null,[],[]];function st(e,t){var n=rt[e];0===t||10===t?((1===e?$:A)(V(n,0)),n.length=0):n.push(t)}function at(e,t,n,r){if(k)return qe(25,1,e,t,n,r);for(var a=0,o=0;o<n;o++){var u=i()[t>>2>>>0],l=i()[t+4>>2>>>0];t+=8;for(var c=0;c<l;c++)st(e,s()[u+c>>>0]);a+=l}return i()[r>>2>>>0]=a,0}var it=0;function ot(e){return 0==e%4&&(0!=e%100||0==e%400)}var ut=[31,29,31,30,31,30,31,31,30,31,30,31],lt=[31,28,31,30,31,30,31,31,30,31,30,31];function ct(e,n,r,s){function i(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return i(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function l(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function c(e){var t=e.Wb;for(e=new Date(new Date(e.Xb+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(ot(e.getFullYear())?ut:lt)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=l(new Date(e.getFullYear(),0,4)),n=l(n),0>=u(t,e)?0>=u(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var h=a()[s+40>>2>>>0];for(var d in s={Lc:a()[s>>2>>>0],Kc:a()[s+4>>2>>>0],dc:a()[s+8>>2>>>0],jc:a()[s+12>>2>>>0],ec:a()[s+16>>2>>>0],Xb:a()[s+20>>2>>>0],Tb:a()[s+24>>2>>>0],Wb:a()[s+28>>2>>>0],Rc:a()[s+32>>2>>>0],Jc:a()[s+36>>2>>>0],Mc:h?W(h):""},r=W(r),h={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(d,"g"),h[d]);var p="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),f="January February March April May June July August September October November December".split(" ");for(d in h={"%a":function(e){return p[e.Tb].substring(0,3)},"%A":function(e){return p[e.Tb]},"%b":function(e){return f[e.ec].substring(0,3)},"%B":function(e){return f[e.ec]},"%C":function(e){return o((e.Xb+1900)/100|0,2)},"%d":function(e){return o(e.jc,2)},"%e":function(e){return i(e.jc,2," ")},"%g":function(e){return c(e).toString().substring(2)},"%G":function(e){return c(e)},"%H":function(e){return o(e.dc,2)},"%I":function(e){return 0==(e=e.dc)?e=12:12<e&&(e-=12),o(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.ec-1;t+=(ot(e.Xb+1900)?ut:lt)[n++]);return o(e.jc+t,3)},"%m":function(e){return o(e.ec+1,2)},"%M":function(e){return o(e.Kc,2)},"%n":function(){return"\n"},"%p":function(e){return 0<=e.dc&&12>e.dc?"AM":"PM"},"%S":function(e){return o(e.Lc,2)},"%t":function(){return"\t"},"%u":function(e){return e.Tb||7},"%U":function(e){return o(Math.floor((e.Wb+7-e.Tb)/7),2)},"%V":function(e){var t=Math.floor((e.Wb+7-(e.Tb+6)%7)/7);if(2>=(e.Tb+371-e.Wb-2)%7&&t++,t)53==t&&(4==(n=(e.Tb+371-e.Wb)%7)||3==n&&ot(e.Xb)||(t=1));else{t=52;var n=(e.Tb+7-e.Wb-1)%7;(4==n||5==n&&ot(e.Xb%400-1))&&t++}return o(t,2)},"%w":function(e){return e.Tb},"%W":function(e){return o(Math.floor((e.Wb+7-(e.Tb+6)%7)/7),2)},"%y":function(e){return(e.Xb+1900).toString().substring(2)},"%Y":function(e){return e.Xb+1900},"%z":function(e){var t=0<=(e=e.Jc);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\0\0"),h)r.includes(d)&&(r=r.replace(new RegExp(d,"g"),h[d](s)));return d=function(e){var t=Array(G(e)+1);return j(e,t,0,t.length),t}(r=r.replace(/\0\0/g,"%")),d.length>n?0:(function(e,n){t().set(e,n>>>0)}(d,e),d.length-1)}fe.fc();var ht=[null,de,ge,Ie,Ee,$e,Ae,Ce,Oe,Re,De,Fe,Pe,Me,Le,ze,Be,We,je,He,Je,Qe,et,tt,nt,at],dt={b:function(e){return ft(e+24)+24},n:function(e){return(e=new Te(e)).uc()||(e.hc(!0),_e--),e.ic(!1),ve.push(e),e.sc(),e.vc()},ma:function(e){throw A("Unexpected exception thrown, this is not properly supported - aborting"),B=!0,e},x:function(){Tt(0);var e=ve.pop();if(e.Hc()&&!e.kc()){var t=e.Dc();t&&ye(t)(e.Zb),Se(e.Zb)}ke=0},e:function(){var e=ke;if(!e)return it=0;var t=new Te(e);t.cc(e);var n=t.bc();if(!n)return it=0,e;for(var r=Array.prototype.slice.call(arguments),s=0;s<r.length;s++){var a=r[s];if(0===a||a===n)break;if($t(a,n,t.Sb+16))return it=a,e}return it=n,e},l:function(){var e=ke;if(!e)return it=0;var t=new Te(e);t.cc(e);var n=t.bc();if(!n)return it=0,e;for(var r=Array.prototype.slice.call(arguments),s=0;s<r.length;s++){var a=r[s];if(0===a||a===n)break;if($t(a,n,t.Sb+16))return it=a,e}return it=n,e},h:function(){var e=ke;if(!e)return it=0;var t=new Te(e);t.cc(e);var n=t.bc();if(!n)return it=0,e;for(var r=Array.prototype.slice.call(arguments),s=0;s<r.length;s++){var a=r[s];if(0===a||a===n)break;if($t(a,n,t.Sb+16))return it=a,e}return it=n,e},t:Se,M:function(){var e=ve.pop();e||ae("no exception to throw");var t=e.Zb;throw e.kc()||(ve.push(e),e.ic(!0),e.hc(!1),_e++),ke=t,t},c:function(e,t,n){throw new Te(e).fc(t,n),ke=e,_e++,e},pa:function(){return _e},Fa:function(e){yt(e,!v,1,!w),fe.pc()},T:function(e){k?postMessage({cmd:"cleanupThread",thread:e}):ce(e)},xa:Ne,j:function(e){throw ke||(ke=e),e},H:Ee,Ma:$e,ua:Ae,wa:Ce,oa:Oe,Ka:Re,Ca:De,Ja:Fe,V:Pe,va:Me,sa:Le,La:ze,ta:Be,Ta:function(){},X:function(){ae("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){ae("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(e,t,n,r){if(e==t)setTimeout(()=>Ue(r));else if(k)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{if(!(e=fe.Vb[e]))return;e.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(e,t){e=new Date(1e3*Ve(e)),a()[t>>2>>>0]=e.getUTCSeconds(),a()[t+4>>2>>>0]=e.getUTCMinutes(),a()[t+8>>2>>>0]=e.getUTCHours(),a()[t+12>>2>>>0]=e.getUTCDate(),a()[t+16>>2>>>0]=e.getUTCMonth(),a()[t+20>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>2>>>0]=e},Qa:function(e,t){e=new Date(1e3*Ve(e)),a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),a()[t+20>>2>>>0]=e.getFullYear()-1900,a()[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1),r=(e.getTime()-n.getTime())/864e5|0;a()[t+28>>2>>>0]=r,a()[t+36>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset(),e=0|(r!=(n=n.getTimezoneOffset())&&e.getTimezoneOffset()==Math.min(n,r)),a()[t+32>>2>>>0]=e},Ra:function(e){var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),s=new Date(t.getFullYear(),0,1),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=s.getTimezoneOffset(),u=Math.min(o,i);return 0>n?a()[e+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),t.setTime(t.getTime()+6e4*((0<n?u:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(t.getTime()-s.getTime())/864e5|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},Aa:We,Ba:je,Sa:function e(t,n,r){e.Ac||(e.Ac=!0,He(t,n,r))},y:function(){ae("")},U:function(){if(!_&&!v){var e="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";xe||(xe={}),xe[e]||(xe[e]=1,_&&(e="warning: "+e),A(e))}},ra:function(){return 4294901760},B:we,Ia:function(e,t,n){s().copyWithin(e>>>0,t>>>0,t+n>>>0)},F:function(){return _?n(3993).cpus().length:navigator.hardwareConcurrency},Da:function(e,t,n){Xe.length=t,n>>=3;for(var r=0;r<t;r++)Xe[r]=o()[n+r>>>0];return(0>e?ue[-e-1]:ht[e]).apply(null,Xe)},qa:function(e){var t=s().length;if((e>>>=0)<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);e:{try{O.grow(a-D.byteLength+65535>>>16),H(O.buffer);var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},Na:function(){throw"unwind"},Ga:Je,Ha:Qe,J:pe,I:et,S:tt,ga:nt,R:at,d:function(){return it},na:function e(r,s){e.lc||(e.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(_)try{var t=n(Object(function(){var e=new Error("Cannot find module 'crypto'");throw e.code="MODULE_NOT_FOUND",e}()));return()=>t.randomBytes(1)[0]}catch(e){}return()=>ae("randomDevice")}());for(var a=0;a<s;a++)t()[(r+a|0)>>>0]=e.lc();return 0},ia:function(e,t,n){var r=It();try{return ye(e)(t,n)}catch(e){if(Nt(r),e!==e+0)throw e;Tt(1,0)}},ja:function(e,t,n){var r=It();try{return ye(e)(t,n)}catch(e){if(Nt(r),e!==e+0)throw e;Tt(1,0)}},K:function(e){var t=It();try{return ye(e)()}catch(e){if(Nt(t),e!==e+0)throw e;Tt(1,0)}},f:function(e,t){var n=It();try{return ye(e)(t)}catch(e){if(Nt(n),e!==e+0)throw e;Tt(1,0)}},P:function(e,t,n){var r=It();try{return ye(e)(t,n)}catch(e){if(Nt(r),e!==e+0)throw e;Tt(1,0)}},Q:function(e,t,n){var r=It();try{return ye(e)(t,n)}catch(e){if(Nt(r),e!==e+0)throw e;Tt(1,0)}},k:function(e,t,n){var r=It();try{return ye(e)(t,n)}catch(e){if(Nt(r),e!==e+0)throw e;Tt(1,0)}},p:function(e,t,n,r){var s=It();try{return ye(e)(t,n,r)}catch(e){if(Nt(s),e!==e+0)throw e;Tt(1,0)}},q:function(e,t,n,r,s){var a=It();try{return ye(e)(t,n,r,s)}catch(e){if(Nt(a),e!==e+0)throw e;Tt(1,0)}},N:function(e,t,n,r,s,a){var i=It();try{return ye(e)(t,n,r,s,a)}catch(e){if(Nt(i),e!==e+0)throw e;Tt(1,0)}},s:function(e,t,n,r,s,a){var i=It();try{return ye(e)(t,n,r,s,a)}catch(e){if(Nt(i),e!==e+0)throw e;Tt(1,0)}},w:function(e,t,n,r,s,a,i){var o=It();try{return ye(e)(t,n,r,s,a,i)}catch(e){if(Nt(o),e!==e+0)throw e;Tt(1,0)}},L:function(e,t,n,r,s,a,i,o){var u=It();try{return ye(e)(t,n,r,s,a,i,o)}catch(e){if(Nt(u),e!==e+0)throw e;Tt(1,0)}},E:function(e,t,n,r,s,a,i,o,u,l,c,h){var d=It();try{return ye(e)(t,n,r,s,a,i,o,u,l,c,h)}catch(e){if(Nt(d),e!==e+0)throw e;Tt(1,0)}},aa:function(e,t,n,r,s,a,i,o){var u=It();try{return zt(e,t,n,r,s,a,i,o)}catch(e){if(Nt(u),e!==e+0)throw e;Tt(1,0)}},_:function(e,t,n,r,s,a,i){var o=It();try{return Ot(e,t,n,r,s,a,i)}catch(e){if(Nt(o),e!==e+0)throw e;Tt(1,0)}},Z:function(e,t,n,r,s){var a=It();try{return Bt(e,t,n,r,s)}catch(e){if(Nt(a),e!==e+0)throw e;Tt(1,0)}},ca:function(e,t,n,r){var s=It();try{return Mt(e,t,n,r)}catch(e){if(Nt(s),e!==e+0)throw e;Tt(1,0)}},$:function(e){var t=It();try{return Ct(e)}catch(e){if(Nt(t),e!==e+0)throw e;Tt(1,0)}},ba:function(e,t){var n=It();try{return Lt(e,t)}catch(e){if(Nt(n),e!==e+0)throw e;Tt(1,0)}},Y:function(e,t,n){var r=It();try{return Rt(e,t,n)}catch(e){if(Nt(r),e!==e+0)throw e;Tt(1,0)}},g:function(e){var t=It();try{ye(e)()}catch(e){if(Nt(t),e!==e+0)throw e;Tt(1,0)}},r:function(e,t){var n=It();try{ye(e)(t)}catch(e){if(Nt(n),e!==e+0)throw e;Tt(1,0)}},i:function(e,t,n){var r=It();try{ye(e)(t,n)}catch(e){if(Nt(r),e!==e+0)throw e;Tt(1,0)}},ha:function(e,t,n,r){var s=It();try{ye(e)(t,n,r)}catch(e){if(Nt(s),e!==e+0)throw e;Tt(1,0)}},m:function(e,t,n,r){var s=It();try{ye(e)(t,n,r)}catch(e){if(Nt(s),e!==e+0)throw e;Tt(1,0)}},v:function(e,t,n,r,s){var a=It();try{ye(e)(t,n,r,s)}catch(e){if(Nt(a),e!==e+0)throw e;Tt(1,0)}},u:function(e,t,n,r,s,a){var i=It();try{ye(e)(t,n,r,s,a)}catch(e){if(Nt(i),e!==e+0)throw e;Tt(1,0)}},O:function(e,t,n,r,s,a,i){var o=It();try{ye(e)(t,n,r,s,a,i)}catch(e){if(Nt(o),e!==e+0)throw e;Tt(1,0)}},A:function(e,t,n,r,s,a,i,o){var u=It();try{ye(e)(t,n,r,s,a,i,o)}catch(e){if(Nt(u),e!==e+0)throw e;Tt(1,0)}},ka:function(e,t,n,r,s,a,i,o,u){var l=It();try{ye(e)(t,n,r,s,a,i,o,u)}catch(e){if(Nt(l),e!==e+0)throw e;Tt(1,0)}},C:function(e,t,n,r,s,a,i,o,u,l,c){var h=It();try{ye(e)(t,n,r,s,a,i,o,u,l,c)}catch(e){if(Nt(h),e!==e+0)throw e;Tt(1,0)}},D:function(e,t,n,r,s,a,i,o,u,l,c,h,d,p,f,m){var g=It();try{ye(e)(t,n,r,s,a,i,o,u,l,c,h,d,p,f,m)}catch(e){if(Nt(g),e!==e+0)throw e;Tt(1,0)}},fa:function(e,t,n,r,s,a,i,o){var u=It();try{Dt(e,t,n,r,s,a,i,o)}catch(e){if(Nt(u),e!==e+0)throw e;Tt(1,0)}},da:function(e,t,n,r,s,a,i,o,u,l,c,h){var d=It();try{Pt(e,t,n,r,s,a,i,o,u,l,c,h)}catch(e){if(Nt(d),e!==e+0)throw e;Tt(1,0)}},ea:function(e,t,n,r,s,a){var i=It();try{Ft(e,t,n,r,s,a)}catch(e){if(Nt(i),e!==e+0)throw e;Tt(1,0)}},o:function(e){return e},a:O||u.wasmMemory,G:function(e){it=e},la:ct,z:function(e,t,n,r){return ct(e,t,n,r)}};!function(){function e(e,t){u.asm=e.exports,fe.qc.push(u.asm.sb),K=u.asm.ub,Y.unshift(u.asm.Va),R=t,k||(ne--,u.monitorRunDependencies&&u.monitorRunDependencies(ne),0==ne&&(null!==re&&(clearInterval(re),re=null),se&&(e=se,se=null,e())))}function t(t){e(t.instance,t.module)}function n(e){return function(){if(!E&&(w||v)){if("function"==typeof fetch&&!te.startsWith("file://"))return fetch(te,{credentials:"same-origin"}).then(function(e){if(!e.ok)throw"failed to load wasm binary file at '"+te+"'";return e.arrayBuffer()}).catch(function(){return oe()});if(d)return new Promise(function(e,t){d(te,function(t){e(new Uint8Array(t))},t)})}return Promise.resolve().then(function(){return oe()})}().then(function(e){return WebAssembly.instantiate(e,r)}).then(function(e){return e}).then(e,function(e){A("failed to asynchronously prepare wasm: "+e),ae(e)})}var r={a:dt};if(k||(ne++,u.monitorRunDependencies&&u.monitorRunDependencies(ne)),u.instantiateWasm)try{return u.instantiateWasm(r,e)}catch(e){return A("Module.instantiateWasm callback failed with error: "+e),!1}(E||"function"!=typeof WebAssembly.instantiateStreaming||ie()||te.startsWith("file://")||_||"function"!=typeof fetch?n(t):fetch(te,{credentials:"same-origin"}).then(function(e){return WebAssembly.instantiateStreaming(e,r).then(t,function(e){return A("wasm streaming compile failed: "+e),A("falling back to ArrayBuffer instantiation"),n(t)})})).catch(c)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var pt=u._pthread_self=function(){return(pt=u._pthread_self=u.asm.ob).apply(null,arguments)},ft=u._malloc=function(){return(ft=u._malloc=u.asm.pb).apply(null,arguments)},mt=u._free=function(){return(mt=u._free=u.asm.qb).apply(null,arguments)},gt=u._fflush=function(){return(gt=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var bt=u.___funcs_on_exit=function(){return(bt=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},yt=u.__emscripten_thread_init=function(){return(yt=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var xt,wt=u._emscripten_run_in_main_runtime_thread_js=function(){return(wt=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},vt=u.__emscripten_proxy_execute_task_queue=function(){return(vt=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},_t=u.__emscripten_thread_free_data=function(){return(_t=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},kt=u.__emscripten_thread_exit=function(){return(kt=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Tt=u._setThrew=function(){return(Tt=u._setThrew=u.asm.Bb).apply(null,arguments)},St=u._emscripten_stack_set_limits=function(){return(St=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},It=u.stackSave=function(){return(It=u.stackSave=u.asm.Db).apply(null,arguments)},Nt=u.stackRestore=function(){return(Nt=u.stackRestore=u.asm.Eb).apply(null,arguments)},Et=u.stackAlloc=function(){return(Et=u.stackAlloc=u.asm.Fb).apply(null,arguments)},$t=u.___cxa_can_catch=function(){return($t=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},At=u.___cxa_is_pointer_type=function(){return(At=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},Ct=u.dynCall_j=function(){return(Ct=u.dynCall_j=u.asm.Ib).apply(null,arguments)},Ot=u.dynCall_iiiiij=function(){return(Ot=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},Rt=u.dynCall_jii=function(){return(Rt=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Dt=u.dynCall_viiiiij=function(){return(Dt=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ft=u.dynCall_vjji=function(){return(Ft=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Pt=u.dynCall_viiijjjii=function(){return(Pt=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Mt=u.dynCall_iij=function(){return(Mt=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},Lt=u.dynCall_ji=function(){return(Lt=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},zt=u.dynCall_iiiiiij=function(){return(zt=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Bt=u.dynCall_iiij=function(){return(Bt=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function Ut(){function e(){if(!xt&&(xt=!0,u.calledRun=!0,!B)&&(k||me(Y),l(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!k)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var e=u.postRun.shift();J.unshift(e)}me(J)}}if(!(0<ne))if(k)l(u),k||me(Y),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)ee();me(X),0<ne||(u.setStatus?(u.setStatus("Running..."),setTimeout(function(){setTimeout(function(){u.setStatus("")},1),e()},1)):e())}}if(u.UTF8ToString=W,u.stringToUTF8=function(e,t,n){return j(e,s(),t,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=O,u.stackSave=It,u.stackRestore=Nt,u.stackAlloc=Et,u.ExitStatus=le,u.PThread=fe,se=function e(){xt||Ut(),xt||(se=e)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return Ut(),e.ready});e.exports=s},932:(e,t,n)=>{var r,s=(r=(r="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t,s,a;e=e||{},t||(t=void 0!==e?e:{}),t.ready=new Promise(function(e,t){s=e,a=t});var i,o,u,l,c,h,d=Object.assign({},t),p="./this.program",f=(e,t)=>{throw t},m="object"==typeof window,g="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,y="";b?(y=g?n(908).dirname(y)+"/":"//",h=()=>{c||(l=n(1384),c=n(908))},i=function(e,t){return h(),e=c.normalize(e),l.readFileSync(e,t?void 0:"utf8")},u=e=>((e=i(e,!0)).buffer||(e=new Uint8Array(e)),e),o=(e,t,n)=>{h(),e=c.normalize(e),l.readFile(e,function(e,r){e?n(e):t(r.buffer)})},1<process.argv.length&&(p=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(e){if(!(e instanceof Z))throw e}),process.on("unhandledRejection",function(e){throw e}),f=(e,t)=>{if(_||0<U)throw process.exitCode=e,t;t instanceof Z||v("exiting due to exception: "+t),process.exit(e)},t.inspect=function(){return"[Emscripten Module object]"}):(m||g)&&(g?y=self.location.href:"undefined"!=typeof document&&document.currentScript&&(y=document.currentScript.src),r&&(y=r),y=0!==y.indexOf("blob:")?y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(u=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),o=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var x,w=t.print||console.log.bind(console),v=t.printErr||console.warn.bind(console);Object.assign(t,d),d=null,t.thisProgram&&(p=t.thisProgram),t.quit&&(f=t.quit),t.wasmBinary&&(x=t.wasmBinary);var _=t.noExitRuntime||!1;"object"!=typeof WebAssembly&&q("no native wasm support detected");var k,T,S,I,N,E,$=!1,A="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function C(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&A)return A.decode(e.subarray(t,n));for(r="";t<n;){var s=e[t++];if(128&s){var a=63&e[t++];if(192==(224&s))r+=String.fromCharCode((31&s)<<6|a);else{var i=63&e[t++];65536>(s=224==(240&s)?(15&s)<<12|a<<6|i:(7&s)<<18|a<<12|i<<6|63&e[t++])?r+=String.fromCharCode(s):(s-=65536,r+=String.fromCharCode(55296|s>>10,56320|1023&s))}}else r+=String.fromCharCode(s)}return r}function O(e,t){return(e>>>=0)?C(I,e,t):""}function R(e,t,n,r){if(!(0<r))return 0;var s=n>>>=0;r=n+r-1;for(var a=0;a<e.length;++a){var i=e.charCodeAt(a);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++a)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-s}function D(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function F(){var e=k.buffer;T=e,t.HEAP8=S=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=N=new Int32Array(e),t.HEAPU8=I=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=E=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var P,M=[],L=[],z=[],B=[],U=0;function V(){var e=t.preRun.shift();M.unshift(e)}var W,j=0,G=null,H=null;function q(e){throw t.onAbort&&t.onAbort(e),v(e="Aborted("+e+")"),$=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),a(e),e}function K(){return W.startsWith("data:application/octet-stream;base64,")}if(W="ort-wasm.wasm",!K()){var X=W;W=t.locateFile?t.locateFile(X,y):y+X}function Y(){var e=W;try{if(e==W&&x)return new Uint8Array(x);if(u)return u(e);throw"both async and sync fetching of the wasm failed"}catch(e){q(e)}}function Z(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function J(e){for(;0<e.length;)e.shift()(t)}var Q=[],ee=0,te=0;function ne(e){this.Db=e,this.zb=e-24,this.Ub=function(e){E[this.zb+4>>2>>>0]=e},this.Eb=function(){return E[this.zb+4>>2>>>0]},this.Sb=function(e){E[this.zb+8>>2>>>0]=e},this.Wb=function(){return E[this.zb+8>>2>>>0]},this.Tb=function(){N[this.zb>>2>>>0]=0},this.Ib=function(e){S[(this.zb+12|0)>>>0]=e?1:0},this.Pb=function(){return 0!=S[(this.zb+12|0)>>>0]},this.Jb=function(e){S[(this.zb+13|0)>>>0]=e?1:0},this.Lb=function(){return 0!=S[(this.zb+13|0)>>>0]},this.Rb=function(e,t){this.Fb(0),this.Ub(e),this.Sb(t),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){N[this.zb>>2>>>0]+=1},this.Xb=function(){var e=N[this.zb>>2>>>0];return N[this.zb>>2>>>0]=e-1,1===e},this.Fb=function(e){E[this.zb+16>>2>>>0]=e},this.Ob=function(){return E[this.zb+16>>2>>>0]},this.Qb=function(){if(Ee(this.Eb()))return E[this.Db>>2>>>0];var e=this.Ob();return 0!==e?e:this.Db}}function re(e){return we(new ne(e).zb)}var se=[];function ae(e){var t=se[e];return t||(e>=se.length&&(se.length=e+1),se[e]=t=P.get(e)),t}function ie(e){var t=D(e)+1,n=xe(t);return n&&R(e,S,n,t),n}var oe={};function ue(){if(!le){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(e in oe)void 0===oe[e]?delete t[e]:t[e]=oe[e];var n=[];for(e in t)n.push(e+"="+t[e]);le=n}return le}var le,ce=[null,[],[]];function he(e,t){var n=ce[e];0===t||10===t?((1===e?w:v)(C(n,0)),n.length=0):n.push(t)}var de=0;function pe(e){return 0==e%4&&(0!=e%100||0==e%400)}var fe=[31,29,31,30,31,30,31,31,30,31,30,31],me=[31,28,31,30,31,30,31,31,30,31,30,31];function ge(e,t,n,r){function s(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function a(e,t){return s(e,t,"0")}function i(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function o(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.Bb;for(e=new Date(new Date(e.Cb+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(pe(e.getFullYear())?fe:me)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=o(new Date(e.getFullYear(),0,4)),n=o(n),0>=i(t,e)?0>=i(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var l=N[r+40>>2>>>0];for(var c in r={$b:N[r>>2>>>0],Zb:N[r+4>>2>>>0],Gb:N[r+8>>2>>>0],Kb:N[r+12>>2>>>0],Hb:N[r+16>>2>>>0],Cb:N[r+20>>2>>>0],Ab:N[r+24>>2>>>0],Bb:N[r+28>>2>>>0],bc:N[r+32>>2>>>0],Yb:N[r+36>>2>>>0],ac:l?O(l):""},n=O(n),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(c,"g"),l[c]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(c in l={"%a":function(e){return h[e.Ab].substring(0,3)},"%A":function(e){return h[e.Ab]},"%b":function(e){return d[e.Hb].substring(0,3)},"%B":function(e){return d[e.Hb]},"%C":function(e){return a((e.Cb+1900)/100|0,2)},"%d":function(e){return a(e.Kb,2)},"%e":function(e){return s(e.Kb,2," ")},"%g":function(e){return u(e).toString().substring(2)},"%G":function(e){return u(e)},"%H":function(e){return a(e.Gb,2)},"%I":function(e){return 0==(e=e.Gb)?e=12:12<e&&(e-=12),a(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.Hb-1;t+=(pe(e.Cb+1900)?fe:me)[n++]);return a(e.Kb+t,3)},"%m":function(e){return a(e.Hb+1,2)},"%M":function(e){return a(e.Zb,2)},"%n":function(){return"\n"},"%p":function(e){return 0<=e.Gb&&12>e.Gb?"AM":"PM"},"%S":function(e){return a(e.$b,2)},"%t":function(){return"\t"},"%u":function(e){return e.Ab||7},"%U":function(e){return a(Math.floor((e.Bb+7-e.Ab)/7),2)},"%V":function(e){var t=Math.floor((e.Bb+7-(e.Ab+6)%7)/7);if(2>=(e.Ab+371-e.Bb-2)%7&&t++,t)53==t&&(4==(n=(e.Ab+371-e.Bb)%7)||3==n&&pe(e.Cb)||(t=1));else{t=52;var n=(e.Ab+7-e.Bb-1)%7;(4==n||5==n&&pe(e.Cb%400-1))&&t++}return a(t,2)},"%w":function(e){return e.Ab},"%W":function(e){return a(Math.floor((e.Bb+7-(e.Ab+6)%7)/7),2)},"%y":function(e){return(e.Cb+1900).toString().substring(2)},"%Y":function(e){return e.Cb+1900},"%z":function(e){var t=0<=(e=e.Yb);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\0\0"),l)n.includes(c)&&(n=n.replace(new RegExp(c,"g"),l[c](r)));return c=function(e){var t=Array(D(e)+1);return R(e,t,0,t.length),t}(n=n.replace(/\0\0/g,"%")),c.length>t?0:(S.set(c,e>>>0),c.length-1)}var be={a:function(e){return xe(e+24)+24},m:function(e){return(e=new ne(e)).Pb()||(e.Ib(!0),ee--),e.Jb(!1),Q.push(e),e.Nb(),e.Qb()},ia:function(e){throw v("Unexpected exception thrown, this is not properly supported - aborting"),$=!0,e},w:function(){ke(0);var e=Q.pop();if(e.Xb()&&!e.Lb()){var t=e.Wb();t&&ae(t)(e.Db),re(e.Db)}te=0},d:function(){var e=te;if(!e)return de=0;var t=new ne(e);t.Fb(e);var n=t.Eb();if(!n)return de=0,e;for(var r=Array.prototype.slice.call(arguments),s=0;s<r.length;s++){var a=r[s];if(0===a||a===n)break;if(Ne(a,n,t.zb+16))return de=a,e}return de=n,e},k:function(){var e=te;if(!e)return de=0;var t=new ne(e);t.Fb(e);var n=t.Eb();if(!n)return de=0,e;for(var r=Array.prototype.slice.call(arguments),s=0;s<r.length;s++){var a=r[s];if(0===a||a===n)break;if(Ne(a,n,t.zb+16))return de=a,e}return de=n,e},g:function(){var e=te;if(!e)return de=0;var t=new ne(e);t.Fb(e);var n=t.Eb();if(!n)return de=0,e;for(var r=Array.prototype.slice.call(arguments),s=0;s<r.length;s++){var a=r[s];if(0===a||a===n)break;if(Ne(a,n,t.zb+16))return de=a,e}return de=n,e},s:re,L:function(){var e=Q.pop();e||q("no exception to throw");var t=e.Db;throw e.Lb()||(Q.push(e),e.Jb(!0),e.Ib(!1),ee++),te=t,t},b:function(e,t,n){throw new ne(e).Rb(t,n),te=e,ee++,e},la:function(){return ee},i:function(e){throw te||(te=e),e},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){q("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){q("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(e,t){e=new Date(1e3*(E[e>>>2]+4294967296*N[e+4>>>2])),N[t>>2>>>0]=e.getUTCSeconds(),N[t+4>>2>>>0]=e.getUTCMinutes(),N[t+8>>2>>>0]=e.getUTCHours(),N[t+12>>2>>>0]=e.getUTCDate(),N[t+16>>2>>>0]=e.getUTCMonth(),N[t+20>>2>>>0]=e.getUTCFullYear()-1900,N[t+24>>2>>>0]=e.getUTCDay(),N[t+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(e,t){e=new Date(1e3*(E[e>>>2]+4294967296*N[e+4>>>2])),N[t>>2>>>0]=e.getSeconds(),N[t+4>>2>>>0]=e.getMinutes(),N[t+8>>2>>>0]=e.getHours(),N[t+12>>2>>>0]=e.getDate(),N[t+16>>2>>>0]=e.getMonth(),N[t+20>>2>>>0]=e.getFullYear()-1900,N[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1);N[t+28>>2>>>0]=(e.getTime()-n.getTime())/864e5|0,N[t+36>>2>>>0]=-60*e.getTimezoneOffset();var r=new Date(e.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),N[t+32>>2>>>0]=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r))},Fa:function(e){var t=new Date(N[e+20>>2>>>0]+1900,N[e+16>>2>>>0],N[e+12>>2>>>0],N[e+8>>2>>>0],N[e+4>>2>>>0],N[e>>2>>>0],0),n=N[e+32>>2>>>0],r=t.getTimezoneOffset(),s=new Date(t.getFullYear(),0,1),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=s.getTimezoneOffset(),o=Math.min(i,a);return 0>n?N[e+32>>2>>>0]=Number(a!=i&&o==r):0<n!=(o==r)&&(a=Math.max(i,a),t.setTime(t.getTime()+6e4*((0<n?o:a)-r))),N[e+24>>2>>>0]=t.getDay(),N[e+28>>2>>>0]=(t.getTime()-s.getTime())/864e5|0,N[e>>2>>>0]=t.getSeconds(),N[e+4>>2>>>0]=t.getMinutes(),N[e+8>>2>>>0]=t.getHours(),N[e+12>>2>>>0]=t.getDate(),N[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function e(t,n,r){e.Vb||(e.Vb=!0,function(e,t,n){function r(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}var s=(new Date).getFullYear(),a=new Date(s,0,1),i=new Date(s,6,1);s=a.getTimezoneOffset();var o=i.getTimezoneOffset();N[e>>2>>>0]=60*Math.max(s,o),N[t>>2>>>0]=Number(s!=o),e=r(a),t=r(i),e=ie(e),t=ie(t),o<s?(E[n>>2>>>0]=e,E[n+4>>2>>>0]=t):(E[n>>2>>>0]=t,E[n+4>>2>>>0]=e)}(t,n,r))},B:function(){q("")},ma:function(){return 4294901760},I:b?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),xa:function(e,t,n){I.copyWithin(e>>>0,t>>>0,t+n>>>0)},G:function(e){var t=I.length;if(4294901760<(e>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var s=Math;r=Math.max(e,r),s=s.min.call(s,4294901760,r+(65536-r%65536)%65536);e:{try{k.grow(s-T.byteLength+65535>>>16),F();var a=1;break e}catch(e){}a=void 0}if(a)return!0}return!1},va:function(e,t){var n=0;return ue().forEach(function(r,s){var a=t+n;for(s=E[e+4*s>>2>>>0]=a,a=0;a<r.length;++a)S[(0|s++)>>>0]=r.charCodeAt(a);S[(0|s)>>>0]=0,n+=r.length+1}),0},wa:function(e,t){var n=ue();E[e>>2>>>0]=n.length;var r=0;return n.forEach(function(e){r+=e.length+1}),E[t>>2>>>0]=r,0},ba:function(e){_||0<U||(_e(),J(z),ve(0),ce[1].length&&he(1,10),ce[2].length&&he(2,10)),_||0<U||(t.onExit&&t.onExit(e),$=!0),f(e,new Z(e))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(e,t,n,r){for(var s=0,a=0;a<n;a++){var i=E[t>>2>>>0],o=E[t+4>>2>>>0];t+=8;for(var u=0;u<o;u++)he(e,I[i+u>>>0]);s+=o}return E[r>>2>>>0]=s,0},c:function(){return de},ja:function e(t,r){e.Mb||(e.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(b)try{var t=n(Object(function(){var e=new Error("Cannot find module 'crypto'");throw e.code="MODULE_NOT_FOUND",e}()));return()=>t.randomBytes(1)[0]}catch(e){}return()=>q("randomDevice")}());for(var s=0;s<r;s++)S[(t+s|0)>>>0]=e.Mb();return 0},ea:function(e,t,n){var r=Te();try{return ae(e)(t,n)}catch(e){if(Se(r),e!==e+0)throw e;ke(1,0)}},fa:function(e,t,n){var r=Te();try{return ae(e)(t,n)}catch(e){if(Se(r),e!==e+0)throw e;ke(1,0)}},J:function(e){var t=Te();try{return ae(e)()}catch(e){if(Se(t),e!==e+0)throw e;ke(1,0)}},e:function(e,t){var n=Te();try{return ae(e)(t)}catch(e){if(Se(n),e!==e+0)throw e;ke(1,0)}},N:function(e,t,n){var r=Te();try{return ae(e)(t,n)}catch(e){if(Se(r),e!==e+0)throw e;ke(1,0)}},O:function(e,t,n){var r=Te();try{return ae(e)(t,n)}catch(e){if(Se(r),e!==e+0)throw e;ke(1,0)}},j:function(e,t,n){var r=Te();try{return ae(e)(t,n)}catch(e){if(Se(r),e!==e+0)throw e;ke(1,0)}},o:function(e,t,n,r){var s=Te();try{return ae(e)(t,n,r)}catch(e){if(Se(s),e!==e+0)throw e;ke(1,0)}},p:function(e,t,n,r,s){var a=Te();try{return ae(e)(t,n,r,s)}catch(e){if(Se(a),e!==e+0)throw e;ke(1,0)}},M:function(e,t,n,r,s,a){var i=Te();try{return ae(e)(t,n,r,s,a)}catch(e){if(Se(i),e!==e+0)throw e;ke(1,0)}},r:function(e,t,n,r,s,a){var i=Te();try{return ae(e)(t,n,r,s,a)}catch(e){if(Se(i),e!==e+0)throw e;ke(1,0)}},v:function(e,t,n,r,s,a,i){var o=Te();try{return ae(e)(t,n,r,s,a,i)}catch(e){if(Se(o),e!==e+0)throw e;ke(1,0)}},K:function(e,t,n,r,s,a,i,o){var u=Te();try{return ae(e)(t,n,r,s,a,i,o)}catch(e){if(Se(u),e!==e+0)throw e;ke(1,0)}},D:function(e,t,n,r,s,a,i,o,u,l,c,h){var d=Te();try{return ae(e)(t,n,r,s,a,i,o,u,l,c,h)}catch(e){if(Se(d),e!==e+0)throw e;ke(1,0)}},X:function(e,t,n,r,s,a,i,o){var u=Te();try{return Me(e,t,n,r,s,a,i,o)}catch(e){if(Se(u),e!==e+0)throw e;ke(1,0)}},V:function(e,t,n,r,s,a,i){var o=Te();try{return Ae(e,t,n,r,s,a,i)}catch(e){if(Se(o),e!==e+0)throw e;ke(1,0)}},U:function(e,t,n,r,s){var a=Te();try{return Le(e,t,n,r,s)}catch(e){if(Se(a),e!==e+0)throw e;ke(1,0)}},Z:function(e,t,n,r){var s=Te();try{return Fe(e,t,n,r)}catch(e){if(Se(s),e!==e+0)throw e;ke(1,0)}},W:function(e){var t=Te();try{return $e(e)}catch(e){if(Se(t),e!==e+0)throw e;ke(1,0)}},Y:function(e,t){var n=Te();try{return Pe(e,t)}catch(e){if(Se(n),e!==e+0)throw e;ke(1,0)}},T:function(e,t,n){var r=Te();try{return Ce(e,t,n)}catch(e){if(Se(r),e!==e+0)throw e;ke(1,0)}},f:function(e){var t=Te();try{ae(e)()}catch(e){if(Se(t),e!==e+0)throw e;ke(1,0)}},q:function(e,t){var n=Te();try{ae(e)(t)}catch(e){if(Se(n),e!==e+0)throw e;ke(1,0)}},h:function(e,t,n){var r=Te();try{ae(e)(t,n)}catch(e){if(Se(r),e!==e+0)throw e;ke(1,0)}},da:function(e,t,n,r){var s=Te();try{ae(e)(t,n,r)}catch(e){if(Se(s),e!==e+0)throw e;ke(1,0)}},l:function(e,t,n,r){var s=Te();try{ae(e)(t,n,r)}catch(e){if(Se(s),e!==e+0)throw e;ke(1,0)}},t:function(e,t,n,r,s){var a=Te();try{ae(e)(t,n,r,s)}catch(e){if(Se(a),e!==e+0)throw e;ke(1,0)}},u:function(e,t,n,r,s,a){var i=Te();try{ae(e)(t,n,r,s,a)}catch(e){if(Se(i),e!==e+0)throw e;ke(1,0)}},x:function(e,t,n,r,s,a,i){var o=Te();try{ae(e)(t,n,r,s,a,i)}catch(e){if(Se(o),e!==e+0)throw e;ke(1,0)}},z:function(e,t,n,r,s,a,i,o){var u=Te();try{ae(e)(t,n,r,s,a,i,o)}catch(e){if(Se(u),e!==e+0)throw e;ke(1,0)}},ga:function(e,t,n,r,s,a,i,o,u){var l=Te();try{ae(e)(t,n,r,s,a,i,o,u)}catch(e){if(Se(l),e!==e+0)throw e;ke(1,0)}},A:function(e,t,n,r,s,a,i,o,u,l,c){var h=Te();try{ae(e)(t,n,r,s,a,i,o,u,l,c)}catch(e){if(Se(h),e!==e+0)throw e;ke(1,0)}},C:function(e,t,n,r,s,a,i,o,u,l,c,h,d,p,f,m){var g=Te();try{ae(e)(t,n,r,s,a,i,o,u,l,c,h,d,p,f,m)}catch(e){if(Se(g),e!==e+0)throw e;ke(1,0)}},aa:function(e,t,n,r,s,a,i,o){var u=Te();try{Oe(e,t,n,r,s,a,i,o)}catch(e){if(Se(u),e!==e+0)throw e;ke(1,0)}},_:function(e,t,n,r,s,a,i,o,u,l,c,h){var d=Te();try{De(e,t,n,r,s,a,i,o,u,l,c,h)}catch(e){if(Se(d),e!==e+0)throw e;ke(1,0)}},$:function(e,t,n,r,s,a){var i=Te();try{Re(e,t,n,r,s,a)}catch(e){if(Se(i),e!==e+0)throw e;ke(1,0)}},n:function(e){return e},F:function(e){de=e},ha:ge,y:function(e,t,n,r){return ge(e,t,n,r)}};!function(){function e(e){t.asm=e.exports,k=t.asm.Ka,F(),P=t.asm.ib,L.unshift(t.asm.La),j--,t.monitorRunDependencies&&t.monitorRunDependencies(j),0==j&&(null!==G&&(clearInterval(G),G=null),H&&(e=H,H=null,e()))}function n(t){e(t.instance)}function r(e){return function(){if(!x&&(m||g)){if("function"==typeof fetch&&!W.startsWith("file://"))return fetch(W,{credentials:"same-origin"}).then(function(e){if(!e.ok)throw"failed to load wasm binary file at '"+W+"'";return e.arrayBuffer()}).catch(function(){return Y()});if(o)return new Promise(function(e,t){o(W,function(t){e(new Uint8Array(t))},t)})}return Promise.resolve().then(function(){return Y()})}().then(function(e){return WebAssembly.instantiate(e,s)}).then(function(e){return e}).then(e,function(e){v("failed to asynchronously prepare wasm: "+e),q(e)})}var s={a:be};if(j++,t.monitorRunDependencies&&t.monitorRunDependencies(j),t.instantiateWasm)try{return t.instantiateWasm(s,e)}catch(e){return v("Module.instantiateWasm callback failed with error: "+e),!1}(x||"function"!=typeof WebAssembly.instantiateStreaming||K()||W.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(W,{credentials:"same-origin"}).then(function(e){return WebAssembly.instantiateStreaming(e,s).then(n,function(e){return v("wasm streaming compile failed: "+e),v("falling back to ArrayBuffer instantiation"),r(n)})})).catch(a)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.La).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.Ma).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.Na).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.Oa).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.Pa).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.Qa).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.Ra).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.Sa).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.Ta).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.Ua).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm.Va).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.Wa).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.Xa).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.Ya).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.Za).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm._a).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.$a).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.ab).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.bb).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.cb).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.db).apply(null,arguments)};var ye,xe=t._malloc=function(){return(xe=t._malloc=t.asm.eb).apply(null,arguments)},we=t._free=function(){return(we=t._free=t.asm.fb).apply(null,arguments)},ve=t._fflush=function(){return(ve=t._fflush=t.asm.gb).apply(null,arguments)},_e=t.___funcs_on_exit=function(){return(_e=t.___funcs_on_exit=t.asm.hb).apply(null,arguments)},ke=t._setThrew=function(){return(ke=t._setThrew=t.asm.jb).apply(null,arguments)},Te=t.stackSave=function(){return(Te=t.stackSave=t.asm.kb).apply(null,arguments)},Se=t.stackRestore=function(){return(Se=t.stackRestore=t.asm.lb).apply(null,arguments)},Ie=t.stackAlloc=function(){return(Ie=t.stackAlloc=t.asm.mb).apply(null,arguments)},Ne=t.___cxa_can_catch=function(){return(Ne=t.___cxa_can_catch=t.asm.nb).apply(null,arguments)},Ee=t.___cxa_is_pointer_type=function(){return(Ee=t.___cxa_is_pointer_type=t.asm.ob).apply(null,arguments)},$e=t.dynCall_j=function(){return($e=t.dynCall_j=t.asm.pb).apply(null,arguments)},Ae=t.dynCall_iiiiij=function(){return(Ae=t.dynCall_iiiiij=t.asm.qb).apply(null,arguments)},Ce=t.dynCall_jii=function(){return(Ce=t.dynCall_jii=t.asm.rb).apply(null,arguments)},Oe=t.dynCall_viiiiij=function(){return(Oe=t.dynCall_viiiiij=t.asm.sb).apply(null,arguments)},Re=t.dynCall_vjji=function(){return(Re=t.dynCall_vjji=t.asm.tb).apply(null,arguments)},De=t.dynCall_viiijjjii=function(){return(De=t.dynCall_viiijjjii=t.asm.ub).apply(null,arguments)},Fe=t.dynCall_iij=function(){return(Fe=t.dynCall_iij=t.asm.vb).apply(null,arguments)},Pe=t.dynCall_ji=function(){return(Pe=t.dynCall_ji=t.asm.wb).apply(null,arguments)},Me=t.dynCall_iiiiiij=function(){return(Me=t.dynCall_iiiiiij=t.asm.xb).apply(null,arguments)},Le=t.dynCall_iiij=function(){return(Le=t.dynCall_iiij=t.asm.yb).apply(null,arguments)};function ze(){function e(){if(!ye&&(ye=!0,t.calledRun=!0,!$)){if(J(L),s(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();B.unshift(e)}J(B)}}if(!(0<j)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)V();J(M),0<j||(t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),e()},1)):e())}}if(t.UTF8ToString=O,t.stringToUTF8=function(e,t,n){return R(e,I,t,n)},t.lengthBytesUTF8=D,t.stackSave=Te,t.stackRestore=Se,t.stackAlloc=Ie,H=function e(){ye||ze(),ye||(H=e)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return ze(),e.ready});e.exports=s},4537:e=>{"use strict";e.exports=function(e,t){for(var n=new Array(arguments.length-1),r=0,s=2,a=!0;s<arguments.length;)n[r++]=arguments[s++];return new Promise(function(s,i){n[r]=function(e){if(a)if(a=!1,e)i(e);else{for(var t=new Array(arguments.length-1),n=0;n<t.length;)t[n++]=arguments[n];s.apply(null,t)}};try{e.apply(t||null,n)}catch(e){a&&(a=!1,i(e))}})}},7419:(e,t)=>{"use strict";var n=t;n.length=function(e){var t=e.length;if(!t)return 0;for(var n=0;--t%4>1&&"="===e.charAt(t);)++n;return Math.ceil(3*e.length)/4-n};for(var r=new Array(64),s=new Array(123),a=0;a<64;)s[r[a]=a<26?a+65:a<52?a+71:a<62?a-4:a-59|43]=a++;n.encode=function(e,t,n){for(var s,a=null,i=[],o=0,u=0;t<n;){var l=e[t++];switch(u){case 0:i[o++]=r[l>>2],s=(3&l)<<4,u=1;break;case 1:i[o++]=r[s|l>>4],s=(15&l)<<2,u=2;break;case 2:i[o++]=r[s|l>>6],i[o++]=r[63&l],u=0}o>8191&&((a||(a=[])).push(String.fromCharCode.apply(String,i)),o=0)}return u&&(i[o++]=r[s],i[o++]=61,1===u&&(i[o++]=61)),a?(o&&a.push(String.fromCharCode.apply(String,i.slice(0,o))),a.join("")):String.fromCharCode.apply(String,i.slice(0,o))};var i="invalid encoding";n.decode=function(e,t,n){for(var r,a=n,o=0,u=0;u<e.length;){var l=e.charCodeAt(u++);if(61===l&&o>1)break;if(void 0===(l=s[l]))throw Error(i);switch(o){case 0:r=l,o=1;break;case 1:t[n++]=r<<2|(48&l)>>4,r=l,o=2;break;case 2:t[n++]=(15&r)<<4|(60&l)>>2,r=l,o=3;break;case 3:t[n++]=(3&r)<<6|l,o=0}}if(1===o)throw Error(i);return n-a},n.test=function(e){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}},9211:e=>{"use strict";function t(){this._listeners={}}e.exports=t,t.prototype.on=function(e,t,n){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:t,ctx:n||this}),this},t.prototype.off=function(e,t){if(void 0===e)this._listeners={};else if(void 0===t)this._listeners[e]=[];else for(var n=this._listeners[e],r=0;r<n.length;)n[r].fn===t?n.splice(r,1):++r;return this},t.prototype.emit=function(e){var t=this._listeners[e];if(t){for(var n=[],r=1;r<arguments.length;)n.push(arguments[r++]);for(r=0;r<t.length;)t[r].fn.apply(t[r++].ctx,n)}return this}},945:e=>{"use strict";function t(e){return"undefined"!=typeof Float32Array?function(){var t=new Float32Array([-0]),n=new Uint8Array(t.buffer),r=128===n[3];function s(e,r,s){t[0]=e,r[s]=n[0],r[s+1]=n[1],r[s+2]=n[2],r[s+3]=n[3]}function a(e,r,s){t[0]=e,r[s]=n[3],r[s+1]=n[2],r[s+2]=n[1],r[s+3]=n[0]}function i(e,r){return n[0]=e[r],n[1]=e[r+1],n[2]=e[r+2],n[3]=e[r+3],t[0]}function o(e,r){return n[3]=e[r],n[2]=e[r+1],n[1]=e[r+2],n[0]=e[r+3],t[0]}e.writeFloatLE=r?s:a,e.writeFloatBE=r?a:s,e.readFloatLE=r?i:o,e.readFloatBE=r?o:i}():function(){function t(e,t,n,r){var s=t<0?1:0;if(s&&(t=-t),0===t)e(1/t>0?0:2147483648,n,r);else if(isNaN(t))e(2143289344,n,r);else if(t>34028234663852886e22)e((s<<31|2139095040)>>>0,n,r);else if(t<11754943508222875e-54)e((s<<31|Math.round(t/1401298464324817e-60))>>>0,n,r);else{var a=Math.floor(Math.log(t)/Math.LN2);e((s<<31|a+127<<23|8388607&Math.round(t*Math.pow(2,-a)*8388608))>>>0,n,r)}}function i(e,t,n){var r=e(t,n),s=2*(r>>31)+1,a=r>>>23&255,i=8388607&r;return 255===a?i?NaN:s*(1/0):0===a?1401298464324817e-60*s*i:s*Math.pow(2,a-150)*(i+8388608)}e.writeFloatLE=t.bind(null,n),e.writeFloatBE=t.bind(null,r),e.readFloatLE=i.bind(null,s),e.readFloatBE=i.bind(null,a)}(),"undefined"!=typeof Float64Array?function(){var t=new Float64Array([-0]),n=new Uint8Array(t.buffer),r=128===n[7];function s(e,r,s){t[0]=e,r[s]=n[0],r[s+1]=n[1],r[s+2]=n[2],r[s+3]=n[3],r[s+4]=n[4],r[s+5]=n[5],r[s+6]=n[6],r[s+7]=n[7]}function a(e,r,s){t[0]=e,r[s]=n[7],r[s+1]=n[6],r[s+2]=n[5],r[s+3]=n[4],r[s+4]=n[3],r[s+5]=n[2],r[s+6]=n[1],r[s+7]=n[0]}function i(e,r){return n[0]=e[r],n[1]=e[r+1],n[2]=e[r+2],n[3]=e[r+3],n[4]=e[r+4],n[5]=e[r+5],n[6]=e[r+6],n[7]=e[r+7],t[0]}function o(e,r){return n[7]=e[r],n[6]=e[r+1],n[5]=e[r+2],n[4]=e[r+3],n[3]=e[r+4],n[2]=e[r+5],n[1]=e[r+6],n[0]=e[r+7],t[0]}e.writeDoubleLE=r?s:a,e.writeDoubleBE=r?a:s,e.readDoubleLE=r?i:o,e.readDoubleBE=r?o:i}():function(){function t(e,t,n,r,s,a){var i=r<0?1:0;if(i&&(r=-r),0===r)e(0,s,a+t),e(1/r>0?0:2147483648,s,a+n);else if(isNaN(r))e(0,s,a+t),e(2146959360,s,a+n);else if(r>17976931348623157e292)e(0,s,a+t),e((i<<31|2146435072)>>>0,s,a+n);else{var o;if(r<22250738585072014e-324)e((o=r/5e-324)>>>0,s,a+t),e((i<<31|o/4294967296)>>>0,s,a+n);else{var u=Math.floor(Math.log(r)/Math.LN2);1024===u&&(u=1023),e(4503599627370496*(o=r*Math.pow(2,-u))>>>0,s,a+t),e((i<<31|u+1023<<20|1048576*o&1048575)>>>0,s,a+n)}}}function i(e,t,n,r,s){var a=e(r,s+t),i=e(r,s+n),o=2*(i>>31)+1,u=i>>>20&2047,l=4294967296*(1048575&i)+a;return 2047===u?l?NaN:o*(1/0):0===u?5e-324*o*l:o*Math.pow(2,u-1075)*(l+4503599627370496)}e.writeDoubleLE=t.bind(null,n,0,4),e.writeDoubleBE=t.bind(null,r,4,0),e.readDoubleLE=i.bind(null,s,0,4),e.readDoubleBE=i.bind(null,a,4,0)}(),e}function n(e,t,n){t[n]=255&e,t[n+1]=e>>>8&255,t[n+2]=e>>>16&255,t[n+3]=e>>>24}function r(e,t,n){t[n]=e>>>24,t[n+1]=e>>>16&255,t[n+2]=e>>>8&255,t[n+3]=255&e}function s(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0}function a(e,t){return(e[t]<<24|e[t+1]<<16|e[t+2]<<8|e[t+3])>>>0}e.exports=t(t)},7199:module=>{"use strict";function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}module.exports=inquire},6662:e=>{"use strict";e.exports=function(e,t,n){var r=n||8192,s=r>>>1,a=null,i=r;return function(n){if(n<1||n>s)return e(n);i+n>r&&(a=e(r),i=0);var o=t.call(a,i,i+=n);return 7&i&&(i=1+(7|i)),o}}},4997:(e,t)=>{"use strict";var n=t;n.length=function(e){for(var t=0,n=0,r=0;r<e.length;++r)(n=e.charCodeAt(r))<128?t+=1:n<2048?t+=2:55296==(64512&n)&&56320==(64512&e.charCodeAt(r+1))?(++r,t+=4):t+=3;return t},n.read=function(e,t,n){if(n-t<1)return"";for(var r,s=null,a=[],i=0;t<n;)(r=e[t++])<128?a[i++]=r:r>191&&r<224?a[i++]=(31&r)<<6|63&e[t++]:r>239&&r<365?(r=((7&r)<<18|(63&e[t++])<<12|(63&e[t++])<<6|63&e[t++])-65536,a[i++]=55296+(r>>10),a[i++]=56320+(1023&r)):a[i++]=(15&r)<<12|(63&e[t++])<<6|63&e[t++],i>8191&&((s||(s=[])).push(String.fromCharCode.apply(String,a)),i=0);return s?(i&&s.push(String.fromCharCode.apply(String,a.slice(0,i))),s.join("")):String.fromCharCode.apply(String,a.slice(0,i))},n.write=function(e,t,n){for(var r,s,a=n,i=0;i<e.length;++i)(r=e.charCodeAt(i))<128?t[n++]=r:r<2048?(t[n++]=r>>6|192,t[n++]=63&r|128):55296==(64512&r)&&56320==(64512&(s=e.charCodeAt(i+1)))?(r=65536+((1023&r)<<10)+(1023&s),++i,t[n++]=r>>18|240,t[n++]=r>>12&63|128,t[n++]=r>>6&63|128,t[n++]=63&r|128):(t[n++]=r>>12|224,t[n++]=r>>6&63|128,t[n++]=63&r|128);return n-a}},3442:(e,t)=>{"use strict";t.__esModule=!0;var n=function(){function e(t){if(!t)throw new TypeError("Invalid argument; `value` has no value.");this.value=e.EMPTY,t&&e.isGuid(t)&&(this.value=t)}return e.isGuid=function(t){var n=t.toString();return t&&(t instanceof e||e.validator.test(n))},e.create=function(){return new e([e.gen(2),e.gen(1),e.gen(1),e.gen(1),e.gen(3)].join("-"))},e.createEmpty=function(){return new e("emptyguid")},e.parse=function(t){return new e(t)},e.raw=function(){return[e.gen(2),e.gen(1),e.gen(1),e.gen(1),e.gen(3)].join("-")},e.gen=function(e){for(var t="",n=0;n<e;n++)t+=(65536*(1+Math.random())|0).toString(16).substring(1);return t},e.prototype.equals=function(t){return e.isGuid(t)&&this.value===t.toString()},e.prototype.isEmpty=function(){return this.value===e.EMPTY},e.prototype.toString=function(){return this.value},e.prototype.toJSON=function(){return{value:this.value}},e.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),e.EMPTY="00000000-0000-0000-0000-000000000000",e}();t.Guid=n},3720:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var s={},a={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=a[e])?r:(n=u(e,(0|e)<0?-1:0,!0),i&&(a[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=u(e,e<0?-1:0,!1),i&&(s[e]=n),n)}function o(e,t){if(isNaN(e))return t?b:g;if(t){if(e<0)return b;if(e>=p)return _}else{if(e<=-f)return k;if(e+1>=f)return v}return e<0?o(-e,t).neg():u(e%d|0,e/d|0,t)}function u(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=o,n.fromBits=u;var l=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var s=o(l(n,8)),a=g,i=0;i<e.length;i+=8){var u=Math.min(8,e.length-i),h=parseInt(e.substring(i,i+u),n);if(u<8){var d=o(l(n,u));a=a.mul(d).add(o(h))}else a=(a=a.mul(s)).add(o(h))}return a.unsigned=t,a}function h(e,t){return"number"==typeof e?o(e,t):"string"==typeof e?c(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var b=i(0,!0);n.UZERO=b;var y=i(1);n.ONE=y;var x=i(1,!0);n.UONE=x;var w=i(-1);n.NEG_ONE=w;var v=u(-1,2147483647,!1);n.MAX_VALUE=v;var _=u(-1,-1,!0);n.MAX_UNSIGNED_VALUE=_;var k=u(0,-2147483648,!1);n.MIN_VALUE=k;var T=n.prototype;T.toInt=function(){return this.unsigned?this.low>>>0:this.low},T.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},T.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(k)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=o(l(e,6),this.unsigned),a=this,i="";;){var u=a.div(s),c=(a.sub(u.mul(s)).toInt()>>>0).toString(e);if((a=u).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},T.getHighBits=function(){return this.high},T.getHighBitsUnsigned=function(){return this.high>>>0},T.getLowBits=function(){return this.low},T.getLowBitsUnsigned=function(){return this.low>>>0},T.getNumBitsAbs=function(){if(this.isNegative())return this.eq(k)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},T.isZero=function(){return 0===this.high&&0===this.low},T.eqz=T.isZero,T.isNegative=function(){return!this.unsigned&&this.high<0},T.isPositive=function(){return this.unsigned||this.high>=0},T.isOdd=function(){return!(1&~this.low)},T.isEven=function(){return!(1&this.low)},T.equals=function(e){return r(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},T.eq=T.equals,T.notEquals=function(e){return!this.eq(e)},T.neq=T.notEquals,T.ne=T.notEquals,T.lessThan=function(e){return this.comp(e)<0},T.lt=T.lessThan,T.lessThanOrEqual=function(e){return this.comp(e)<=0},T.lte=T.lessThanOrEqual,T.le=T.lessThanOrEqual,T.greaterThan=function(e){return this.comp(e)>0},T.gt=T.greaterThan,T.greaterThanOrEqual=function(e){return this.comp(e)>=0},T.gte=T.greaterThanOrEqual,T.ge=T.greaterThanOrEqual,T.compare=function(e){if(r(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},T.comp=T.compare,T.negate=function(){return!this.unsigned&&this.eq(k)?k:this.not().add(y)},T.neg=T.negate,T.add=function(e){r(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,s=this.low>>>16,a=65535&this.low,i=e.high>>>16,o=65535&e.high,l=e.low>>>16,c=0,d=0,p=0,f=0;return p+=(f+=a+(65535&e.low))>>>16,d+=(p+=s+l)>>>16,c+=(d+=n+o)>>>16,c+=t+i,u((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},T.subtract=function(e){return r(e)||(e=h(e)),this.add(e.neg())},T.sub=T.subtract,T.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=h(e)),t)return u(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(k))return e.isOdd()?k:g;if(e.eq(k))return this.isOdd()?k:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,s=65535&this.high,a=this.low>>>16,i=65535&this.low,l=e.high>>>16,c=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,b=0,y=0,x=0;return y+=(x+=i*p)>>>16,b+=(y+=a*p)>>>16,y&=65535,b+=(y+=i*d)>>>16,f+=(b+=s*p)>>>16,b&=65535,f+=(b+=a*d)>>>16,b&=65535,f+=(b+=i*c)>>>16,f+=n*p+s*d+a*c+i*l,u((y&=65535)<<16|(x&=65535),(f&=65535)<<16|(b&=65535),this.unsigned)},T.mul=T.multiply,T.divide=function(e){if(r(e)||(e=h(e)),e.isZero())throw Error("division by zero");var n,s,a;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return x;a=b}else{if(this.eq(k))return e.eq(y)||e.eq(w)?k:e.eq(k)?y:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?y:w:(s=this.sub(e.mul(n)),a=n.add(s.div(e)));if(e.eq(k))return this.unsigned?b:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=g}for(s=this;s.gte(e);){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:l(2,i-48),d=o(n),p=d.mul(e);p.isNegative()||p.gt(s);)p=(d=o(n-=c,this.unsigned)).mul(e);d.isZero()&&(d=y),a=a.add(d),s=s.sub(p)}return a},T.div=T.divide,T.modulo=function(e){return r(e)||(e=h(e)),t?u((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},T.mod=T.modulo,T.rem=T.modulo,T.not=function(){return u(~this.low,~this.high,this.unsigned)},T.and=function(e){return r(e)||(e=h(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},T.or=function(e){return r(e)||(e=h(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},T.xor=function(e){return r(e)||(e=h(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},T.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},T.shl=T.shiftLeft,T.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},T.shr=T.shiftRight,T.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},T.shru=T.shiftRightUnsigned,T.shr_u=T.shiftRightUnsigned,T.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},T.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},T.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},T.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},T.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},1446:(e,t,n)=>{"use strict";var r,s,a,i=n(2100),o=i.Reader,u=i.Writer,l=i.util,c=i.roots.default||(i.roots.default={});c.onnx=((a={}).Version=(r={},(s=Object.create(r))[r[0]="_START_VERSION"]=0,s[r[1]="IR_VERSION_2017_10_10"]=1,s[r[2]="IR_VERSION_2017_10_30"]=2,s[r[3]="IR_VERSION_2017_11_3"]=3,s[r[4]="IR_VERSION_2019_1_22"]=4,s[r[5]="IR_VERSION"]=5,s),a.AttributeProto=function(){function e(e){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.name="",e.prototype.refAttrName="",e.prototype.docString="",e.prototype.type=0,e.prototype.f=0,e.prototype.i=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.s=l.newBuffer([]),e.prototype.t=null,e.prototype.g=null,e.prototype.floats=l.emptyArray,e.prototype.ints=l.emptyArray,e.prototype.strings=l.emptyArray,e.prototype.tensors=l.emptyArray,e.prototype.graphs=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.name&&e.hasOwnProperty("name")&&t.uint32(10).string(e.name),null!=e.f&&e.hasOwnProperty("f")&&t.uint32(21).float(e.f),null!=e.i&&e.hasOwnProperty("i")&&t.uint32(24).int64(e.i),null!=e.s&&e.hasOwnProperty("s")&&t.uint32(34).bytes(e.s),null!=e.t&&e.hasOwnProperty("t")&&c.onnx.TensorProto.encode(e.t,t.uint32(42).fork()).ldelim(),null!=e.g&&e.hasOwnProperty("g")&&c.onnx.GraphProto.encode(e.g,t.uint32(50).fork()).ldelim(),null!=e.floats&&e.floats.length){t.uint32(58).fork();for(var n=0;n<e.floats.length;++n)t.float(e.floats[n]);t.ldelim()}if(null!=e.ints&&e.ints.length){for(t.uint32(66).fork(),n=0;n<e.ints.length;++n)t.int64(e.ints[n]);t.ldelim()}if(null!=e.strings&&e.strings.length)for(n=0;n<e.strings.length;++n)t.uint32(74).bytes(e.strings[n]);if(null!=e.tensors&&e.tensors.length)for(n=0;n<e.tensors.length;++n)c.onnx.TensorProto.encode(e.tensors[n],t.uint32(82).fork()).ldelim();if(null!=e.graphs&&e.graphs.length)for(n=0;n<e.graphs.length;++n)c.onnx.GraphProto.encode(e.graphs[n],t.uint32(90).fork()).ldelim();return null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(106).string(e.docString),null!=e.type&&e.hasOwnProperty("type")&&t.uint32(160).int32(e.type),null!=e.refAttrName&&e.hasOwnProperty("refAttrName")&&t.uint32(170).string(e.refAttrName),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.AttributeProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.name=e.string();break;case 21:r.refAttrName=e.string();break;case 13:r.docString=e.string();break;case 20:r.type=e.int32();break;case 2:r.f=e.float();break;case 3:r.i=e.int64();break;case 4:r.s=e.bytes();break;case 5:r.t=c.onnx.TensorProto.decode(e,e.uint32());break;case 6:r.g=c.onnx.GraphProto.decode(e,e.uint32());break;case 7:if(r.floats&&r.floats.length||(r.floats=[]),2==(7&s))for(var a=e.uint32()+e.pos;e.pos<a;)r.floats.push(e.float());else r.floats.push(e.float());break;case 8:if(r.ints&&r.ints.length||(r.ints=[]),2==(7&s))for(a=e.uint32()+e.pos;e.pos<a;)r.ints.push(e.int64());else r.ints.push(e.int64());break;case 9:r.strings&&r.strings.length||(r.strings=[]),r.strings.push(e.bytes());break;case 10:r.tensors&&r.tensors.length||(r.tensors=[]),r.tensors.push(c.onnx.TensorProto.decode(e,e.uint32()));break;case 11:r.graphs&&r.graphs.length||(r.graphs=[]),r.graphs.push(c.onnx.GraphProto.decode(e,e.uint32()));break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.name&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(null!=e.refAttrName&&e.hasOwnProperty("refAttrName")&&!l.isString(e.refAttrName))return"refAttrName: string expected";if(null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(null!=e.type&&e.hasOwnProperty("type"))switch(e.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(null!=e.f&&e.hasOwnProperty("f")&&"number"!=typeof e.f)return"f: number expected";if(null!=e.i&&e.hasOwnProperty("i")&&!(l.isInteger(e.i)||e.i&&l.isInteger(e.i.low)&&l.isInteger(e.i.high)))return"i: integer|Long expected";if(null!=e.s&&e.hasOwnProperty("s")&&!(e.s&&"number"==typeof e.s.length||l.isString(e.s)))return"s: buffer expected";if(null!=e.t&&e.hasOwnProperty("t")&&(n=c.onnx.TensorProto.verify(e.t)))return"t."+n;if(null!=e.g&&e.hasOwnProperty("g")&&(n=c.onnx.GraphProto.verify(e.g)))return"g."+n;if(null!=e.floats&&e.hasOwnProperty("floats")){if(!Array.isArray(e.floats))return"floats: array expected";for(var t=0;t<e.floats.length;++t)if("number"!=typeof e.floats[t])return"floats: number[] expected"}if(null!=e.ints&&e.hasOwnProperty("ints")){if(!Array.isArray(e.ints))return"ints: array expected";for(t=0;t<e.ints.length;++t)if(!(l.isInteger(e.ints[t])||e.ints[t]&&l.isInteger(e.ints[t].low)&&l.isInteger(e.ints[t].high)))return"ints: integer|Long[] expected"}if(null!=e.strings&&e.hasOwnProperty("strings")){if(!Array.isArray(e.strings))return"strings: array expected";for(t=0;t<e.strings.length;++t)if(!(e.strings[t]&&"number"==typeof e.strings[t].length||l.isString(e.strings[t])))return"strings: buffer[] expected"}if(null!=e.tensors&&e.hasOwnProperty("tensors")){if(!Array.isArray(e.tensors))return"tensors: array expected";for(t=0;t<e.tensors.length;++t)if(n=c.onnx.TensorProto.verify(e.tensors[t]))return"tensors."+n}if(null!=e.graphs&&e.hasOwnProperty("graphs")){if(!Array.isArray(e.graphs))return"graphs: array expected";for(t=0;t<e.graphs.length;++t){var n;if(n=c.onnx.GraphProto.verify(e.graphs[t]))return"graphs."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.AttributeProto)return e;var t=new c.onnx.AttributeProto;switch(null!=e.name&&(t.name=String(e.name)),null!=e.refAttrName&&(t.refAttrName=String(e.refAttrName)),null!=e.docString&&(t.docString=String(e.docString)),e.type){case"UNDEFINED":case 0:t.type=0;break;case"FLOAT":case 1:t.type=1;break;case"INT":case 2:t.type=2;break;case"STRING":case 3:t.type=3;break;case"TENSOR":case 4:t.type=4;break;case"GRAPH":case 5:t.type=5;break;case"FLOATS":case 6:t.type=6;break;case"INTS":case 7:t.type=7;break;case"STRINGS":case 8:t.type=8;break;case"TENSORS":case 9:t.type=9;break;case"GRAPHS":case 10:t.type=10}if(null!=e.f&&(t.f=Number(e.f)),null!=e.i&&(l.Long?(t.i=l.Long.fromValue(e.i)).unsigned=!1:"string"==typeof e.i?t.i=parseInt(e.i,10):"number"==typeof e.i?t.i=e.i:"object"==typeof e.i&&(t.i=new l.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber())),null!=e.s&&("string"==typeof e.s?l.base64.decode(e.s,t.s=l.newBuffer(l.base64.length(e.s)),0):e.s.length&&(t.s=e.s)),null!=e.t){if("object"!=typeof e.t)throw TypeError(".onnx.AttributeProto.t: object expected");t.t=c.onnx.TensorProto.fromObject(e.t)}if(null!=e.g){if("object"!=typeof e.g)throw TypeError(".onnx.AttributeProto.g: object expected");t.g=c.onnx.GraphProto.fromObject(e.g)}if(e.floats){if(!Array.isArray(e.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");t.floats=[];for(var n=0;n<e.floats.length;++n)t.floats[n]=Number(e.floats[n])}if(e.ints){if(!Array.isArray(e.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(t.ints=[],n=0;n<e.ints.length;++n)l.Long?(t.ints[n]=l.Long.fromValue(e.ints[n])).unsigned=!1:"string"==typeof e.ints[n]?t.ints[n]=parseInt(e.ints[n],10):"number"==typeof e.ints[n]?t.ints[n]=e.ints[n]:"object"==typeof e.ints[n]&&(t.ints[n]=new l.LongBits(e.ints[n].low>>>0,e.ints[n].high>>>0).toNumber())}if(e.strings){if(!Array.isArray(e.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(t.strings=[],n=0;n<e.strings.length;++n)"string"==typeof e.strings[n]?l.base64.decode(e.strings[n],t.strings[n]=l.newBuffer(l.base64.length(e.strings[n])),0):e.strings[n].length&&(t.strings[n]=e.strings[n])}if(e.tensors){if(!Array.isArray(e.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(t.tensors=[],n=0;n<e.tensors.length;++n){if("object"!=typeof e.tensors[n])throw TypeError(".onnx.AttributeProto.tensors: object expected");t.tensors[n]=c.onnx.TensorProto.fromObject(e.tensors[n])}}if(e.graphs){if(!Array.isArray(e.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(t.graphs=[],n=0;n<e.graphs.length;++n){if("object"!=typeof e.graphs[n])throw TypeError(".onnx.AttributeProto.graphs: object expected");t.graphs[n]=c.onnx.GraphProto.fromObject(e.graphs[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.floats=[],n.ints=[],n.strings=[],n.tensors=[],n.graphs=[]),t.defaults){if(n.name="",n.f=0,l.Long){var r=new l.Long(0,0,!1);n.i=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.i=t.longs===String?"0":0;t.bytes===String?n.s="":(n.s=[],t.bytes!==Array&&(n.s=l.newBuffer(n.s))),n.t=null,n.g=null,n.docString="",n.type=t.enums===String?"UNDEFINED":0,n.refAttrName=""}if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.f&&e.hasOwnProperty("f")&&(n.f=t.json&&!isFinite(e.f)?String(e.f):e.f),null!=e.i&&e.hasOwnProperty("i")&&("number"==typeof e.i?n.i=t.longs===String?String(e.i):e.i:n.i=t.longs===String?l.Long.prototype.toString.call(e.i):t.longs===Number?new l.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber():e.i),null!=e.s&&e.hasOwnProperty("s")&&(n.s=t.bytes===String?l.base64.encode(e.s,0,e.s.length):t.bytes===Array?Array.prototype.slice.call(e.s):e.s),null!=e.t&&e.hasOwnProperty("t")&&(n.t=c.onnx.TensorProto.toObject(e.t,t)),null!=e.g&&e.hasOwnProperty("g")&&(n.g=c.onnx.GraphProto.toObject(e.g,t)),e.floats&&e.floats.length){n.floats=[];for(var s=0;s<e.floats.length;++s)n.floats[s]=t.json&&!isFinite(e.floats[s])?String(e.floats[s]):e.floats[s]}if(e.ints&&e.ints.length)for(n.ints=[],s=0;s<e.ints.length;++s)"number"==typeof e.ints[s]?n.ints[s]=t.longs===String?String(e.ints[s]):e.ints[s]:n.ints[s]=t.longs===String?l.Long.prototype.toString.call(e.ints[s]):t.longs===Number?new l.LongBits(e.ints[s].low>>>0,e.ints[s].high>>>0).toNumber():e.ints[s];if(e.strings&&e.strings.length)for(n.strings=[],s=0;s<e.strings.length;++s)n.strings[s]=t.bytes===String?l.base64.encode(e.strings[s],0,e.strings[s].length):t.bytes===Array?Array.prototype.slice.call(e.strings[s]):e.strings[s];if(e.tensors&&e.tensors.length)for(n.tensors=[],s=0;s<e.tensors.length;++s)n.tensors[s]=c.onnx.TensorProto.toObject(e.tensors[s],t);if(e.graphs&&e.graphs.length)for(n.graphs=[],s=0;s<e.graphs.length;++s)n.graphs[s]=c.onnx.GraphProto.toObject(e.graphs[s],t);return null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),null!=e.type&&e.hasOwnProperty("type")&&(n.type=t.enums===String?c.onnx.AttributeProto.AttributeType[e.type]:e.type),null!=e.refAttrName&&e.hasOwnProperty("refAttrName")&&(n.refAttrName=e.refAttrName),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e.AttributeType=function(){var e={},t=Object.create(e);return t[e[0]="UNDEFINED"]=0,t[e[1]="FLOAT"]=1,t[e[2]="INT"]=2,t[e[3]="STRING"]=3,t[e[4]="TENSOR"]=4,t[e[5]="GRAPH"]=5,t[e[6]="FLOATS"]=6,t[e[7]="INTS"]=7,t[e[8]="STRINGS"]=8,t[e[9]="TENSORS"]=9,t[e[10]="GRAPHS"]=10,t}(),e}(),a.ValueInfoProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.name="",e.prototype.type=null,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.name&&e.hasOwnProperty("name")&&t.uint32(10).string(e.name),null!=e.type&&e.hasOwnProperty("type")&&c.onnx.TypeProto.encode(e.type,t.uint32(18).fork()).ldelim(),null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(26).string(e.docString),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.ValueInfoProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.name=e.string();break;case 2:r.type=c.onnx.TypeProto.decode(e,e.uint32());break;case 3:r.docString=e.string();break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.name&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(null!=e.type&&e.hasOwnProperty("type")){var t=c.onnx.TypeProto.verify(e.type);if(t)return"type."+t}return null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString)?"docString: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.ValueInfoProto)return e;var t=new c.onnx.ValueInfoProto;if(null!=e.name&&(t.name=String(e.name)),null!=e.type){if("object"!=typeof e.type)throw TypeError(".onnx.ValueInfoProto.type: object expected");t.type=c.onnx.TypeProto.fromObject(e.type)}return null!=e.docString&&(t.docString=String(e.docString)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.name="",n.type=null,n.docString=""),null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.type&&e.hasOwnProperty("type")&&(n.type=c.onnx.TypeProto.toObject(e.type,t)),null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),a.NodeProto=function(){function e(e){if(this.input=[],this.output=[],this.attribute=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.input=l.emptyArray,e.prototype.output=l.emptyArray,e.prototype.name="",e.prototype.opType="",e.prototype.domain="",e.prototype.attribute=l.emptyArray,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.input&&e.input.length)for(var n=0;n<e.input.length;++n)t.uint32(10).string(e.input[n]);if(null!=e.output&&e.output.length)for(n=0;n<e.output.length;++n)t.uint32(18).string(e.output[n]);if(null!=e.name&&e.hasOwnProperty("name")&&t.uint32(26).string(e.name),null!=e.opType&&e.hasOwnProperty("opType")&&t.uint32(34).string(e.opType),null!=e.attribute&&e.attribute.length)for(n=0;n<e.attribute.length;++n)c.onnx.AttributeProto.encode(e.attribute[n],t.uint32(42).fork()).ldelim();return null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(50).string(e.docString),null!=e.domain&&e.hasOwnProperty("domain")&&t.uint32(58).string(e.domain),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.NodeProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.input&&r.input.length||(r.input=[]),r.input.push(e.string());break;case 2:r.output&&r.output.length||(r.output=[]),r.output.push(e.string());break;case 3:r.name=e.string();break;case 4:r.opType=e.string();break;case 7:r.domain=e.string();break;case 5:r.attribute&&r.attribute.length||(r.attribute=[]),r.attribute.push(c.onnx.AttributeProto.decode(e,e.uint32()));break;case 6:r.docString=e.string();break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.input&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var t=0;t<e.input.length;++t)if(!l.isString(e.input[t]))return"input: string[] expected"}if(null!=e.output&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(!l.isString(e.output[t]))return"output: string[] expected"}if(null!=e.name&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(null!=e.opType&&e.hasOwnProperty("opType")&&!l.isString(e.opType))return"opType: string expected";if(null!=e.domain&&e.hasOwnProperty("domain")&&!l.isString(e.domain))return"domain: string expected";if(null!=e.attribute&&e.hasOwnProperty("attribute")){if(!Array.isArray(e.attribute))return"attribute: array expected";for(t=0;t<e.attribute.length;++t){var n=c.onnx.AttributeProto.verify(e.attribute[t]);if(n)return"attribute."+n}}return null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString)?"docString: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.NodeProto)return e;var t=new c.onnx.NodeProto;if(e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.NodeProto.input: array expected");t.input=[];for(var n=0;n<e.input.length;++n)t.input[n]=String(e.input[n])}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.NodeProto.output: array expected");for(t.output=[],n=0;n<e.output.length;++n)t.output[n]=String(e.output[n])}if(null!=e.name&&(t.name=String(e.name)),null!=e.opType&&(t.opType=String(e.opType)),null!=e.domain&&(t.domain=String(e.domain)),e.attribute){if(!Array.isArray(e.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(t.attribute=[],n=0;n<e.attribute.length;++n){if("object"!=typeof e.attribute[n])throw TypeError(".onnx.NodeProto.attribute: object expected");t.attribute[n]=c.onnx.AttributeProto.fromObject(e.attribute[n])}}return null!=e.docString&&(t.docString=String(e.docString)),t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.input=[],n.output=[],n.attribute=[]),t.defaults&&(n.name="",n.opType="",n.docString="",n.domain=""),e.input&&e.input.length){n.input=[];for(var r=0;r<e.input.length;++r)n.input[r]=e.input[r]}if(e.output&&e.output.length)for(n.output=[],r=0;r<e.output.length;++r)n.output[r]=e.output[r];if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.opType&&e.hasOwnProperty("opType")&&(n.opType=e.opType),e.attribute&&e.attribute.length)for(n.attribute=[],r=0;r<e.attribute.length;++r)n.attribute[r]=c.onnx.AttributeProto.toObject(e.attribute[r],t);return null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),null!=e.domain&&e.hasOwnProperty("domain")&&(n.domain=e.domain),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),a.ModelProto=function(){function e(e){if(this.opsetImport=[],this.metadataProps=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.irVersion=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.opsetImport=l.emptyArray,e.prototype.producerName="",e.prototype.producerVersion="",e.prototype.domain="",e.prototype.modelVersion=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.docString="",e.prototype.graph=null,e.prototype.metadataProps=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.irVersion&&e.hasOwnProperty("irVersion")&&t.uint32(8).int64(e.irVersion),null!=e.producerName&&e.hasOwnProperty("producerName")&&t.uint32(18).string(e.producerName),null!=e.producerVersion&&e.hasOwnProperty("producerVersion")&&t.uint32(26).string(e.producerVersion),null!=e.domain&&e.hasOwnProperty("domain")&&t.uint32(34).string(e.domain),null!=e.modelVersion&&e.hasOwnProperty("modelVersion")&&t.uint32(40).int64(e.modelVersion),null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(50).string(e.docString),null!=e.graph&&e.hasOwnProperty("graph")&&c.onnx.GraphProto.encode(e.graph,t.uint32(58).fork()).ldelim(),null!=e.opsetImport&&e.opsetImport.length)for(var n=0;n<e.opsetImport.length;++n)c.onnx.OperatorSetIdProto.encode(e.opsetImport[n],t.uint32(66).fork()).ldelim();if(null!=e.metadataProps&&e.metadataProps.length)for(n=0;n<e.metadataProps.length;++n)c.onnx.StringStringEntryProto.encode(e.metadataProps[n],t.uint32(114).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.ModelProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.irVersion=e.int64();break;case 8:r.opsetImport&&r.opsetImport.length||(r.opsetImport=[]),r.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e,e.uint32()));break;case 2:r.producerName=e.string();break;case 3:r.producerVersion=e.string();break;case 4:r.domain=e.string();break;case 5:r.modelVersion=e.int64();break;case 6:r.docString=e.string();break;case 7:r.graph=c.onnx.GraphProto.decode(e,e.uint32());break;case 14:r.metadataProps&&r.metadataProps.length||(r.metadataProps=[]),r.metadataProps.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.irVersion&&e.hasOwnProperty("irVersion")&&!(l.isInteger(e.irVersion)||e.irVersion&&l.isInteger(e.irVersion.low)&&l.isInteger(e.irVersion.high)))return"irVersion: integer|Long expected";if(null!=e.opsetImport&&e.hasOwnProperty("opsetImport")){if(!Array.isArray(e.opsetImport))return"opsetImport: array expected";for(var t=0;t<e.opsetImport.length;++t)if(n=c.onnx.OperatorSetIdProto.verify(e.opsetImport[t]))return"opsetImport."+n}if(null!=e.producerName&&e.hasOwnProperty("producerName")&&!l.isString(e.producerName))return"producerName: string expected";if(null!=e.producerVersion&&e.hasOwnProperty("producerVersion")&&!l.isString(e.producerVersion))return"producerVersion: string expected";if(null!=e.domain&&e.hasOwnProperty("domain")&&!l.isString(e.domain))return"domain: string expected";if(null!=e.modelVersion&&e.hasOwnProperty("modelVersion")&&!(l.isInteger(e.modelVersion)||e.modelVersion&&l.isInteger(e.modelVersion.low)&&l.isInteger(e.modelVersion.high)))return"modelVersion: integer|Long expected";if(null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(null!=e.graph&&e.hasOwnProperty("graph")&&(n=c.onnx.GraphProto.verify(e.graph)))return"graph."+n;if(null!=e.metadataProps&&e.hasOwnProperty("metadataProps")){if(!Array.isArray(e.metadataProps))return"metadataProps: array expected";for(t=0;t<e.metadataProps.length;++t){var n;if(n=c.onnx.StringStringEntryProto.verify(e.metadataProps[t]))return"metadataProps."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.ModelProto)return e;var t=new c.onnx.ModelProto;if(null!=e.irVersion&&(l.Long?(t.irVersion=l.Long.fromValue(e.irVersion)).unsigned=!1:"string"==typeof e.irVersion?t.irVersion=parseInt(e.irVersion,10):"number"==typeof e.irVersion?t.irVersion=e.irVersion:"object"==typeof e.irVersion&&(t.irVersion=new l.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber())),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");t.opsetImport=[];for(var n=0;n<e.opsetImport.length;++n){if("object"!=typeof e.opsetImport[n])throw TypeError(".onnx.ModelProto.opsetImport: object expected");t.opsetImport[n]=c.onnx.OperatorSetIdProto.fromObject(e.opsetImport[n])}}if(null!=e.producerName&&(t.producerName=String(e.producerName)),null!=e.producerVersion&&(t.producerVersion=String(e.producerVersion)),null!=e.domain&&(t.domain=String(e.domain)),null!=e.modelVersion&&(l.Long?(t.modelVersion=l.Long.fromValue(e.modelVersion)).unsigned=!1:"string"==typeof e.modelVersion?t.modelVersion=parseInt(e.modelVersion,10):"number"==typeof e.modelVersion?t.modelVersion=e.modelVersion:"object"==typeof e.modelVersion&&(t.modelVersion=new l.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber())),null!=e.docString&&(t.docString=String(e.docString)),null!=e.graph){if("object"!=typeof e.graph)throw TypeError(".onnx.ModelProto.graph: object expected");t.graph=c.onnx.GraphProto.fromObject(e.graph)}if(e.metadataProps){if(!Array.isArray(e.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(t.metadataProps=[],n=0;n<e.metadataProps.length;++n){if("object"!=typeof e.metadataProps[n])throw TypeError(".onnx.ModelProto.metadataProps: object expected");t.metadataProps[n]=c.onnx.StringStringEntryProto.fromObject(e.metadataProps[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.opsetImport=[],n.metadataProps=[]),t.defaults){if(l.Long){var r=new l.Long(0,0,!1);n.irVersion=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.irVersion=t.longs===String?"0":0;n.producerName="",n.producerVersion="",n.domain="",l.Long?(r=new l.Long(0,0,!1),n.modelVersion=t.longs===String?r.toString():t.longs===Number?r.toNumber():r):n.modelVersion=t.longs===String?"0":0,n.docString="",n.graph=null}if(null!=e.irVersion&&e.hasOwnProperty("irVersion")&&("number"==typeof e.irVersion?n.irVersion=t.longs===String?String(e.irVersion):e.irVersion:n.irVersion=t.longs===String?l.Long.prototype.toString.call(e.irVersion):t.longs===Number?new l.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber():e.irVersion),null!=e.producerName&&e.hasOwnProperty("producerName")&&(n.producerName=e.producerName),null!=e.producerVersion&&e.hasOwnProperty("producerVersion")&&(n.producerVersion=e.producerVersion),null!=e.domain&&e.hasOwnProperty("domain")&&(n.domain=e.domain),null!=e.modelVersion&&e.hasOwnProperty("modelVersion")&&("number"==typeof e.modelVersion?n.modelVersion=t.longs===String?String(e.modelVersion):e.modelVersion:n.modelVersion=t.longs===String?l.Long.prototype.toString.call(e.modelVersion):t.longs===Number?new l.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber():e.modelVersion),null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),null!=e.graph&&e.hasOwnProperty("graph")&&(n.graph=c.onnx.GraphProto.toObject(e.graph,t)),e.opsetImport&&e.opsetImport.length){n.opsetImport=[];for(var s=0;s<e.opsetImport.length;++s)n.opsetImport[s]=c.onnx.OperatorSetIdProto.toObject(e.opsetImport[s],t)}if(e.metadataProps&&e.metadataProps.length)for(n.metadataProps=[],s=0;s<e.metadataProps.length;++s)n.metadataProps[s]=c.onnx.StringStringEntryProto.toObject(e.metadataProps[s],t);return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),a.StringStringEntryProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.key="",e.prototype.value="",e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.key&&e.hasOwnProperty("key")&&t.uint32(10).string(e.key),null!=e.value&&e.hasOwnProperty("value")&&t.uint32(18).string(e.value),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.StringStringEntryProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.key=e.string();break;case 2:r.value=e.string();break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){return"object"!=typeof e||null===e?"object expected":null!=e.key&&e.hasOwnProperty("key")&&!l.isString(e.key)?"key: string expected":null!=e.value&&e.hasOwnProperty("value")&&!l.isString(e.value)?"value: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.StringStringEntryProto)return e;var t=new c.onnx.StringStringEntryProto;return null!=e.key&&(t.key=String(e.key)),null!=e.value&&(t.value=String(e.value)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.key="",n.value=""),null!=e.key&&e.hasOwnProperty("key")&&(n.key=e.key),null!=e.value&&e.hasOwnProperty("value")&&(n.value=e.value),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),a.TensorAnnotation=function(){function e(e){if(this.quantParameterTensorNames=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.tensorName="",e.prototype.quantParameterTensorNames=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.tensorName&&e.hasOwnProperty("tensorName")&&t.uint32(10).string(e.tensorName),null!=e.quantParameterTensorNames&&e.quantParameterTensorNames.length)for(var n=0;n<e.quantParameterTensorNames.length;++n)c.onnx.StringStringEntryProto.encode(e.quantParameterTensorNames[n],t.uint32(18).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorAnnotation;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.tensorName=e.string();break;case 2:r.quantParameterTensorNames&&r.quantParameterTensorNames.length||(r.quantParameterTensorNames=[]),r.quantParameterTensorNames.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.tensorName&&e.hasOwnProperty("tensorName")&&!l.isString(e.tensorName))return"tensorName: string expected";if(null!=e.quantParameterTensorNames&&e.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(e.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var t=0;t<e.quantParameterTensorNames.length;++t){var n=c.onnx.StringStringEntryProto.verify(e.quantParameterTensorNames[t]);if(n)return"quantParameterTensorNames."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.TensorAnnotation)return e;var t=new c.onnx.TensorAnnotation;if(null!=e.tensorName&&(t.tensorName=String(e.tensorName)),e.quantParameterTensorNames){if(!Array.isArray(e.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");t.quantParameterTensorNames=[];for(var n=0;n<e.quantParameterTensorNames.length;++n){if("object"!=typeof e.quantParameterTensorNames[n])throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");t.quantParameterTensorNames[n]=c.onnx.StringStringEntryProto.fromObject(e.quantParameterTensorNames[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.quantParameterTensorNames=[]),t.defaults&&(n.tensorName=""),null!=e.tensorName&&e.hasOwnProperty("tensorName")&&(n.tensorName=e.tensorName),e.quantParameterTensorNames&&e.quantParameterTensorNames.length){n.quantParameterTensorNames=[];for(var r=0;r<e.quantParameterTensorNames.length;++r)n.quantParameterTensorNames[r]=c.onnx.StringStringEntryProto.toObject(e.quantParameterTensorNames[r],t)}return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),a.GraphProto=function(){function e(e){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.node=l.emptyArray,e.prototype.name="",e.prototype.initializer=l.emptyArray,e.prototype.docString="",e.prototype.input=l.emptyArray,e.prototype.output=l.emptyArray,e.prototype.valueInfo=l.emptyArray,e.prototype.quantizationAnnotation=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.node&&e.node.length)for(var n=0;n<e.node.length;++n)c.onnx.NodeProto.encode(e.node[n],t.uint32(10).fork()).ldelim();if(null!=e.name&&e.hasOwnProperty("name")&&t.uint32(18).string(e.name),null!=e.initializer&&e.initializer.length)for(n=0;n<e.initializer.length;++n)c.onnx.TensorProto.encode(e.initializer[n],t.uint32(42).fork()).ldelim();if(null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(82).string(e.docString),null!=e.input&&e.input.length)for(n=0;n<e.input.length;++n)c.onnx.ValueInfoProto.encode(e.input[n],t.uint32(90).fork()).ldelim();if(null!=e.output&&e.output.length)for(n=0;n<e.output.length;++n)c.onnx.ValueInfoProto.encode(e.output[n],t.uint32(98).fork()).ldelim();if(null!=e.valueInfo&&e.valueInfo.length)for(n=0;n<e.valueInfo.length;++n)c.onnx.ValueInfoProto.encode(e.valueInfo[n],t.uint32(106).fork()).ldelim();if(null!=e.quantizationAnnotation&&e.quantizationAnnotation.length)for(n=0;n<e.quantizationAnnotation.length;++n)c.onnx.TensorAnnotation.encode(e.quantizationAnnotation[n],t.uint32(114).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.GraphProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.node&&r.node.length||(r.node=[]),r.node.push(c.onnx.NodeProto.decode(e,e.uint32()));break;case 2:r.name=e.string();break;case 5:r.initializer&&r.initializer.length||(r.initializer=[]),r.initializer.push(c.onnx.TensorProto.decode(e,e.uint32()));break;case 10:r.docString=e.string();break;case 11:r.input&&r.input.length||(r.input=[]),r.input.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 12:r.output&&r.output.length||(r.output=[]),r.output.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 13:r.valueInfo&&r.valueInfo.length||(r.valueInfo=[]),r.valueInfo.push(c.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 14:r.quantizationAnnotation&&r.quantizationAnnotation.length||(r.quantizationAnnotation=[]),r.quantizationAnnotation.push(c.onnx.TensorAnnotation.decode(e,e.uint32()));break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.node&&e.hasOwnProperty("node")){if(!Array.isArray(e.node))return"node: array expected";for(var t=0;t<e.node.length;++t)if(n=c.onnx.NodeProto.verify(e.node[t]))return"node."+n}if(null!=e.name&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(null!=e.initializer&&e.hasOwnProperty("initializer")){if(!Array.isArray(e.initializer))return"initializer: array expected";for(t=0;t<e.initializer.length;++t)if(n=c.onnx.TensorProto.verify(e.initializer[t]))return"initializer."+n}if(null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(null!=e.input&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(t=0;t<e.input.length;++t)if(n=c.onnx.ValueInfoProto.verify(e.input[t]))return"input."+n}if(null!=e.output&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(n=c.onnx.ValueInfoProto.verify(e.output[t]))return"output."+n}if(null!=e.valueInfo&&e.hasOwnProperty("valueInfo")){if(!Array.isArray(e.valueInfo))return"valueInfo: array expected";for(t=0;t<e.valueInfo.length;++t)if(n=c.onnx.ValueInfoProto.verify(e.valueInfo[t]))return"valueInfo."+n}if(null!=e.quantizationAnnotation&&e.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(e.quantizationAnnotation))return"quantizationAnnotation: array expected";for(t=0;t<e.quantizationAnnotation.length;++t){var n;if(n=c.onnx.TensorAnnotation.verify(e.quantizationAnnotation[t]))return"quantizationAnnotation."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.GraphProto)return e;var t=new c.onnx.GraphProto;if(e.node){if(!Array.isArray(e.node))throw TypeError(".onnx.GraphProto.node: array expected");t.node=[];for(var n=0;n<e.node.length;++n){if("object"!=typeof e.node[n])throw TypeError(".onnx.GraphProto.node: object expected");t.node[n]=c.onnx.NodeProto.fromObject(e.node[n])}}if(null!=e.name&&(t.name=String(e.name)),e.initializer){if(!Array.isArray(e.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(t.initializer=[],n=0;n<e.initializer.length;++n){if("object"!=typeof e.initializer[n])throw TypeError(".onnx.GraphProto.initializer: object expected");t.initializer[n]=c.onnx.TensorProto.fromObject(e.initializer[n])}}if(null!=e.docString&&(t.docString=String(e.docString)),e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.GraphProto.input: array expected");for(t.input=[],n=0;n<e.input.length;++n){if("object"!=typeof e.input[n])throw TypeError(".onnx.GraphProto.input: object expected");t.input[n]=c.onnx.ValueInfoProto.fromObject(e.input[n])}}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.GraphProto.output: array expected");for(t.output=[],n=0;n<e.output.length;++n){if("object"!=typeof e.output[n])throw TypeError(".onnx.GraphProto.output: object expected");t.output[n]=c.onnx.ValueInfoProto.fromObject(e.output[n])}}if(e.valueInfo){if(!Array.isArray(e.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(t.valueInfo=[],n=0;n<e.valueInfo.length;++n){if("object"!=typeof e.valueInfo[n])throw TypeError(".onnx.GraphProto.valueInfo: object expected");t.valueInfo[n]=c.onnx.ValueInfoProto.fromObject(e.valueInfo[n])}}if(e.quantizationAnnotation){if(!Array.isArray(e.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(t.quantizationAnnotation=[],n=0;n<e.quantizationAnnotation.length;++n){if("object"!=typeof e.quantizationAnnotation[n])throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");t.quantizationAnnotation[n]=c.onnx.TensorAnnotation.fromObject(e.quantizationAnnotation[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.node=[],n.initializer=[],n.input=[],n.output=[],n.valueInfo=[],n.quantizationAnnotation=[]),t.defaults&&(n.name="",n.docString=""),e.node&&e.node.length){n.node=[];for(var r=0;r<e.node.length;++r)n.node[r]=c.onnx.NodeProto.toObject(e.node[r],t)}if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),e.initializer&&e.initializer.length)for(n.initializer=[],r=0;r<e.initializer.length;++r)n.initializer[r]=c.onnx.TensorProto.toObject(e.initializer[r],t);if(null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),e.input&&e.input.length)for(n.input=[],r=0;r<e.input.length;++r)n.input[r]=c.onnx.ValueInfoProto.toObject(e.input[r],t);if(e.output&&e.output.length)for(n.output=[],r=0;r<e.output.length;++r)n.output[r]=c.onnx.ValueInfoProto.toObject(e.output[r],t);if(e.valueInfo&&e.valueInfo.length)for(n.valueInfo=[],r=0;r<e.valueInfo.length;++r)n.valueInfo[r]=c.onnx.ValueInfoProto.toObject(e.valueInfo[r],t);if(e.quantizationAnnotation&&e.quantizationAnnotation.length)for(n.quantizationAnnotation=[],r=0;r<e.quantizationAnnotation.length;++r)n.quantizationAnnotation[r]=c.onnx.TensorAnnotation.toObject(e.quantizationAnnotation[r],t);return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),a.TensorProto=function(){function e(e){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.dims=l.emptyArray,e.prototype.dataType=0,e.prototype.segment=null,e.prototype.floatData=l.emptyArray,e.prototype.int32Data=l.emptyArray,e.prototype.stringData=l.emptyArray,e.prototype.int64Data=l.emptyArray,e.prototype.name="",e.prototype.docString="",e.prototype.rawData=l.newBuffer([]),e.prototype.externalData=l.emptyArray,e.prototype.dataLocation=0,e.prototype.doubleData=l.emptyArray,e.prototype.uint64Data=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.dims&&e.dims.length){t.uint32(10).fork();for(var n=0;n<e.dims.length;++n)t.int64(e.dims[n]);t.ldelim()}if(null!=e.dataType&&e.hasOwnProperty("dataType")&&t.uint32(16).int32(e.dataType),null!=e.segment&&e.hasOwnProperty("segment")&&c.onnx.TensorProto.Segment.encode(e.segment,t.uint32(26).fork()).ldelim(),null!=e.floatData&&e.floatData.length){for(t.uint32(34).fork(),n=0;n<e.floatData.length;++n)t.float(e.floatData[n]);t.ldelim()}if(null!=e.int32Data&&e.int32Data.length){for(t.uint32(42).fork(),n=0;n<e.int32Data.length;++n)t.int32(e.int32Data[n]);t.ldelim()}if(null!=e.stringData&&e.stringData.length)for(n=0;n<e.stringData.length;++n)t.uint32(50).bytes(e.stringData[n]);if(null!=e.int64Data&&e.int64Data.length){for(t.uint32(58).fork(),n=0;n<e.int64Data.length;++n)t.int64(e.int64Data[n]);t.ldelim()}if(null!=e.name&&e.hasOwnProperty("name")&&t.uint32(66).string(e.name),null!=e.rawData&&e.hasOwnProperty("rawData")&&t.uint32(74).bytes(e.rawData),null!=e.doubleData&&e.doubleData.length){for(t.uint32(82).fork(),n=0;n<e.doubleData.length;++n)t.double(e.doubleData[n]);t.ldelim()}if(null!=e.uint64Data&&e.uint64Data.length){for(t.uint32(90).fork(),n=0;n<e.uint64Data.length;++n)t.uint64(e.uint64Data[n]);t.ldelim()}if(null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(98).string(e.docString),null!=e.externalData&&e.externalData.length)for(n=0;n<e.externalData.length;++n)c.onnx.StringStringEntryProto.encode(e.externalData[n],t.uint32(106).fork()).ldelim();return null!=e.dataLocation&&e.hasOwnProperty("dataLocation")&&t.uint32(112).int32(e.dataLocation),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:if(r.dims&&r.dims.length||(r.dims=[]),2==(7&s))for(var a=e.uint32()+e.pos;e.pos<a;)r.dims.push(e.int64());else r.dims.push(e.int64());break;case 2:r.dataType=e.int32();break;case 3:r.segment=c.onnx.TensorProto.Segment.decode(e,e.uint32());break;case 4:if(r.floatData&&r.floatData.length||(r.floatData=[]),2==(7&s))for(a=e.uint32()+e.pos;e.pos<a;)r.floatData.push(e.float());else r.floatData.push(e.float());break;case 5:if(r.int32Data&&r.int32Data.length||(r.int32Data=[]),2==(7&s))for(a=e.uint32()+e.pos;e.pos<a;)r.int32Data.push(e.int32());else r.int32Data.push(e.int32());break;case 6:r.stringData&&r.stringData.length||(r.stringData=[]),r.stringData.push(e.bytes());break;case 7:if(r.int64Data&&r.int64Data.length||(r.int64Data=[]),2==(7&s))for(a=e.uint32()+e.pos;e.pos<a;)r.int64Data.push(e.int64());else r.int64Data.push(e.int64());break;case 8:r.name=e.string();break;case 12:r.docString=e.string();break;case 9:r.rawData=e.bytes();break;case 13:r.externalData&&r.externalData.length||(r.externalData=[]),r.externalData.push(c.onnx.StringStringEntryProto.decode(e,e.uint32()));break;case 14:r.dataLocation=e.int32();break;case 10:if(r.doubleData&&r.doubleData.length||(r.doubleData=[]),2==(7&s))for(a=e.uint32()+e.pos;e.pos<a;)r.doubleData.push(e.double());else r.doubleData.push(e.double());break;case 11:if(r.uint64Data&&r.uint64Data.length||(r.uint64Data=[]),2==(7&s))for(a=e.uint32()+e.pos;e.pos<a;)r.uint64Data.push(e.uint64());else r.uint64Data.push(e.uint64());break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.dims&&e.hasOwnProperty("dims")){if(!Array.isArray(e.dims))return"dims: array expected";for(var t=0;t<e.dims.length;++t)if(!(l.isInteger(e.dims[t])||e.dims[t]&&l.isInteger(e.dims[t].low)&&l.isInteger(e.dims[t].high)))return"dims: integer|Long[] expected"}if(null!=e.dataType&&e.hasOwnProperty("dataType")&&!l.isInteger(e.dataType))return"dataType: integer expected";if(null!=e.segment&&e.hasOwnProperty("segment")&&(n=c.onnx.TensorProto.Segment.verify(e.segment)))return"segment."+n;if(null!=e.floatData&&e.hasOwnProperty("floatData")){if(!Array.isArray(e.floatData))return"floatData: array expected";for(t=0;t<e.floatData.length;++t)if("number"!=typeof e.floatData[t])return"floatData: number[] expected"}if(null!=e.int32Data&&e.hasOwnProperty("int32Data")){if(!Array.isArray(e.int32Data))return"int32Data: array expected";for(t=0;t<e.int32Data.length;++t)if(!l.isInteger(e.int32Data[t]))return"int32Data: integer[] expected"}if(null!=e.stringData&&e.hasOwnProperty("stringData")){if(!Array.isArray(e.stringData))return"stringData: array expected";for(t=0;t<e.stringData.length;++t)if(!(e.stringData[t]&&"number"==typeof e.stringData[t].length||l.isString(e.stringData[t])))return"stringData: buffer[] expected"}if(null!=e.int64Data&&e.hasOwnProperty("int64Data")){if(!Array.isArray(e.int64Data))return"int64Data: array expected";for(t=0;t<e.int64Data.length;++t)if(!(l.isInteger(e.int64Data[t])||e.int64Data[t]&&l.isInteger(e.int64Data[t].low)&&l.isInteger(e.int64Data[t].high)))return"int64Data: integer|Long[] expected"}if(null!=e.name&&e.hasOwnProperty("name")&&!l.isString(e.name))return"name: string expected";if(null!=e.docString&&e.hasOwnProperty("docString")&&!l.isString(e.docString))return"docString: string expected";if(null!=e.rawData&&e.hasOwnProperty("rawData")&&!(e.rawData&&"number"==typeof e.rawData.length||l.isString(e.rawData)))return"rawData: buffer expected";if(null!=e.externalData&&e.hasOwnProperty("externalData")){if(!Array.isArray(e.externalData))return"externalData: array expected";for(t=0;t<e.externalData.length;++t){var n;if(n=c.onnx.StringStringEntryProto.verify(e.externalData[t]))return"externalData."+n}}if(null!=e.dataLocation&&e.hasOwnProperty("dataLocation"))switch(e.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(null!=e.doubleData&&e.hasOwnProperty("doubleData")){if(!Array.isArray(e.doubleData))return"doubleData: array expected";for(t=0;t<e.doubleData.length;++t)if("number"!=typeof e.doubleData[t])return"doubleData: number[] expected"}if(null!=e.uint64Data&&e.hasOwnProperty("uint64Data")){if(!Array.isArray(e.uint64Data))return"uint64Data: array expected";for(t=0;t<e.uint64Data.length;++t)if(!(l.isInteger(e.uint64Data[t])||e.uint64Data[t]&&l.isInteger(e.uint64Data[t].low)&&l.isInteger(e.uint64Data[t].high)))return"uint64Data: integer|Long[] expected"}return null},e.fromObject=function(e){if(e instanceof c.onnx.TensorProto)return e;var t=new c.onnx.TensorProto;if(e.dims){if(!Array.isArray(e.dims))throw TypeError(".onnx.TensorProto.dims: array expected");t.dims=[];for(var n=0;n<e.dims.length;++n)l.Long?(t.dims[n]=l.Long.fromValue(e.dims[n])).unsigned=!1:"string"==typeof e.dims[n]?t.dims[n]=parseInt(e.dims[n],10):"number"==typeof e.dims[n]?t.dims[n]=e.dims[n]:"object"==typeof e.dims[n]&&(t.dims[n]=new l.LongBits(e.dims[n].low>>>0,e.dims[n].high>>>0).toNumber())}if(null!=e.dataType&&(t.dataType=0|e.dataType),null!=e.segment){if("object"!=typeof e.segment)throw TypeError(".onnx.TensorProto.segment: object expected");t.segment=c.onnx.TensorProto.Segment.fromObject(e.segment)}if(e.floatData){if(!Array.isArray(e.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(t.floatData=[],n=0;n<e.floatData.length;++n)t.floatData[n]=Number(e.floatData[n])}if(e.int32Data){if(!Array.isArray(e.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(t.int32Data=[],n=0;n<e.int32Data.length;++n)t.int32Data[n]=0|e.int32Data[n]}if(e.stringData){if(!Array.isArray(e.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(t.stringData=[],n=0;n<e.stringData.length;++n)"string"==typeof e.stringData[n]?l.base64.decode(e.stringData[n],t.stringData[n]=l.newBuffer(l.base64.length(e.stringData[n])),0):e.stringData[n].length&&(t.stringData[n]=e.stringData[n])}if(e.int64Data){if(!Array.isArray(e.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(t.int64Data=[],n=0;n<e.int64Data.length;++n)l.Long?(t.int64Data[n]=l.Long.fromValue(e.int64Data[n])).unsigned=!1:"string"==typeof e.int64Data[n]?t.int64Data[n]=parseInt(e.int64Data[n],10):"number"==typeof e.int64Data[n]?t.int64Data[n]=e.int64Data[n]:"object"==typeof e.int64Data[n]&&(t.int64Data[n]=new l.LongBits(e.int64Data[n].low>>>0,e.int64Data[n].high>>>0).toNumber())}if(null!=e.name&&(t.name=String(e.name)),null!=e.docString&&(t.docString=String(e.docString)),null!=e.rawData&&("string"==typeof e.rawData?l.base64.decode(e.rawData,t.rawData=l.newBuffer(l.base64.length(e.rawData)),0):e.rawData.length&&(t.rawData=e.rawData)),e.externalData){if(!Array.isArray(e.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(t.externalData=[],n=0;n<e.externalData.length;++n){if("object"!=typeof e.externalData[n])throw TypeError(".onnx.TensorProto.externalData: object expected");t.externalData[n]=c.onnx.StringStringEntryProto.fromObject(e.externalData[n])}}switch(e.dataLocation){case"DEFAULT":case 0:t.dataLocation=0;break;case"EXTERNAL":case 1:t.dataLocation=1}if(e.doubleData){if(!Array.isArray(e.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(t.doubleData=[],n=0;n<e.doubleData.length;++n)t.doubleData[n]=Number(e.doubleData[n])}if(e.uint64Data){if(!Array.isArray(e.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(t.uint64Data=[],n=0;n<e.uint64Data.length;++n)l.Long?(t.uint64Data[n]=l.Long.fromValue(e.uint64Data[n])).unsigned=!0:"string"==typeof e.uint64Data[n]?t.uint64Data[n]=parseInt(e.uint64Data[n],10):"number"==typeof e.uint64Data[n]?t.uint64Data[n]=e.uint64Data[n]:"object"==typeof e.uint64Data[n]&&(t.uint64Data[n]=new l.LongBits(e.uint64Data[n].low>>>0,e.uint64Data[n].high>>>0).toNumber(!0))}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.dims=[],n.floatData=[],n.int32Data=[],n.stringData=[],n.int64Data=[],n.doubleData=[],n.uint64Data=[],n.externalData=[]),t.defaults&&(n.dataType=0,n.segment=null,n.name="",t.bytes===String?n.rawData="":(n.rawData=[],t.bytes!==Array&&(n.rawData=l.newBuffer(n.rawData))),n.docString="",n.dataLocation=t.enums===String?"DEFAULT":0),e.dims&&e.dims.length){n.dims=[];for(var r=0;r<e.dims.length;++r)"number"==typeof e.dims[r]?n.dims[r]=t.longs===String?String(e.dims[r]):e.dims[r]:n.dims[r]=t.longs===String?l.Long.prototype.toString.call(e.dims[r]):t.longs===Number?new l.LongBits(e.dims[r].low>>>0,e.dims[r].high>>>0).toNumber():e.dims[r]}if(null!=e.dataType&&e.hasOwnProperty("dataType")&&(n.dataType=e.dataType),null!=e.segment&&e.hasOwnProperty("segment")&&(n.segment=c.onnx.TensorProto.Segment.toObject(e.segment,t)),e.floatData&&e.floatData.length)for(n.floatData=[],r=0;r<e.floatData.length;++r)n.floatData[r]=t.json&&!isFinite(e.floatData[r])?String(e.floatData[r]):e.floatData[r];if(e.int32Data&&e.int32Data.length)for(n.int32Data=[],r=0;r<e.int32Data.length;++r)n.int32Data[r]=e.int32Data[r];if(e.stringData&&e.stringData.length)for(n.stringData=[],r=0;r<e.stringData.length;++r)n.stringData[r]=t.bytes===String?l.base64.encode(e.stringData[r],0,e.stringData[r].length):t.bytes===Array?Array.prototype.slice.call(e.stringData[r]):e.stringData[r];if(e.int64Data&&e.int64Data.length)for(n.int64Data=[],r=0;r<e.int64Data.length;++r)"number"==typeof e.int64Data[r]?n.int64Data[r]=t.longs===String?String(e.int64Data[r]):e.int64Data[r]:n.int64Data[r]=t.longs===String?l.Long.prototype.toString.call(e.int64Data[r]):t.longs===Number?new l.LongBits(e.int64Data[r].low>>>0,e.int64Data[r].high>>>0).toNumber():e.int64Data[r];if(null!=e.name&&e.hasOwnProperty("name")&&(n.name=e.name),null!=e.rawData&&e.hasOwnProperty("rawData")&&(n.rawData=t.bytes===String?l.base64.encode(e.rawData,0,e.rawData.length):t.bytes===Array?Array.prototype.slice.call(e.rawData):e.rawData),e.doubleData&&e.doubleData.length)for(n.doubleData=[],r=0;r<e.doubleData.length;++r)n.doubleData[r]=t.json&&!isFinite(e.doubleData[r])?String(e.doubleData[r]):e.doubleData[r];if(e.uint64Data&&e.uint64Data.length)for(n.uint64Data=[],r=0;r<e.uint64Data.length;++r)"number"==typeof e.uint64Data[r]?n.uint64Data[r]=t.longs===String?String(e.uint64Data[r]):e.uint64Data[r]:n.uint64Data[r]=t.longs===String?l.Long.prototype.toString.call(e.uint64Data[r]):t.longs===Number?new l.LongBits(e.uint64Data[r].low>>>0,e.uint64Data[r].high>>>0).toNumber(!0):e.uint64Data[r];if(null!=e.docString&&e.hasOwnProperty("docString")&&(n.docString=e.docString),e.externalData&&e.externalData.length)for(n.externalData=[],r=0;r<e.externalData.length;++r)n.externalData[r]=c.onnx.StringStringEntryProto.toObject(e.externalData[r],t);return null!=e.dataLocation&&e.hasOwnProperty("dataLocation")&&(n.dataLocation=t.enums===String?c.onnx.TensorProto.DataLocation[e.dataLocation]:e.dataLocation),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e.DataType=function(){var e={},t=Object.create(e);return t[e[0]="UNDEFINED"]=0,t[e[1]="FLOAT"]=1,t[e[2]="UINT8"]=2,t[e[3]="INT8"]=3,t[e[4]="UINT16"]=4,t[e[5]="INT16"]=5,t[e[6]="INT32"]=6,t[e[7]="INT64"]=7,t[e[8]="STRING"]=8,t[e[9]="BOOL"]=9,t[e[10]="FLOAT16"]=10,t[e[11]="DOUBLE"]=11,t[e[12]="UINT32"]=12,t[e[13]="UINT64"]=13,t[e[14]="COMPLEX64"]=14,t[e[15]="COMPLEX128"]=15,t[e[16]="BFLOAT16"]=16,t}(),e.Segment=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.begin=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.end=l.Long?l.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.begin&&e.hasOwnProperty("begin")&&t.uint32(8).int64(e.begin),null!=e.end&&e.hasOwnProperty("end")&&t.uint32(16).int64(e.end),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorProto.Segment;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.begin=e.int64();break;case 2:r.end=e.int64();break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){return"object"!=typeof e||null===e?"object expected":null!=e.begin&&e.hasOwnProperty("begin")&&!(l.isInteger(e.begin)||e.begin&&l.isInteger(e.begin.low)&&l.isInteger(e.begin.high))?"begin: integer|Long expected":null!=e.end&&e.hasOwnProperty("end")&&!(l.isInteger(e.end)||e.end&&l.isInteger(e.end.low)&&l.isInteger(e.end.high))?"end: integer|Long expected":null},e.fromObject=function(e){if(e instanceof c.onnx.TensorProto.Segment)return e;var t=new c.onnx.TensorProto.Segment;return null!=e.begin&&(l.Long?(t.begin=l.Long.fromValue(e.begin)).unsigned=!1:"string"==typeof e.begin?t.begin=parseInt(e.begin,10):"number"==typeof e.begin?t.begin=e.begin:"object"==typeof e.begin&&(t.begin=new l.LongBits(e.begin.low>>>0,e.begin.high>>>0).toNumber())),null!=e.end&&(l.Long?(t.end=l.Long.fromValue(e.end)).unsigned=!1:"string"==typeof e.end?t.end=parseInt(e.end,10):"number"==typeof e.end?t.end=e.end:"object"==typeof e.end&&(t.end=new l.LongBits(e.end.low>>>0,e.end.high>>>0).toNumber())),t},e.toObject=function(e,t){t||(t={});var n={};if(t.defaults){if(l.Long){var r=new l.Long(0,0,!1);n.begin=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.begin=t.longs===String?"0":0;l.Long?(r=new l.Long(0,0,!1),n.end=t.longs===String?r.toString():t.longs===Number?r.toNumber():r):n.end=t.longs===String?"0":0}return null!=e.begin&&e.hasOwnProperty("begin")&&("number"==typeof e.begin?n.begin=t.longs===String?String(e.begin):e.begin:n.begin=t.longs===String?l.Long.prototype.toString.call(e.begin):t.longs===Number?new l.LongBits(e.begin.low>>>0,e.begin.high>>>0).toNumber():e.begin),null!=e.end&&e.hasOwnProperty("end")&&("number"==typeof e.end?n.end=t.longs===String?String(e.end):e.end:n.end=t.longs===String?l.Long.prototype.toString.call(e.end):t.longs===Number?new l.LongBits(e.end.low>>>0,e.end.high>>>0).toNumber():e.end),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),e.DataLocation=function(){var e={},t=Object.create(e);return t[e[0]="DEFAULT"]=0,t[e[1]="EXTERNAL"]=1,t}(),e}(),a.TensorShapeProto=function(){function e(e){if(this.dim=[],e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.dim=l.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=u.create()),null!=e.dim&&e.dim.length)for(var n=0;n<e.dim.length;++n)c.onnx.TensorShapeProto.Dimension.encode(e.dim[n],t.uint32(10).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorShapeProto;e.pos<n;){var s=e.uint32();s>>>3==1?(r.dim&&r.dim.length||(r.dim=[]),r.dim.push(c.onnx.TensorShapeProto.Dimension.decode(e,e.uint32()))):e.skipType(7&s)}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.dim&&e.hasOwnProperty("dim")){if(!Array.isArray(e.dim))return"dim: array expected";for(var t=0;t<e.dim.length;++t){var n=c.onnx.TensorShapeProto.Dimension.verify(e.dim[t]);if(n)return"dim."+n}}return null},e.fromObject=function(e){if(e instanceof c.onnx.TensorShapeProto)return e;var t=new c.onnx.TensorShapeProto;if(e.dim){if(!Array.isArray(e.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");t.dim=[];for(var n=0;n<e.dim.length;++n){if("object"!=typeof e.dim[n])throw TypeError(".onnx.TensorShapeProto.dim: object expected");t.dim[n]=c.onnx.TensorShapeProto.Dimension.fromObject(e.dim[n])}}return t},e.toObject=function(e,t){t||(t={});var n={};if((t.arrays||t.defaults)&&(n.dim=[]),e.dim&&e.dim.length){n.dim=[];for(var r=0;r<e.dim.length;++r)n.dim[r]=c.onnx.TensorShapeProto.Dimension.toObject(e.dim[r],t)}return n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e.Dimension=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}var t;return e.prototype.dimValue=l.Long?l.Long.fromBits(0,0,!1):0,e.prototype.dimParam="",e.prototype.denotation="",Object.defineProperty(e.prototype,"value",{get:l.oneOfGetter(t=["dimValue","dimParam"]),set:l.oneOfSetter(t)}),e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.dimValue&&e.hasOwnProperty("dimValue")&&t.uint32(8).int64(e.dimValue),null!=e.dimParam&&e.hasOwnProperty("dimParam")&&t.uint32(18).string(e.dimParam),null!=e.denotation&&e.hasOwnProperty("denotation")&&t.uint32(26).string(e.denotation),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TensorShapeProto.Dimension;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.dimValue=e.int64();break;case 2:r.dimParam=e.string();break;case 3:r.denotation=e.string();break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";var t={};if(null!=e.dimValue&&e.hasOwnProperty("dimValue")&&(t.value=1,!(l.isInteger(e.dimValue)||e.dimValue&&l.isInteger(e.dimValue.low)&&l.isInteger(e.dimValue.high))))return"dimValue: integer|Long expected";if(null!=e.dimParam&&e.hasOwnProperty("dimParam")){if(1===t.value)return"value: multiple values";if(t.value=1,!l.isString(e.dimParam))return"dimParam: string expected"}return null!=e.denotation&&e.hasOwnProperty("denotation")&&!l.isString(e.denotation)?"denotation: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.TensorShapeProto.Dimension)return e;var t=new c.onnx.TensorShapeProto.Dimension;return null!=e.dimValue&&(l.Long?(t.dimValue=l.Long.fromValue(e.dimValue)).unsigned=!1:"string"==typeof e.dimValue?t.dimValue=parseInt(e.dimValue,10):"number"==typeof e.dimValue?t.dimValue=e.dimValue:"object"==typeof e.dimValue&&(t.dimValue=new l.LongBits(e.dimValue.low>>>0,e.dimValue.high>>>0).toNumber())),null!=e.dimParam&&(t.dimParam=String(e.dimParam)),null!=e.denotation&&(t.denotation=String(e.denotation)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.denotation=""),null!=e.dimValue&&e.hasOwnProperty("dimValue")&&("number"==typeof e.dimValue?n.dimValue=t.longs===String?String(e.dimValue):e.dimValue:n.dimValue=t.longs===String?l.Long.prototype.toString.call(e.dimValue):t.longs===Number?new l.LongBits(e.dimValue.low>>>0,e.dimValue.high>>>0).toNumber():e.dimValue,t.oneofs&&(n.value="dimValue")),null!=e.dimParam&&e.hasOwnProperty("dimParam")&&(n.dimParam=e.dimParam,t.oneofs&&(n.value="dimParam")),null!=e.denotation&&e.hasOwnProperty("denotation")&&(n.denotation=e.denotation),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),e}(),a.TypeProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}var t;return e.prototype.tensorType=null,e.prototype.denotation="",Object.defineProperty(e.prototype,"value",{get:l.oneOfGetter(t=["tensorType"]),set:l.oneOfSetter(t)}),e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.tensorType&&e.hasOwnProperty("tensorType")&&c.onnx.TypeProto.Tensor.encode(e.tensorType,t.uint32(10).fork()).ldelim(),null!=e.denotation&&e.hasOwnProperty("denotation")&&t.uint32(50).string(e.denotation),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TypeProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.tensorType=c.onnx.TypeProto.Tensor.decode(e,e.uint32());break;case 6:r.denotation=e.string();break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.tensorType&&e.hasOwnProperty("tensorType")){var t=c.onnx.TypeProto.Tensor.verify(e.tensorType);if(t)return"tensorType."+t}return null!=e.denotation&&e.hasOwnProperty("denotation")&&!l.isString(e.denotation)?"denotation: string expected":null},e.fromObject=function(e){if(e instanceof c.onnx.TypeProto)return e;var t=new c.onnx.TypeProto;if(null!=e.tensorType){if("object"!=typeof e.tensorType)throw TypeError(".onnx.TypeProto.tensorType: object expected");t.tensorType=c.onnx.TypeProto.Tensor.fromObject(e.tensorType)}return null!=e.denotation&&(t.denotation=String(e.denotation)),t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.denotation=""),null!=e.tensorType&&e.hasOwnProperty("tensorType")&&(n.tensorType=c.onnx.TypeProto.Tensor.toObject(e.tensorType,t),t.oneofs&&(n.value="tensorType")),null!=e.denotation&&e.hasOwnProperty("denotation")&&(n.denotation=e.denotation),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e.Tensor=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.elemType=0,e.prototype.shape=null,e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.elemType&&e.hasOwnProperty("elemType")&&t.uint32(8).int32(e.elemType),null!=e.shape&&e.hasOwnProperty("shape")&&c.onnx.TensorShapeProto.encode(e.shape,t.uint32(18).fork()).ldelim(),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.TypeProto.Tensor;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.elemType=e.int32();break;case 2:r.shape=c.onnx.TensorShapeProto.decode(e,e.uint32());break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.elemType&&e.hasOwnProperty("elemType")&&!l.isInteger(e.elemType))return"elemType: integer expected";if(null!=e.shape&&e.hasOwnProperty("shape")){var t=c.onnx.TensorShapeProto.verify(e.shape);if(t)return"shape."+t}return null},e.fromObject=function(e){if(e instanceof c.onnx.TypeProto.Tensor)return e;var t=new c.onnx.TypeProto.Tensor;if(null!=e.elemType&&(t.elemType=0|e.elemType),null!=e.shape){if("object"!=typeof e.shape)throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");t.shape=c.onnx.TensorShapeProto.fromObject(e.shape)}return t},e.toObject=function(e,t){t||(t={});var n={};return t.defaults&&(n.elemType=0,n.shape=null),null!=e.elemType&&e.hasOwnProperty("elemType")&&(n.elemType=e.elemType),null!=e.shape&&e.hasOwnProperty("shape")&&(n.shape=c.onnx.TensorShapeProto.toObject(e.shape,t)),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),e}(),a.OperatorSetIdProto=function(){function e(e){if(e)for(var t=Object.keys(e),n=0;n<t.length;++n)null!=e[t[n]]&&(this[t[n]]=e[t[n]])}return e.prototype.domain="",e.prototype.version=l.Long?l.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=u.create()),null!=e.domain&&e.hasOwnProperty("domain")&&t.uint32(10).string(e.domain),null!=e.version&&e.hasOwnProperty("version")&&t.uint32(16).int64(e.version),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof o||(e=o.create(e));for(var n=void 0===t?e.len:e.pos+t,r=new c.onnx.OperatorSetIdProto;e.pos<n;){var s=e.uint32();switch(s>>>3){case 1:r.domain=e.string();break;case 2:r.version=e.int64();break;default:e.skipType(7&s)}}return r},e.decodeDelimited=function(e){return e instanceof o||(e=new o(e)),this.decode(e,e.uint32())},e.verify=function(e){return"object"!=typeof e||null===e?"object expected":null!=e.domain&&e.hasOwnProperty("domain")&&!l.isString(e.domain)?"domain: string expected":null!=e.version&&e.hasOwnProperty("version")&&!(l.isInteger(e.version)||e.version&&l.isInteger(e.version.low)&&l.isInteger(e.version.high))?"version: integer|Long expected":null},e.fromObject=function(e){if(e instanceof c.onnx.OperatorSetIdProto)return e;var t=new c.onnx.OperatorSetIdProto;return null!=e.domain&&(t.domain=String(e.domain)),null!=e.version&&(l.Long?(t.version=l.Long.fromValue(e.version)).unsigned=!1:"string"==typeof e.version?t.version=parseInt(e.version,10):"number"==typeof e.version?t.version=e.version:"object"==typeof e.version&&(t.version=new l.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber())),t},e.toObject=function(e,t){t||(t={});var n={};if(t.defaults)if(n.domain="",l.Long){var r=new l.Long(0,0,!1);n.version=t.longs===String?r.toString():t.longs===Number?r.toNumber():r}else n.version=t.longs===String?"0":0;return null!=e.domain&&e.hasOwnProperty("domain")&&(n.domain=e.domain),null!=e.version&&e.hasOwnProperty("version")&&("number"==typeof e.version?n.version=t.longs===String?String(e.version):e.version:n.version=t.longs===String?l.Long.prototype.toString.call(e.version):t.longs===Number?new l.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber():e.version),n},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),a),e.exports=c},2100:(e,t,n)=>{"use strict";e.exports=n(9482)},9482:(e,t,n)=>{"use strict";var r=t;function s(){r.util._configure(),r.Writer._configure(r.BufferWriter),r.Reader._configure(r.BufferReader)}r.build="minimal",r.Writer=n(1173),r.BufferWriter=n(3155),r.Reader=n(1408),r.BufferReader=n(593),r.util=n(9693),r.rpc=n(5994),r.roots=n(5054),r.configure=s,s()},1408:(e,t,n)=>{"use strict";e.exports=u;var r,s=n(9693),a=s.LongBits,i=s.utf8;function o(e,t){return RangeError("index out of range: "+e.pos+" + "+(t||1)+" > "+e.len)}function u(e){this.buf=e,this.pos=0,this.len=e.length}var l,c="undefined"!=typeof Uint8Array?function(e){if(e instanceof Uint8Array||Array.isArray(e))return new u(e);throw Error("illegal buffer")}:function(e){if(Array.isArray(e))return new u(e);throw Error("illegal buffer")},h=function(){return s.Buffer?function(e){return(u.create=function(e){return s.Buffer.isBuffer(e)?new r(e):c(e)})(e)}:c};function d(){var e=new a(0,0),t=0;if(!(this.len-this.pos>4)){for(;t<3;++t){if(this.pos>=this.len)throw o(this);if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(127&this.buf[this.pos++])<<7*t)>>>0,e}for(;t<4;++t)if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(127&this.buf[this.pos])<<28)>>>0,e.hi=(e.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return e;if(t=0,this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw o(this);if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}function p(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}function f(){if(this.pos+8>this.len)throw o(this,8);return new a(p(this.buf,this.pos+=4),p(this.buf,this.pos+=4))}u.create=h(),u.prototype._slice=s.Array.prototype.subarray||s.Array.prototype.slice,u.prototype.uint32=(l=4294967295,function(){if(l=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return l;if(l=(l|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return l;if(l=(l|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return l;if(l=(l|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return l;if(l=(l|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return l;if((this.pos+=5)>this.len)throw this.pos=this.len,o(this,10);return l}),u.prototype.int32=function(){return 0|this.uint32()},u.prototype.sint32=function(){var e=this.uint32();return e>>>1^-(1&e)},u.prototype.bool=function(){return 0!==this.uint32()},u.prototype.fixed32=function(){if(this.pos+4>this.len)throw o(this,4);return p(this.buf,this.pos+=4)},u.prototype.sfixed32=function(){if(this.pos+4>this.len)throw o(this,4);return 0|p(this.buf,this.pos+=4)},u.prototype.float=function(){if(this.pos+4>this.len)throw o(this,4);var e=s.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e},u.prototype.double=function(){if(this.pos+8>this.len)throw o(this,4);var e=s.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e},u.prototype.bytes=function(){var e=this.uint32(),t=this.pos,n=this.pos+e;if(n>this.len)throw o(this,e);return this.pos+=e,Array.isArray(this.buf)?this.buf.slice(t,n):t===n?new this.buf.constructor(0):this._slice.call(this.buf,t,n)},u.prototype.string=function(){var e=this.bytes();return i.read(e,0,e.length)},u.prototype.skip=function(e){if("number"==typeof e){if(this.pos+e>this.len)throw o(this,e);this.pos+=e}else do{if(this.pos>=this.len)throw o(this)}while(128&this.buf[this.pos++]);return this},u.prototype.skipType=function(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(e=7&this.uint32());)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+e+" at offset "+this.pos)}return this},u._configure=function(e){r=e,u.create=h(),r._configure();var t=s.Long?"toLong":"toNumber";s.merge(u.prototype,{int64:function(){return d.call(this)[t](!1)},uint64:function(){return d.call(this)[t](!0)},sint64:function(){return d.call(this).zzDecode()[t](!1)},fixed64:function(){return f.call(this)[t](!0)},sfixed64:function(){return f.call(this)[t](!1)}})}},593:(e,t,n)=>{"use strict";e.exports=a;var r=n(1408);(a.prototype=Object.create(r.prototype)).constructor=a;var s=n(9693);function a(e){r.call(this,e)}a._configure=function(){s.Buffer&&(a.prototype._slice=s.Buffer.prototype.slice)},a.prototype.string=function(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))},a._configure()},5054:e=>{"use strict";e.exports={}},5994:(e,t,n)=>{"use strict";t.Service=n(7948)},7948:(e,t,n)=>{"use strict";e.exports=s;var r=n(9693);function s(e,t,n){if("function"!=typeof e)throw TypeError("rpcImpl must be a function");r.EventEmitter.call(this),this.rpcImpl=e,this.requestDelimited=Boolean(t),this.responseDelimited=Boolean(n)}(s.prototype=Object.create(r.EventEmitter.prototype)).constructor=s,s.prototype.rpcCall=function e(t,n,s,a,i){if(!a)throw TypeError("request must be specified");var o=this;if(!i)return r.asPromise(e,o,t,n,s,a);if(o.rpcImpl)try{return o.rpcImpl(t,n[o.requestDelimited?"encodeDelimited":"encode"](a).finish(),function(e,n){if(e)return o.emit("error",e,t),i(e);if(null!==n){if(!(n instanceof s))try{n=s[o.responseDelimited?"decodeDelimited":"decode"](n)}catch(e){return o.emit("error",e,t),i(e)}return o.emit("data",n,t),i(null,n)}o.end(!0)})}catch(e){return o.emit("error",e,t),void setTimeout(function(){i(e)},0)}else setTimeout(function(){i(Error("already ended"))},0)},s.prototype.end=function(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(e,t,n)=>{"use strict";e.exports=s;var r=n(9693);function s(e,t){this.lo=e>>>0,this.hi=t>>>0}var a=s.zero=new s(0,0);a.toNumber=function(){return 0},a.zzEncode=a.zzDecode=function(){return this},a.length=function(){return 1};var i=s.zeroHash="\0\0\0\0\0\0\0\0";s.fromNumber=function(e){if(0===e)return a;var t=e<0;t&&(e=-e);var n=e>>>0,r=(e-n)/4294967296>>>0;return t&&(r=~r>>>0,n=~n>>>0,++n>4294967295&&(n=0,++r>4294967295&&(r=0))),new s(n,r)},s.from=function(e){if("number"==typeof e)return s.fromNumber(e);if(r.isString(e)){if(!r.Long)return s.fromNumber(parseInt(e,10));e=r.Long.fromString(e)}return e.low||e.high?new s(e.low>>>0,e.high>>>0):a},s.prototype.toNumber=function(e){if(!e&&this.hi>>>31){var t=1+~this.lo>>>0,n=~this.hi>>>0;return t||(n=n+1>>>0),-(t+4294967296*n)}return this.lo+4294967296*this.hi},s.prototype.toLong=function(e){return r.Long?new r.Long(0|this.lo,0|this.hi,Boolean(e)):{low:0|this.lo,high:0|this.hi,unsigned:Boolean(e)}};var o=String.prototype.charCodeAt;s.fromHash=function(e){return e===i?a:new s((o.call(e,0)|o.call(e,1)<<8|o.call(e,2)<<16|o.call(e,3)<<24)>>>0,(o.call(e,4)|o.call(e,5)<<8|o.call(e,6)<<16|o.call(e,7)<<24)>>>0)},s.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},s.prototype.zzEncode=function(){var e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this},s.prototype.zzDecode=function(){var e=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this},s.prototype.length=function(){var e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return 0===n?0===t?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:n<128?9:10}},9693:function(e,t,n){"use strict";var r=t;function s(e,t,n){for(var r=Object.keys(t),s=0;s<r.length;++s)void 0!==e[r[s]]&&n||(e[r[s]]=t[r[s]]);return e}function a(e){function t(e,n){if(!(this instanceof t))return new t(e,n);Object.defineProperty(this,"message",{get:function(){return e}}),Error.captureStackTrace?Error.captureStackTrace(this,t):Object.defineProperty(this,"stack",{value:(new Error).stack||""}),n&&s(this,n)}return(t.prototype=Object.create(Error.prototype)).constructor=t,Object.defineProperty(t.prototype,"name",{get:function(){return e}}),t.prototype.toString=function(){return this.name+": "+this.message},t}r.asPromise=n(4537),r.base64=n(7419),r.EventEmitter=n(9211),r.float=n(945),r.inquire=n(7199),r.utf8=n(4997),r.pool=n(6662),r.LongBits=n(1945),r.isNode=Boolean(void 0!==n.g&&n.g&&n.g.process&&n.g.process.versions&&n.g.process.versions.node),r.global=r.isNode&&n.g||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||this,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(e){return"number"==typeof e&&isFinite(e)&&Math.floor(e)===e},r.isString=function(e){return"string"==typeof e||e instanceof String},r.isObject=function(e){return e&&"object"==typeof e},r.isset=r.isSet=function(e,t){var n=e[t];return!(null==n||!e.hasOwnProperty(t))&&("object"!=typeof n||(Array.isArray(n)?n.length:Object.keys(n).length)>0)},r.Buffer=function(){try{var e=r.inquire("buffer").Buffer;return e.prototype.utf8Write?e:null}catch(e){return null}}(),r._Buffer_from=null,r._Buffer_allocUnsafe=null,r.newBuffer=function(e){return"number"==typeof e?r.Buffer?r._Buffer_allocUnsafe(e):new r.Array(e):r.Buffer?r._Buffer_from(e):"undefined"==typeof Uint8Array?e:new Uint8Array(e)},r.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire("long"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(e){return e?r.LongBits.from(e).toHash():r.LongBits.zeroHash},r.longFromHash=function(e,t){var n=r.LongBits.fromHash(e);return r.Long?r.Long.fromBits(n.lo,n.hi,t):n.toNumber(Boolean(t))},r.merge=s,r.lcFirst=function(e){return e.charAt(0).toLowerCase()+e.substring(1)},r.newError=a,r.ProtocolError=a("ProtocolError"),r.oneOfGetter=function(e){for(var t={},n=0;n<e.length;++n)t[e[n]]=1;return function(){for(var e=Object.keys(this),n=e.length-1;n>-1;--n)if(1===t[e[n]]&&void 0!==this[e[n]]&&null!==this[e[n]])return e[n]}},r.oneOfSetter=function(e){return function(t){for(var n=0;n<e.length;++n)e[n]!==t&&delete this[e[n]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r._configure=function(){var e=r.Buffer;e?(r._Buffer_from=e.from!==Uint8Array.from&&e.from||function(t,n){return new e(t,n)},r._Buffer_allocUnsafe=e.allocUnsafe||function(t){return new e(t)}):r._Buffer_from=r._Buffer_allocUnsafe=null}},1173:(e,t,n)=>{"use strict";e.exports=h;var r,s=n(9693),a=s.LongBits,i=s.base64,o=s.utf8;function u(e,t,n){this.fn=e,this.len=t,this.next=void 0,this.val=n}function l(){}function c(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}function h(){this.len=0,this.head=new u(l,0,0),this.tail=this.head,this.states=null}var d=function(){return s.Buffer?function(){return(h.create=function(){return new r})()}:function(){return new h}};function p(e,t,n){t[n]=255&e}function f(e,t){this.len=e,this.next=void 0,this.val=t}function m(e,t,n){for(;e.hi;)t[n++]=127&e.lo|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[n++]=127&e.lo|128,e.lo=e.lo>>>7;t[n++]=e.lo}function g(e,t,n){t[n]=255&e,t[n+1]=e>>>8&255,t[n+2]=e>>>16&255,t[n+3]=e>>>24}h.create=d(),h.alloc=function(e){return new s.Array(e)},s.Array!==Array&&(h.alloc=s.pool(h.alloc,s.Array.prototype.subarray)),h.prototype._push=function(e,t,n){return this.tail=this.tail.next=new u(e,t,n),this.len+=t,this},f.prototype=Object.create(u.prototype),f.prototype.fn=function(e,t,n){for(;e>127;)t[n++]=127&e|128,e>>>=7;t[n]=e},h.prototype.uint32=function(e){return this.len+=(this.tail=this.tail.next=new f((e>>>=0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this},h.prototype.int32=function(e){return e<0?this._push(m,10,a.fromNumber(e)):this.uint32(e)},h.prototype.sint32=function(e){return this.uint32((e<<1^e>>31)>>>0)},h.prototype.uint64=function(e){var t=a.from(e);return this._push(m,t.length(),t)},h.prototype.int64=h.prototype.uint64,h.prototype.sint64=function(e){var t=a.from(e).zzEncode();return this._push(m,t.length(),t)},h.prototype.bool=function(e){return this._push(p,1,e?1:0)},h.prototype.fixed32=function(e){return this._push(g,4,e>>>0)},h.prototype.sfixed32=h.prototype.fixed32,h.prototype.fixed64=function(e){var t=a.from(e);return this._push(g,4,t.lo)._push(g,4,t.hi)},h.prototype.sfixed64=h.prototype.fixed64,h.prototype.float=function(e){return this._push(s.float.writeFloatLE,4,e)},h.prototype.double=function(e){return this._push(s.float.writeDoubleLE,8,e)};var b=s.Array.prototype.set?function(e,t,n){t.set(e,n)}:function(e,t,n){for(var r=0;r<e.length;++r)t[n+r]=e[r]};h.prototype.bytes=function(e){var t=e.length>>>0;if(!t)return this._push(p,1,0);if(s.isString(e)){var n=h.alloc(t=i.length(e));i.decode(e,n,0),e=n}return this.uint32(t)._push(b,t,e)},h.prototype.string=function(e){var t=o.length(e);return t?this.uint32(t)._push(o.write,t,e):this._push(p,1,0)},h.prototype.fork=function(){return this.states=new c(this),this.head=this.tail=new u(l,0,0),this.len=0,this},h.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new u(l,0,0),this.len=0),this},h.prototype.ldelim=function(){var e=this.head,t=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=e.next,this.tail=t,this.len+=n),this},h.prototype.finish=function(){for(var e=this.head.next,t=this.constructor.alloc(this.len),n=0;e;)e.fn(e.val,t,n),n+=e.len,e=e.next;return t},h._configure=function(e){r=e,h.create=d(),r._configure()}},3155:(e,t,n)=>{"use strict";e.exports=a;var r=n(1173);(a.prototype=Object.create(r.prototype)).constructor=a;var s=n(9693);function a(){r.call(this)}function i(e,t,n){e.length<40?s.utf8.write(e,t,n):t.utf8Write?t.utf8Write(e,n):t.write(e,n)}a._configure=function(){a.alloc=s._Buffer_allocUnsafe,a.writeBytesBuffer=s.Buffer&&s.Buffer.prototype instanceof Uint8Array&&"set"===s.Buffer.prototype.set.name?function(e,t,n){t.set(e,n)}:function(e,t,n){if(e.copy)e.copy(t,n,0,e.length);else for(var r=0;r<e.length;)t[n++]=e[r++]}},a.prototype.bytes=function(e){s.isString(e)&&(e=s._Buffer_from(e,"base64"));var t=e.length>>>0;return this.uint32(t),t&&this._push(a.writeBytesBuffer,t,e),this},a.prototype.string=function(e){var t=s.Buffer.byteLength(e);return this.uint32(t),t&&this._push(i,t,e),this},a._configure()},7714:(e,t,n)=>{"use strict";t.R=void 0;const r=n(6919),s=n(7448);t.R=new class{async init(){}async createSessionHandler(e,t){const n=new r.Session(t);return await n.loadModel(e),new s.OnnxjsSessionHandler(n)}}},4200:(e,t,n)=>{"use strict";t.c8=t.rX=void 0;const r=n(1670),s=n(5381),a=n(2157),i=n(2306);t.rX=()=>{if(("number"!=typeof r.env.wasm.initTimeout||r.env.wasm.initTimeout<0)&&(r.env.wasm.initTimeout=0),"boolean"!=typeof r.env.wasm.simd&&(r.env.wasm.simd=!0),"boolean"!=typeof r.env.wasm.proxy&&(r.env.wasm.proxy=!1),"number"!=typeof r.env.wasm.numThreads||!Number.isInteger(r.env.wasm.numThreads)||r.env.wasm.numThreads<=0){const e="undefined"==typeof navigator?(0,s.cpus)().length:navigator.hardwareConcurrency;r.env.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},t.c8=new class{async init(){(0,t.rX)(),await(0,a.initWasm)()}async createSessionHandler(e,t){const n=new i.OnnxruntimeWebAssemblySessionHandler;return await n.loadModel(e,t),Promise.resolve(n)}}},6018:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var s=Object.getOwnPropertyDescriptor(t,n);s&&!("get"in s?!t.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,s)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),s=this&&this.__exportStar||function(e,t){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(t,n)||r(t,e,n)};Object.defineProperty(t,"__esModule",{value:!0}),s(n(1670),t);const a=n(1670);{const e=n(7714).R;(0,a.registerBackend)("webgl",e,-10)}{const e=n(4200).c8;(0,a.registerBackend)("cpu",e,10),(0,a.registerBackend)("wasm",e,10),(0,a.registerBackend)("xnnpack",e,9)}},246:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createAttributeWithCacheKey=void 0;class n{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this._cacheKey}}t.createAttributeWithCacheKey=e=>new n(e)},7778:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Attribute=void 0;const r=n(1446),s=n(9395),a=n(9162),i=n(2517);var o=s.onnxruntime.experimental.fbs;class u{constructor(e){if(this._attributes=new Map,null!=e){for(const t of e)t instanceof r.onnx.AttributeProto?this._attributes.set(t.name,[u.getValue(t),u.getType(t)]):t instanceof o.Attribute&&this._attributes.set(t.name(),[u.getValue(t),u.getType(t)]);if(this._attributes.size<e.length)throw new Error("duplicated attribute names")}}set(e,t,n){this._attributes.set(e,[n,t])}delete(e){this._attributes.delete(e)}getFloat(e,t){return this.get(e,"float",t)}getInt(e,t){return this.get(e,"int",t)}getString(e,t){return this.get(e,"string",t)}getTensor(e,t){return this.get(e,"tensor",t)}getFloats(e,t){return this.get(e,"floats",t)}getInts(e,t){return this.get(e,"ints",t)}getStrings(e,t){return this.get(e,"strings",t)}getTensors(e,t){return this.get(e,"tensors",t)}get(e,t,n){const r=this._attributes.get(e);if(void 0===r){if(void 0!==n)return n;throw new Error(`required attribute not found: ${e}`)}if(r[1]!==t)throw new Error(`type mismatch: expected ${t} but got ${r[1]}`);return r[0]}static getType(e){const t=e instanceof r.onnx.AttributeProto?e.type:e.type();switch(t){case r.onnx.AttributeProto.AttributeType.FLOAT:return"float";case r.onnx.AttributeProto.AttributeType.INT:return"int";case r.onnx.AttributeProto.AttributeType.STRING:return"string";case r.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case r.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case r.onnx.AttributeProto.AttributeType.INTS:return"ints";case r.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case r.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${r.onnx.AttributeProto.AttributeType[t]}`)}}static getValue(e){const t=e instanceof r.onnx.AttributeProto?e.type:e.type();if(t===r.onnx.AttributeProto.AttributeType.GRAPH||t===r.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const n=this.getValueNoCheck(e);if(t===r.onnx.AttributeProto.AttributeType.INT&&i.LongUtil.isLong(n))return i.LongUtil.longToNumber(n);if(t===r.onnx.AttributeProto.AttributeType.INTS){const e=n,t=new Array(e.length);for(let n=0;n<e.length;n++){const r=e[n];t[n]=i.LongUtil.longToNumber(r)}return t}if(t===r.onnx.AttributeProto.AttributeType.TENSOR)return e instanceof r.onnx.AttributeProto?a.Tensor.fromProto(n):a.Tensor.fromOrtTensor(n);if(t===r.onnx.AttributeProto.AttributeType.TENSORS){if(e instanceof r.onnx.AttributeProto)return n.map(e=>a.Tensor.fromProto(e));if(e instanceof o.Attribute)return n.map(e=>a.Tensor.fromOrtTensor(e))}if(t===r.onnx.AttributeProto.AttributeType.STRING&&e instanceof r.onnx.AttributeProto){const e=n;return(0,i.decodeUtf8String)(e)}return t===r.onnx.AttributeProto.AttributeType.STRINGS&&e instanceof r.onnx.AttributeProto?n.map(i.decodeUtf8String):n}static getValueNoCheck(e){return e instanceof r.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(e):this.getValueNoCheckFromOrtFormat(e)}static getValueNoCheckFromOnnxFormat(e){switch(e.type){case r.onnx.AttributeProto.AttributeType.FLOAT:return e.f;case r.onnx.AttributeProto.AttributeType.INT:return e.i;case r.onnx.AttributeProto.AttributeType.STRING:return e.s;case r.onnx.AttributeProto.AttributeType.TENSOR:return e.t;case r.onnx.AttributeProto.AttributeType.GRAPH:return e.g;case r.onnx.AttributeProto.AttributeType.FLOATS:return e.floats;case r.onnx.AttributeProto.AttributeType.INTS:return e.ints;case r.onnx.AttributeProto.AttributeType.STRINGS:return e.strings;case r.onnx.AttributeProto.AttributeType.TENSORS:return e.tensors;case r.onnx.AttributeProto.AttributeType.GRAPHS:return e.graphs;default:throw new Error(`unsupported attribute type: ${r.onnx.AttributeProto.AttributeType[e.type]}`)}}static getValueNoCheckFromOrtFormat(e){switch(e.type()){case o.AttributeType.FLOAT:return e.f();case o.AttributeType.INT:return e.i();case o.AttributeType.STRING:return e.s();case o.AttributeType.TENSOR:return e.t();case o.AttributeType.GRAPH:return e.g();case o.AttributeType.FLOATS:return e.floatsArray();case o.AttributeType.INTS:{const t=[];for(let n=0;n<e.intsLength();n++)t.push(e.ints(n));return t}case o.AttributeType.STRINGS:{const t=[];for(let n=0;n<e.stringsLength();n++)t.push(e.strings(n));return t}case o.AttributeType.TENSORS:{const t=[];for(let n=0;n<e.tensorsLength();n++)t.push(e.tensors(n));return t}default:throw new Error(`unsupported attribute type: ${o.AttributeType[e.type()]}`)}}}t.Attribute=u},7091:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.resolveBackend=t.backend=void 0;const r=n(5038),s=new Map;async function a(e){const n=t.backend;if(void 0!==n[e]&&function(e){const t=e;return"initialize"in t&&"function"==typeof t.initialize&&"createSessionHandler"in t&&"function"==typeof t.createSessionHandler&&"dispose"in t&&"function"==typeof t.dispose}(n[e])){const t=n[e];let r=t.initialize();if("object"==typeof r&&"then"in r&&(r=await r),r)return s.set(e,t),t}}t.backend={webgl:new r.WebGLBackend},t.resolveBackend=async function e(t){if(!t)return e(["webgl"]);{const e="string"==typeof t?[t]:t;for(const t of e){const e=s.get(t);if(e)return e;const n=await a(t);if(n)return n}}throw new Error("no available backend to use")}},5038:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLBackend=void 0;const r=n(1670),s=n(6231),a=n(6416),i=n(7305);t.WebGLBackend=class{get contextId(){return r.env.webgl.contextId}set contextId(e){r.env.webgl.contextId=e}get matmulMaxBatchSize(){return r.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(e){r.env.webgl.matmulMaxBatchSize=e}get textureCacheMode(){return r.env.webgl.textureCacheMode}set textureCacheMode(e){r.env.webgl.textureCacheMode=e}get pack(){return r.env.webgl.pack}set pack(e){r.env.webgl.pack=e}get async(){return r.env.webgl.async}set async(e){r.env.webgl.async=e}initialize(){try{return this.glContext=(0,i.createWebGLContext)(this.contextId),"number"!=typeof this.matmulMaxBatchSize&&(this.matmulMaxBatchSize=16),"string"!=typeof this.textureCacheMode&&(this.textureCacheMode="full"),"boolean"!=typeof this.pack&&(this.pack=!1),"boolean"!=typeof this.async&&(this.async=!1),s.Logger.setWithEnv(r.env),s.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return s.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(e){return new a.WebGLSessionHandler(this,e)}dispose(){this.glContext.dispose()}}},5107:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CoordsGlslLib=void 0;const r=n(2517),s=n(8520),a=n(5060),i=n(7859),o=n(9390);class u extends s.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new s.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ")}}coordsToOffset(){return{coordsToOffset:new s.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ")}}getOutputSamplingSnippet(){const e=this.context.outputTextureLayout;return e.isPacked?this.getPackedOutputSamplingSnippet(e):this.getUnpackedOutputSamplingSnippet(e)}getPackedOutputSamplingSnippet(e){const t=e.unpackedShape,n=[e.width,e.height],r={},i="getOutputCoords";switch(t.length){case 0:r[i]=this.getOutputScalarCoords();break;case 1:r[i]=this.getOutputPacked1DCoords(t,n);break;case 2:r[i]=this.getOutputPacked2DCoords(t,n);break;case 3:r[i]=this.getOutputPacked3DCoords(t,n);break;default:r[i]=this.getOutputPackedNDCoords(t,n)}const o=`\n      void setOutput(vec4 val) {\n        ${(0,a.getGlsl)(this.context.glContext.version).output} = val;\n      }\n    `;return r.floatTextureSetRGBA=new s.GlslLibRoutine(o),r}getUnpackedOutputSamplingSnippet(e){const t=e.unpackedShape,n=[e.width,e.height],r={},i="getOutputCoords";switch(t.length){case 0:r[i]=this.getOutputScalarCoords();break;case 1:r[i]=this.getOutputUnpacked1DCoords(t,n);break;case 2:r[i]=this.getOutputUnpacked2DCoords(t,n);break;case 3:r[i]=this.getOutputUnpacked3DCoords(t,n);break;case 4:r[i]=this.getOutputUnpacked4DCoords(t,n);break;case 5:r[i]=this.getOutputUnpacked5DCoords(t,n);break;case 6:r[i]=this.getOutputUnpacked6DCoords(t,n);break;default:throw new Error(`Unsupported output dimensionality: ${t.length}`)}const o=`\n        void setOutput(float val) {\n          ${(0,a.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\n        }\n    `;return r.floatTextureSetR=new s.GlslLibRoutine(o),r}getOutputScalarCoords(){return new s.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ")}getOutputPacked1DCoords(e,t){const n=t;let r="";return 1===n[0]?(r=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${n[1]}.0);\n          }\n        `,new s.GlslLibRoutine(r)):1===n[1]?(r=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${n[0]}.0);\n          }\n        `,new s.GlslLibRoutine(r)):(r=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${n[0]}, ${n[1]}));\n          return 2 * (resTexRC.y * ${n[0]} + resTexRC.x);\n        }\n      `,new s.GlslLibRoutine(r))}getOutputPacked2DCoords(e,t){let n="";if(r.ArrayUtil.arraysEqual(e,t))return n=`\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${t[0]}, ${t[1]}));\n        }\n      `,new s.GlslLibRoutine(n);const a=t,i=Math.ceil(e[1]/2);return n=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${a[0]}, ${a[1]}));\n\n          int index = resTexRC.y * ${a[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${i}) * 2;\n          int c = 2 * (index / ${i});\n\n          return ivec2(r, c);\n        }\n      `,new s.GlslLibRoutine(n)}getOutputPacked3DCoords(e,t){const n=[t[0],t[1]],r=Math.ceil(e[2]/2),a=r*Math.ceil(e[1]/2),i=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${n[0]}, ${n[1]}));\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n          int b = index / ${a};\n          index -= b * ${a};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${r}) * 2;\n          int c = 2 * (index / ${r});\n\n          return ivec3(b, r, c);\n        }\n      `;return new s.GlslLibRoutine(i)}getOutputPackedNDCoords(e,t){const n=[t[0],t[1]],r=Math.ceil(e[e.length-1]/2),a=r*Math.ceil(e[e.length-2]/2);let i=a,o="",u="b, r, c";for(let t=2;t<e.length-1;t++)i*=e[e.length-t-1],o=`\n      int b${t} = index / ${i};\n      index -= b${t} * ${i};\n    `+o,u=`b${t}, `+u;const l=`\n      ivec${e.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n        ${o}\n\n        int b = index / ${a};\n        index -= b * ${a};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${r}) * 2;\n        int c = 2 * (index / ${r});\n\n        return ivec${e.length}(${u});\n      }\n    `;return new s.GlslLibRoutine(l)}getOutputUnpacked1DCoords(e,t){const n=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          return resTexRC.y * ${t[0]} + resTexRC.x;\n        }\n      `;return new s.GlslLibRoutine(n)}getOutputUnpacked2DCoords(e,t){const n=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          int r = index / ${e[1]};\n          int c = index - r * ${e[1]};\n          return ivec2(r, c);\n        }\n      `;return new s.GlslLibRoutine(n)}getOutputUnpacked3DCoords(e,t){let n="";const r=e.length;let a=null;r<2&&(a=[]),a=new Array(r-1),a[r-2]=e[r-1];for(let t=r-3;t>=0;--t)a[t]=a[t+1]*e[t+1];const i=["r","c","d"],o=a.map((e,t)=>`int ${i[t]} = index / ${e}; ${t===a.length-1?`int ${i[t+1]} = index - ${i[t]} * ${e}`:`index -= ${i[t]} * ${e}`};`).join("");return n=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${o}\n          return ivec3(r, c, d);\n        }\n      `,new s.GlslLibRoutine(n)}getOutputUnpacked4DCoords(e,t){let n="";const r=e.length;let a=null;r<2&&(a=[]),a=new Array(r-1),a[r-2]=e[r-1];for(let t=r-3;t>=0;--t)a[t]=a[t+1]*e[t+1];const i=["r","c","d","d2"],o=a.map((e,t)=>`int ${i[t]} = index / ${e}; ${t===a.length-1?`int ${i[t+1]} = index - ${i[t]} * ${e}`:`index -= ${i[t]} * ${e}`};`).join("");return n=`\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${o}\n          return ivec4(r, c, d, d2);\n        }\n      `,new s.GlslLibRoutine(n)}getOutputUnpacked5DCoords(e,t){let n="";const r=e.length;let a=null;r<2&&(a=[]),a=new Array(r-1),a[r-2]=e[r-1];for(let t=r-3;t>=0;--t)a[t]=a[t+1]*e[t+1];const i=["r","c","d","d2","d3"],o=a.map((e,t)=>`int ${i[t]} = index / ${e}; ${t===a.length-1?`int ${i[t+1]} = index - ${i[t]} * ${e}`:`index -= ${i[t]} * ${e}`};`).join("");return n=`\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${o}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `,new s.GlslLibRoutine(n)}getOutputUnpacked6DCoords(e,t){let n="";const r=e.length;let a=null;r<2&&(a=[]),a=new Array(r-1),a[r-2]=e[r-1];for(let t=r-3;t>=0;--t)a[t]=a[t+1]*e[t+1];const i=["r","c","d","d2","d3","d4"],o=a.map((e,t)=>`int ${i[t]} = index / ${e}; ${t===a.length-1?`int ${i[t+1]} = index - ${i[t]} * ${e}`:`index -= ${i[t]} * ${e}`};`).join("");return n=`\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${t[0]}, ${t[1]}));\n         int index = resTexRC.y * ${t[0]} + resTexRC.x;\n         ${o}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `,new s.GlslLibRoutine(n)}getCommonUtilFuncs(){const e={};let t="uvFromFlat";e[t]=new s.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "),t="packedUVfrom1D",e[t]=new s.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),t="packedUVfrom2D",e[t]=new s.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),t="packedUVfrom3D",e[t]=new s.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),t="sampleTexture";const n=(0,a.getGlsl)(this.context.glContext.version);return e[t]=new s.GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${n.texture2D}(textureSampler, uv).r;\n        }`),e}getInputsSamplingSnippets(){const e={},t=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((n,r)=>{const s=this.context.inputTextureLayouts[r],a=(0,o.generateShaderFuncNameFromInputSamplerName)(n);s.isPacked?e[a]=this.getPackedSamplerFromInput(a,n,s):e[a]=this.getUnpackedSamplerFromInput(a,n,s);const i=(0,o.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n);s.unpackedShape.length<=t.unpackedShape.length&&(s.isPacked?e[i]=this.getPackedSamplerAtOutputCoords(i,s,t,n):e[i]=this.getUnpackedSamplerAtOutputCoords(i,s,t,n))}),e}getPackedSamplerAtOutputCoords(e,t,n,a){const i=t.unpackedShape,u=n.unpackedShape,l=a,c=(0,o.generateShaderFuncNameFromInputSamplerName)(l),h=i.length,d=u.length,p=r.BroadcastUtil.getBroadcastDims(i,u),f=(0,o.getCoordsDataType)(d),m=d-h;let g;const b=(0,o.getGlChannels)();g=0===h?"":d<2&&p.length>=1?"coords = 0;":p.map(e=>`coords.${b[e+m]} = 0;`).join("\n");let y="";y=d<2&&h>0?"coords":i.map((e,t)=>`coords.${b[t+m]}`).join(", ");let x="return outputValue;";const w=1===r.ShapeUtil.size(i),v=1===r.ShapeUtil.size(u);if(1!==h||w||v){if(w&&!v)x=1===d?"\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ":"\n          return vec4(outputValue.x);\n        ";else if(p.length){const e=h-2,t=h-1;p.indexOf(e)>-1&&p.indexOf(t)>-1?x="return vec4(outputValue.x);":p.indexOf(e)>-1?x="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":p.indexOf(t)>-1&&(x="return vec4(outputValue.xx, outputValue.zz);")}}else x="\n        return vec4(outputValue.xy, outputValue.xy);\n      ";const _=`\n      vec4 ${e}() {\n        ${f} coords = getOutputCoords();\n        \n        int lastDim = coords.${b[d-1]};\n        coords.${b[d-1]} = coords.${b[d-2]};\n        coords.${b[d-2]} = lastDim;\n      \n        ${g}\n        vec4 outputValue = ${c}(${y});\n        ${x}\n      }\n    `;return new s.GlslLibRoutine(_,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(e,t,n,a){const i=[n.width,n.height],u=[t.width,t.height],l=t.unpackedShape.length,c=n.unpackedShape.length,h=t.unpackedShape,d=n.unpackedShape,p=(0,o.generateShaderFuncNameFromInputSamplerName)(a);if(l===c&&r.ArrayUtil.arraysEqual(u,i)){const t=`\n          float ${e}() {\n            return sampleTexture(${a}, TexCoords);\n          }\n        `;return new s.GlslLibRoutine(t,["coordinates.sampleTexture"])}const f=(0,o.getCoordsDataType)(c),m=r.BroadcastUtil.getBroadcastDims(h,d),g=c-l;let b;const y=(0,o.getGlChannels)();b=0===l?"":c<2&&m.length>=1?"coords = 0;":m.map(e=>`coords.${y[e+g]} = 0;`).join("\n");let x="";x=c<2&&l>0?"coords":t.unpackedShape.map((e,t)=>`coords.${y[t+g]}`).join(", ");const w=`\n        float ${e}() {\n          ${f} coords = getOutputCoords();\n          ${b}\n          return ${p}(${x});\n        }\n      `;return new s.GlslLibRoutine(w,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(e,t,n){switch(n.unpackedShape.length){case 0:return this.getPackedSamplerScalar(e,t);case 1:return this.getPackedSampler1D(e,t,n);case 2:return this.getPackedSampler2D(e,t,n);case 3:return this.getPackedSampler3D(e,t,n);default:return this.getPackedSamplerND(e,t,n)}}getUnpackedSamplerFromInput(e,t,n){const r=n.unpackedShape;switch(r.length){case 0:return this.getUnpackedSamplerScalar(e,t,n);case 1:return this.getUnpackedSampler1D(e,t,n);case 2:return this.getUnpackedSampler2D(e,t,n);case 3:return this.getUnpackedSampler3D(e,t,n);case 4:return this.getUnpackedSampler4D(e,t,n);case 5:return this.getUnpackedSampler5D(e,t,n);case 6:return this.getUnpackedSampler6D(e,t,n);default:throw new Error(`Unsupported dimension ${r.length}-D`)}}getPackedSamplerScalar(e,t){const n=`\n          vec4 ${e}() {\n            return ${(0,a.getGlsl)(this.context.glContext.version).texture2D}(${t}, halfCR);\n          }\n        `;return new s.GlslLibRoutine(n)}getPackedSampler1D(e,t,n){const r=[n.width,n.height],i=[r[1],r[0]],o=(0,a.getGlsl)(this.context.glContext.version),u=`vec4 ${e}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${i[0]}, ${i[1]}, index);\n      return ${o.texture2D}(${t}, uv);\n    }`;return new s.GlslLibRoutine(u,["coordinates.packedUVfrom1D"])}getPackedSampler2D(e,t,n){const i=n.unpackedShape,o=[n.width,n.height],u=(0,a.getGlsl)(this.context.glContext.version),l=o[0],c=o[1];if(null!=o&&r.ArrayUtil.arraysEqual(i,o)){const n=`vec4 ${e}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${l}.0);\n        return ${u.texture2D}(${t}, uv);\n      }`;return new s.GlslLibRoutine(n)}const h=o,d=Math.ceil(i[1]/2),p=`vec4 ${e}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${h[1]}, ${h[0]}, ${d}, row, col);\n      return ${u.texture2D}(${t}, uv);\n    }`;return new s.GlslLibRoutine(p,["coordinates.packedUVfrom2D"])}getPackedSampler3D(e,t,n){const r=n.unpackedShape,i=[n.width,n.height],u=[i[0],i[1]],l=(0,a.getGlsl)(this.context.glContext.version);if(1===r[0]){const a=r.slice(1),i=[1,2],u=(0,o.squeezeInputShape)(r,a),l=["b","row","col"],c=JSON.parse(JSON.stringify(n));c.unpackedShape=u;const h=this.getPackedSamplerFromInput(e,t,c),d=`${h.routineBody}\n      vec4 ${e}(int b, int row, int col) {\n        return ${e}(${(0,o.getSqueezedParams)(l,i)});\n      } `;return new s.GlslLibRoutine(d,h.dependencies)}const c=u[0],h=u[1],d=Math.ceil(r[2]/2),p=`vec4 ${e}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${h}, ${c}, ${d*Math.ceil(r[1]/2)}, ${d}, b, row, col);\n      return ${l.texture2D}(${t}, uv);}`;return new s.GlslLibRoutine(p,["coordinates.packedUVfrom3D"])}getPackedSamplerND(e,t,n){const r=n.unpackedShape,i=r.length,o=[n.width,n.height],u=(0,a.getGlsl)(this.context.glContext.version),l=[o[0],o[1]],c=l[1],h=l[0],d=Math.ceil(r[i-1]/2);let p=d*Math.ceil(r[i-2]/2),f="int b, int row, int col",m=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let e=2;e<i-1;e++)f=`int b${e}, `+f,p*=r[i-e-1],m=`b${e} * ${p} + `+m;const g=`vec4 ${e}(${f}) {\n      int index = ${m};\n      int texR = index / ${h};\n      int texC = index - texR * ${h};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${c});\n      return ${u.texture2D}(${t}, uv);\n    }`;return new s.GlslLibRoutine(g)}getUnpackedSamplerScalar(e,t,n){const[r,a]=[n.width,n.height];if(1===r&&1===a){const n=`\n          float ${e}() {\n            return sampleTexture(${t}, halfCR);\n          }\n        `;return new s.GlslLibRoutine(n,["coordinates.sampleTexture"])}const i=`\n        float ${e}() {\n          int offset_${t} = coordsToOffset(TexCoords, ${r}, ${a});\n          vec2 uv = uvFromFlat(${r}, ${a}, offset_${t});\n          return sampleTexture(${t}, uv);\n        }\n      `;return new s.GlslLibRoutine(i,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(e,t,n){const r=n.width,a=n.height;if(1===a&&1===r){const n=`\n        float ${e}(int index) {\n          return sampleTexture(${t}, halfCR);\n        }\n      `;return new s.GlslLibRoutine(n,["coordinates.sampleTexture"])}if(1===a){const n=`\n          float ${e}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${r}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new s.GlslLibRoutine(n,["coordinates.sampleTexture"])}if(1===r){const n=`\n          float ${e}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${a}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new s.GlslLibRoutine(n,["coordinates.sampleTexture"])}const i=`\n        float ${e}(int index) {\n          vec2 uv = uvFromFlat(${r}, ${a}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new s.GlslLibRoutine(i,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(e,t,n){const a=n.unpackedShape,u=[n.height,n.width];if(null!=u&&r.ArrayUtil.arraysEqual(a,u)){const n=`\n          float ${e}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u[1]}.0, ${u[0]}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new s.GlslLibRoutine(n,["coordinates.sampleTexture"])}const{newShape:l,keptDims:c}=(0,i.squeezeShape)(a),h=l;if(h.length<a.length){const r=(0,o.squeezeInputShape)(a,h),i=JSON.parse(JSON.stringify(n));i.unpackedShape=r;const u=["col","row"],l=`\n          ${this.getUnpackedSamplerFromInput(e,t,i).routineBody}\n          float ${e}(int row, int col) {\n            return ${e}(${(0,o.getSqueezedParams)(u,c)});\n          }\n        `;return new s.GlslLibRoutine(l,["coordinates.sampleTexture"])}const d=u[1],p=u[0];if(1===p){const n=`\n          float ${e}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${d}, ${p});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${a[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new s.GlslLibRoutine(n,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(1===d){const n=`\n          float ${e}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${d}, ${p});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${a[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new s.GlslLibRoutine(n,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const f=`\n        float ${e}(int row, int col) {\n          int index = col * ${a[1]} + row;\n          vec2 uv = uvFromFlat(${d}, ${p}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new s.GlslLibRoutine(f,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(e,t,n){const r=n.unpackedShape,a=r[1]*r[2],u=r[2],{newShape:l,keptDims:c}=(0,i.squeezeShape)(r),h=l;if(h.length<r.length){const a=(0,o.squeezeInputShape)(r,h),i=["batch","col","row"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=a;const l=this.getUnpackedSamplerFromInput(e,t,u),d=c.reverse(),p=`\n          ${l.routineBody}\n          float ${e}(int batch, int row, int col) {\n            return ${e}(${(0,o.getSqueezedParams)(i,d)});\n          }\n        `;return new s.GlslLibRoutine(p,l.dependencies)}const d=`\n          float ${e}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${a} + col * ${u} + row;\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n            return sampleTexture(${t}, uv);\n          }\n      `;return new s.GlslLibRoutine(d,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(e,t,n){const r=n.unpackedShape,a=r[3],i=r[2]*a,o=`\n        float ${e}(int row, int col, int depth, int depth2) {\n          int index = row * ${r[1]*i} + col * ${i} +\n              depth2 * ${a} + depth;\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new s.GlslLibRoutine(o,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(e,t,n){const r=n.unpackedShape,a=r[4],u=r[3]*a,l=r[2]*u,c=r[1]*l,{newShape:h,keptDims:d}=(0,i.squeezeShape)(r);if(h.length<r.length){const a=(0,o.squeezeInputShape)(r,h),i=["row","col","depth","depth2","depth3"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=a;const l=`\n          ${this.getUnpackedSamplerFromInput(e,t,u).routineBody}\n          float ${e}(int row, int col, int depth, int depth2, int depth3) {\n            return ${e}(${(0,o.getSqueezedParams)(i,d)});\n          }\n        `;return new s.GlslLibRoutine(l,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const p=`\n        float ${e}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth3 * ${a} + depth2;\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new s.GlslLibRoutine(p,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(e,t,n){const r=n.unpackedShape,a=r[5],u=r[4]*a,l=r[3]*u,c=r[2]*l,h=r[1]*c,{newShape:d,keptDims:p}=(0,i.squeezeShape)(r);if(d.length<r.length){const a=(0,o.squeezeInputShape)(r,d),i=["row","col","depth","depth2","depth3","depth4"],u=JSON.parse(JSON.stringify(n));u.unpackedShape=a;const l=`\n            ${this.getUnpackedSamplerFromInput(e,t,u).routineBody}\n            float ${e}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${e}(${(0,o.getSqueezedParams)(i,p)});\n            }\n          `;return new s.GlslLibRoutine(l,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const f=`\n          float ${e}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${h} + col * ${c} + depth * ${l} +\n            depth2 * ${u} + depth3 * ${a} + depth4;\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new s.GlslLibRoutine(f,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const e=this.context.outputTextureLayout,t=e.shape.length,n=e.strides,r=e.width,a=e.height,i=[];for(let e=0;e<t-1;++e)i.push(`\n        c[${e}] = offset / ${n[e]};`),i.push(`\n        offset -= c[${e}] * ${n[e]};`);i.push(`\n        c[${t-1}] = offset;`);const o=`\n      void toVec(vec2 texCoords, out int c[${t}]) {\n        int offset = coordsToOffset(texCoords, ${r}, ${a});\n        ${i.join("")}\n      }\n      void toVec(int offset, out int c[${t}]) {\n        ${i.join("")}\n      }\n    `;return{toVec:new s.GlslLibRoutine(o,["coordinates.coordsToOffset"])}}valueFrom(){const e={};return this.context.programInfo.inputNames.forEach((t,n)=>{const r=this.context.inputTextureLayouts[n],a=(r.unpackedShape.length>0?r.unpackedShape:r.shape).length;let i=`_${t}`;e[i]=new s.GlslLibRoutine(this.getValueFromSingle(t,a,r.width,r.height,!1),[`shapeUtils.indicesToOffset${i}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),i+="_T",e[i]=new s.GlslLibRoutine(this.getValueFromSingle(t,a,r.width,r.height,!0),[`shapeUtils.indicesToOffset${i}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),e}getValueFromSingle(e,t,n,r,s){let i=`_${e}`;return s&&(i+="_T"),`\n        float ${i}(int m[${t}]) {\n          int offset = indicesToOffset${i}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\n          float value = getColorAsFloat(${(0,a.getGlsl)(this.context.glContext.version).texture2D}(${e}, coords));\n          return value;\n        }\n        `}getPackedValueFrom(e,t,n,r,s){let i=`_${e}_Pack`;return s&&(i+="_T"),`\n        vec4 ${i}(int m[${t}]) {\n          int offset = indicesToOffset_${e}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\n          return ${(0,a.getGlsl)(this.context.glContext.version).texture2D}(${e}, coords);\n        }\n        `}}t.CoordsGlslLib=u},8520:(e,t)=>{"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),t.TopologicalSortGlslRoutines=t.GlslLibRoutineNode=t.GlslLibRoutine=t.GlslLib=t.GlslContext=t.FunctionType=void 0,(n=t.FunctionType||(t.FunctionType={}))[n.ValueBased=0]="ValueBased",n[n.Positional=1]="Positional",t.GlslContext=class{constructor(e,t,n,r){this.glContext=e,this.programInfo=t,this.inputTextureLayouts=n,this.outputTextureLayout=r}},t.GlslLib=class{constructor(e){this.context=e}},t.GlslLibRoutine=class{constructor(e,t){this.routineBody=e,this.dependencies=t}},t.GlslLibRoutineNode=class{constructor(e,t,n){this.name=e,this.dependencies=n||[],t&&(this.routineBody=t)}addDependency(e){e&&this.dependencies.push(e)}},t.TopologicalSortGlslRoutines=class{static returnOrderedNodes(e){if(!e||0===e.length)return[];if(1===e.length)return e;const t=new Set,n=new Set,r=new Array;return this.createOrderedNodes(e,t,n,r),r}static createOrderedNodes(e,t,n,r){for(let s=0;s<e.length;++s)this.dfsTraverse(e[s],t,n,r)}static dfsTraverse(e,t,n,r){if(!e||n.has(e.name))return;if(t.has(e.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");t.add(e.name);const s=e.dependencies;if(s&&s.length>0)for(let e=0;e<s.length;++e)this.dfsTraverse(s[e],t,n,r);r.push(e),n.add(e.name),t.delete(e.name)}}},7341:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.EncodingGlslLib=void 0;const r=n(8520);class s extends r.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new r.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ")}}decodeFloat32(){return{decode:new r.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ")}}encodeUint8(){const e=s.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new r.GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${e}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)}}decodeUint8(){const e=s.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new r.GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${e}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)}}static isLittleEndian(){const e=new ArrayBuffer(4),t=new Uint32Array(e),n=new Uint8Array(e);if(t[0]=3735928559,239===n[0])return!0;if(222===n[0])return!1;throw new Error("unknown endianness")}}t.EncodingGlslLib=s},9894:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FragColorGlslLib=void 0;const r=n(8520),s=n(5060);class a extends r.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const e=(0,s.getGlsl)(this.context.glContext.version);return{setFragColor:new r.GlslLibRoutine(`\n        void setFragColor(float value) {\n            ${e.output} = encode(value);\n        }\n        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new r.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ",["encoding.decode"])}}}t.FragColorGlslLib=a},2848:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.replaceInlines=void 0;const n=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;t.replaceInlines=function(e){const t={};let r;for(;null!==(r=n.exec(e));){const e=r[3].split(",").map(e=>{const t=e.trim().split(" ");return t&&2===t.length?{type:t[0],name:t[1]}:null}).filter(e=>null!==e);t[r[2]]={params:e,body:r[4]}}for(const n in t){const s="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",n),a=new RegExp(s,"gm");for(;null!==(r=a.exec(e));){const s=r[1],a=r[2],i=r[3].split(","),o=s?`${s} ${a};`:"";let u=t[n].body,l="";t[n].params.forEach((e,t)=>{e&&(l+=`${e.type} ${e.name} = ${i[t]};\n`)}),u=`${l}\n ${u}`,u=u.replace("return",`${a} = `);const c=`\n      ${o}\n      {\n        ${u}\n      }\n      `;e=e.replace(r[0],c)}}return e.replace(n,"")}},8879:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GlslPreprocessor=void 0;const r=n(8520),s=n(2848),a=n(5483),i=n(5060);t.GlslPreprocessor=class{constructor(e,t,n,s){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new r.GlslContext(e,t,n,s),Object.keys(a.glslRegistry).forEach(e=>{const t=new a.glslRegistry[e](this.context);this.libs[e]=t});const i=this.glslLibRoutineDependencyGraph;for(const e in this.libs){const t=this.libs[e].getFunctions();for(const n in t){const s=e+"."+n;let a;i[s]?(a=i[s],a.routineBody=t[n].routineBody):(a=new r.GlslLibRoutineNode(s,t[n].routineBody),i[s]=a);const o=t[n].dependencies;if(o)for(let e=0;e<o.length;++e)if(i[o[e]])a.addDependency(i[o[e]]);else{const t=new r.GlslLibRoutineNode(o[e]);i[o[e]]=t,a.addDependency(t)}}}}preprocess(){const e=this.context.programInfo;let t=e.shaderSource;return this.context.programInfo.hasMain||(t=`${t}\n      ${(0,i.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),t=(0,s.replaceInlines)(t),`${(0,i.getFragShaderPreamble)(this.context.glContext.version)}\n    ${this.getUniforms(e.inputNames,e.variables)}\n    ${this.getImports(t)}\n    ${t}`}getImports(e){const t=this.selectGlslLibRoutinesToBeIncluded(e);if(0===t.length)return"";let n="";for(let e=0;e<t.length;++e){if(!t[e].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${t[e].name}`);n+=t[e].routineBody+"\n"}return n}selectGlslLibRoutinesToBeIncluded(e){const t=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(n=>{const r=n.split(".")[1];-1!==e.indexOf(r)&&t.push(this.glslLibRoutineDependencyGraph[n])}),r.TopologicalSortGlslRoutines.returnOrderedNodes(t)}getUniforms(e,t){const n=[];if(e)for(const t of e)n.push(`uniform sampler2D ${t};`);if(t)for(const e of t)n.push(`uniform ${e.type} ${e.name}${e.arrayLength?`[${e.arrayLength}]`:""};`);return n.join("\n")}}},5483:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.glslRegistry=void 0;const r=n(5107),s=n(7341),a=n(9894),i=n(2655),o=n(3891);t.glslRegistry={encoding:s.EncodingGlslLib,fragcolor:a.FragColorGlslLib,vec:o.VecGlslLib,shapeUtils:i.ShapeUtilsGlslLib,coordinates:r.CoordsGlslLib}},2655:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ShapeUtilsGlslLib=void 0;const r=n(8520);class s extends r.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const e=this.context.outputTextureLayout.shape.length,t={};return this.context.programInfo.inputNames.forEach((n,s)=>{const a=this.context.inputTextureLayouts[s].unpackedShape;if(a.length<=e){const s=a.length,i=e-s,o=`bcastIndices_${n}`;let u="";for(let e=0;e<s;++e)u+=`\n          realIndices[${e}] = int( mod(float(bcastedIndices[${i+e}]), ${a[e]}.0) );\n          `;const l=`\n        void ${o} (int bcastedIndices[${e}], out int realIndices[${s}]) {\n          ${u}\n        }\n        `;t[o]=new r.GlslLibRoutine(l)}}),t}bcastMatmulIndex(){const e=this.context.outputTextureLayout.shape.length,t={};return this.context.programInfo.inputNames.forEach((n,s)=>{const a=this.context.inputTextureLayouts[s].shape;if(!(a.length<2||a.length>e)){const s=a.length,i=e-s,o=`bcastMatmulIndices_${n}`;let u="";for(let e=0;e<s-2;++e)u+=`\n          realIndices[${e}] = int( mod(float(bcastedIndices[${i+e}]), ${a[e]}.0) );\n          `;const l=`\n        void ${o}(int bcastedIndices[${e}], out int realIndices[${s}]) {\n          ${u}\n          realIndices[${s-1}] = bcastedIndices[${e-1}];\n          realIndices[${s-2}] = bcastedIndices[${e-2}];\n        }\n        `;t[o]=new r.GlslLibRoutine(l)}}),t}indicesToOffset(){const e={};return this.context.programInfo.inputNames.forEach((t,n)=>{const a=this.context.inputTextureLayouts[n].shape,i=this.context.inputTextureLayouts[n].strides,o=a.length;let u=`indicesToOffset_${t}`;e[u]=new r.GlslLibRoutine(s.indexToOffsetSingle(u,o,i)),u=`indicesToOffset_${t}_T`,e[u]=new r.GlslLibRoutine(s.indexToOffsetSingle(u,o,i.slice().reverse()))}),e}static indexToOffsetSingle(e,t,n){let r="";for(let e=t-1;e>=0;--e)r+=`\n        offset += indices[${e}] * ${n[e]};\n        `;return`\n      int ${e}(int indices[${t}]) {\n        int offset = 0;\n        ${r}\n        return offset;\n      }\n      `}offsetToIndices(){const e={};return this.context.programInfo.inputNames.forEach((t,n)=>{const a=this.context.inputTextureLayouts[n].shape,i=this.context.inputTextureLayouts[n].strides,o=a.length;let u=`offsetToIndices_${t}`;e[u]=new r.GlslLibRoutine(s.offsetToIndicesSingle(u,o,i)),u=`offsetToIndices_${t}_T`,e[u]=new r.GlslLibRoutine(s.offsetToIndicesSingle(u,o,i.slice().reverse()))}),e}static offsetToIndicesSingle(e,t,n){const r=[];for(let e=0;e<t-1;++e)r.push(`\n      indices[${e}] = offset / ${n[e]};`),r.push(`\n        offset -= indices[${e}] * ${n[e]};`);return r.push(`\n      indices[${t-1}] = offset;`),`\n      void ${e}(int offset, out int indices[${t}]) {\n        ${r.join("")}\n      }\n      `}incrementIndices(){const e={};return this.context.programInfo.inputNames.forEach((t,n)=>{const s=this.context.inputTextureLayouts[n].shape,a=s.length,i=`incrementIndices_${t}`;let o="";for(let e=0;e<a;++e)o+=`\n        shape[${e}] = ${s[e]};`;const u=`\n        void ${i}(int axis, out int indices[${a}]) {\n          int shape[${a}];\n          ${o};\n          for(int i = ${a} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;e[i]=new r.GlslLibRoutine(u)}),e}}t.ShapeUtilsGlslLib=s},5060:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getDefaultFragShaderMain=t.getFragShaderPreamble=t.getVertexShaderSource=t.getGlsl=void 0;const n={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},r={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function s(e){return 1===e?n:r}t.getGlsl=s,t.getVertexShaderSource=function(e){const t=s(e);return`${t.version}\n      precision highp float;\n      ${t.attribute} vec3 position;\n      ${t.attribute} vec2 textureCoord;\n\n      ${t.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`},t.getFragShaderPreamble=function(e){const t=s(e);return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFrag} vec2 TexCoords;\n    ${t.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `},t.getDefaultFragShaderMain=function(e,t){return`\n  void main() {\n    int indices[${t}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${s(e).output} = result;\n  }\n  `}},3891:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.VecGlslLib=void 0;const r=n(8520);class s extends r.GlslLib{constructor(e){super(e)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const e=this.context.outputTextureLayout.shape.length,t={add:"+=",sub:"-=",mul:"*=",div:"/="},n={};for(const s in t){const a=`${s}Vec`;let i="";for(let n=0;n<e;++n)i+=`\n          dest[${n}] ${t[s]} src[${n}];\n          `;const o=`\n        void ${a}(int src[${e}], out int dest[${e}]) {\n          ${i}\n        }\n        `;n[a]=new r.GlslLibRoutine(o)}return n}copyVec(){const e=this.context.outputTextureLayout.shape.length;let t="";for(let n=0;n<e;++n)t+=`\n        dest[${n}] = src[${n}];\n        `;const n=`\n      void copyVec(int src[${e}], out int dest[${e}]) {\n        ${t}\n      }\n      `;return{copyVec:new r.GlslLibRoutine(n)}}setVecItem(){const e=this.context.outputTextureLayout.shape.length;let t=`\n        if(index < 0)\n            index =${e} + index;\n        if (index == 0)\n            m[0] = value;\n        `;for(let n=1;n<e-1;++n)t+=`\n        else if (index == ${n})\n            m[${n}] = value;\n            `;t+=`\n        else\n            m[${e-1}] = value;\n        `;const n=`\n      void setVecItem(out int m[${e}], int index, int value) {\n        ${t}\n      }\n        `;return{setVecItem:new r.GlslLibRoutine(n)}}getVecItem(){const e=this.context.outputTextureLayout.shape.length;let t=`\n        if(index < 0)\n            index = ${e} + index;\n        if (index == 0)\n            return m[0];\n      `;for(let n=1;n<e-1;++n)t+=`\n        else if (index == ${n})\n            return m[${n}];\n      `;t+=`\n        else\n            return m[${e-1}];\n        `;const n=`\n      int getVecItem(int m[${e}], int index) {\n        ${t}\n      }\n    `;return{getVecItem:new r.GlslLibRoutine(n)}}}t.VecGlslLib=s},8316:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLInferenceHandler=void 0;const r=n(6231),s=n(9162),a=n(2517),i=n(2403),o=n(7019),u=n(8710),l=n(5611),c=n(4057),h=n(2039);t.WebGLInferenceHandler=class{constructor(e){this.session=e,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,t){return(0,c.calculateTextureWidthAndHeight)(this.session.layoutStrategy,e,t)}executeProgram(e,t){if(t.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");const n=[];for(let r=0;r<e.inputNames.length;++r)n[r]=this.getOrCreateTextureData(t[r],e.inputTypes[r]);const r=((e,t)=>{const n=t.map(e=>`${e.unpackedShape.join(",")};${e.width}x${e.height}`).join("_");let r=e.name;return e.cacheHint&&(r+="["+e.cacheHint+"]"),r+=":"+n,r})(e,n);let s=this.session.programManager.getArtifact(r);const a=s?s.programInfo:"function"==typeof e.get?e.get():e,i=(0,c.createTextureLayoutFromTextureType)(this.session.layoutStrategy,a.output.dims,a.output.textureType),o=this.createTextureData(i,a.output.type);return s||(s=this.session.programManager.build(a,n,o),this.session.programManager.setArtifact(r,s)),this.runProgram(s,n,o),o}run(e,t){return this.executeProgram(e,t).tensor}runProgram(e,t,n){for(let n=0;n<t.length;++n)if(!!t[n].isPacked!=(e.programInfo.inputTypes[n]===h.TextureType.packed))throw new Error(`input[${n}] property packed inconsistent`);if(!!n.isPacked!=(e.programInfo.output.textureType===h.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(e,t,n)}getOrCreateTextureData(e,t){let n=this.getTextureData(e.dataId,t===h.TextureType.packed);if(!n&&(n=this.getTextureData(e.dataId,t!==h.TextureType.packed),n))return t===h.TextureType.packed?this.pack(n):this.unpack(n);if(!n){const r=(0,c.createTextureLayoutFromTextureType)(this.session.layoutStrategy,e.dims,t);if(t===h.TextureType.packedLastDimension){const n=1,r=4,s=e.dims;if(4===s.length){const a=[s[0],Math.ceil(s[1]*s[2]*s[3]/r)],i=(0,c.createTextureLayoutFromTextureType)(this.session.layoutStrategy,a,t);let o=e.numberData;if(s[1]*s[2]*s[3]%r!=0){const t=s[0],a=s[1]*s[2]*s[3],i=Math.ceil(a*n/r)*r;o=new Float32Array(t*i);for(let r=0;r<t;++r){const t=r*a,s=r*i+r%n*a;o.set(e.numberData.subarray(t,t+a),s)}}return this.createTextureData(i,e.type,o,e,1)}}if(t===h.TextureType.packed){const t=(0,c.createTextureLayoutFromShape)(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),r=this.createTextureData(t,e.type,e.numberData,e,1);n=this.pack(r)}else n=this.createTextureData(r,e.type,e.numberData,e,1)}return n}createTextureDataFromLayoutBindTensor(e,t,n,r){return this.createTextureData(e,t,n,r,1)}createTextureData(e,t,n,s,a){r.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);const i=this.session.textureManager.createTextureFromLayout(t,e,n,a);return this.createTextureDataFromTexture(e,t,i,s)}reshapeUnpacked(e,t){const n=this.getOrCreateTextureData(e,h.TextureType.unpacked),r={channels:n.channels,height:n.height,width:n.width,shape:0!==t.length?t:[1],strides:a.ShapeUtil.computeStrides(t),unpackedShape:t};return this.createTextureDataFromTexture(r,e.type,n.texture).tensor}reshapePacked(e,t){const n=this.getOrCreateTextureData(e,h.TextureType.packed);if((0,o.isReshapeCheap)(e.dims,t)){const r={channels:n.channels,height:n.height,width:n.width,shape:0!==t.length?t:[1],strides:a.ShapeUtil.computeStrides(t),unpackedShape:t,isPacked:!0};return this.createTextureDataFromTexture(r,e.type,n.texture).tensor}const r=(0,o.processDims3D)(e.dims),s=(0,o.processDims3D)(t),i=this.reshapePacked(e,r),u=this.run((0,o.createPackedReshape3DProgramInfoLoader)(this,i,s),[i]);return this.reshapePacked(u,t)}cast(e,t){const n=this.getOrCreateTextureData(e,h.TextureType.unpacked);return this.createTextureDataFromTexture(n,t,n.texture).tensor}createTextureDataFromTexture(e,t,n,r,a){const i=Object.assign(Object.assign({},e),{tensor:r||new s.Tensor(e.unpackedShape,t,e=>this.readTexture(i),async e=>this.readTextureAsync(i),void 0,a),texture:n});return this.setTextureData(i.tensor.dataId,i,e.isPacked),i}getTextureData(e,t=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,t):t?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,t,n=!1){this.session.isInitializer(e)?this.session.setTextureData(e,t,n):(n?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,t)}isTextureLayoutCached(e,t=!1){return!!this.getTextureData(e.dataId,t)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,u.encodeAsUint8)(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,u.encodeAsUint8)(this,e))}pack(e){return this.executeProgram((0,i.createPackProgramInfoLoader)(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram((0,l.createUnpackProgramInfoLoader)(this,e.tensor),[e.tensor])}}},1640:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var s=Object.getOwnPropertyDescriptor(t,n);s&&!("get"in s?!t.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,s)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return s(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.WEBGL_OP_RESOLVE_RULES=void 0;const i=n(2898),o=a(n(7839)),u=n(4196),l=n(2069),c=n(8138),h=n(9663),d=n(5193),p=n(7992),f=n(1253),m=n(4776),g=n(6572),b=n(3346),y=n(5623),x=n(2870),w=n(2143),v=n(4939),_=n(718),k=n(2268),T=n(8117),S=n(2278),I=n(5524),N=n(5975),E=n(3933),$=n(6558),A=n(5723),C=n(3738),O=a(n(4909)),R=n(8428),D=n(9793);t.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",O.abs],["Acos","","7+",O.acos],["Add","","7+",o.add],["And","","7+",o.and],["Asin","","7+",O.asin],["Atan","","7+",O.atan],["AveragePool","","7+",w.averagePool,w.parseAveragePoolAttributes],["BatchNormalization","","7+",i.batchNormalization,i.parseBatchNormalizationAttributes],["Cast","","6+",u.cast,u.parseCastAttributes],["Ceil","","6+",O.ceil],["Clip","","6-10",O.clip,O.parseClipAttributes],["Clip","","11+",O.clipV11],["Concat","","4+",l.concat,l.parseConcatAttributes],["Conv","","1+",c.conv,c.parseConvAttributes],["ConvTranspose","","1+",h.convTranspose,h.parseConvTransposeAttributes],["Cos","","7+",O.cos],["Div","","7+",o.div],["Dropout","","7+",O.identity],["DepthToSpace","","1+",d.depthToSpace,d.parseDepthToSpaceAttributes],["Equal","","7+",o.equal],["Elu","","6+",O.elu,O.parseEluAttributes],["Exp","","6+",O.exp],["Flatten","","1+",p.flatten,p.parseFlattenAttributes],["Floor","","6+",O.floor],["FusedConv","com.microsoft","1+",c.conv,c.parseConvAttributes],["Gather","","1+",f.gather,f.parseGatherAttributes],["Gemm","","7-10",m.gemm,m.parseGemmAttributesV7],["Gemm","","11+",m.gemm,m.parseGemmAttributesV11],["GlobalAveragePool","","1+",w.globalAveragePool,w.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",w.globalMaxPool],["Greater","","7+",o.greater],["Identity","","1+",O.identity],["ImageScaler","","1+",g.imageScaler,g.parseImageScalerAttributes],["InstanceNormalization","","6+",b.instanceNormalization,b.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",O.leakyRelu,O.parseLeakyReluAttributes],["Less","","7+",o.less],["Log","","6+",O.log],["MatMul","","1+",y.matMul,y.parseMatMulAttributes],["MaxPool","","1+",w.maxPool,w.parseMaxPoolAttributes],["Mul","","7+",o.mul],["Neg","","6+",O.neg],["Not","","1+",O.not],["Or","","7+",o.or],["Pad","","2-10",x.padV2,x.parsePadAttributesV2],["Pad","","11+",x.padV11,x.parsePadAttributesV11],["Pow","","7+",o.pow],["PRelu","","7+",o.pRelu],["ReduceLogSum","","1+",v.reduceLogSum,v.parseReduceAttributes],["ReduceMax","","1+",v.reduceMax,v.parseReduceAttributes],["ReduceMean","","1+",v.reduceMean,v.parseReduceAttributes],["ReduceMin","","1+",v.reduceMin,v.parseReduceAttributes],["ReduceProd","","1+",v.reduceProd,v.parseReduceAttributes],["ReduceSum","","1-12",v.reduceSum,v.parseReduceAttributes],["ReduceSumSquare","","1+",v.reduceLogSumSquare,v.parseReduceAttributes],["Relu","","6+",O.relu],["Reshape","","5+",_.reshape],["Resize","","10",k.resize,k.parseResizeAttributesV10],["Resize","","11+",k.resize,k.parseResizeAttributesV11],["Shape","","1+",T.shape],["Sigmoid","","6+",O.sigmoid],["Sin","","7+",O.sin],["Slice","","10+",S.sliceV10],["Slice","","1-9",S.slice,S.parseSliceAttributes],["Softmax","","1-12",I.softmax,I.parseSoftmaxAttributes],["Softmax","","13+",I.softmaxV13,I.parseSoftmaxAttributesV13],["Split","","2-12",N.split,N.parseSplitAttributes],["Sqrt","","6+",O.sqrt],["Squeeze","","1-12",E.squeeze,E.parseSqueezeAttributes],["Squeeze","","13+",E.squeezeV13],["Sub","","7+",o.sub],["Sum","","6+",$.sum],["Tan","","7+",O.tan],["Tanh","","6+",O.tanh],["Tile","","6+",A.tile],["Transpose","","1+",C.transpose,C.parseTransposeAttributes],["Upsample","","7-8",D.upsample,D.parseUpsampleAttributesV7],["Upsample","","9",D.upsample,D.parseUpsampleAttributesV9],["Unsqueeze","","1-12",R.unsqueeze,R.parseUnsqueezeAttributes],["Unsqueeze","","13+",R.unsqueezeV13],["Xor","","7+",o.xor]]},2898:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseBatchNormalizationAttributes=t.batchNormalization=void 0;const r=n(246),s=n(5060),a=n(2039),i={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]};t.batchNormalization=(e,t,n)=>(u(t),[e.run(Object.assign(Object.assign({},i),{cacheHint:n.cacheKey,get:()=>o(e,t,n)}),t)]),t.parseBatchNormalizationAttributes=e=>{const t=e.attributes.getFloat("epsilon",1e-5),n=e.attributes.getFloat("momentum",.9),s=e.attributes.getInt("spatial",1);return(0,r.createAttributeWithCacheKey)({epsilon:t,momentum:n,spatial:s})};const o=(e,t,n)=>{const r=(0,s.getGlsl)(e.session.backend.glContext.version),o=t[0].dims.length,[u,l]=e.calculateTextureWidthAndHeight(t[1].dims,a.TextureType.unpacked),c=`\n  float process(int[${o}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${u}, ${l});\n    float scale = getColorAsFloat(${r.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${r.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${r.texture2D}(Variance, position));\n    float b = getColorAsFloat(${r.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;\n  }`;return Object.assign(Object.assign({},i),{output:{dims:t[0].dims,type:t[0].type,textureType:a.TextureType.unpacked},shaderSource:c})},u=e=>{if(!e||5!==e.length)throw new Error("BatchNormalization requires 5 inputs.");const t=e[0],n=e[1],r=e[2],s=e[3],a=e[4];if(t.dims.length<3||1!==n.dims.length||1!==r.dims.length||1!==s.dims.length||1!==a.dims.length)throw new Error("invalid input shape.");if(n.dims[0]!==t.dims[1]||r.dims[0]!==t.dims[1]||s.dims[0]!==t.dims[1]||a.dims[0]!==t.dims[1])throw new Error("invalid input shape.");if("float32"!==t.type&&"float64"!==t.type||"float32"!==n.type&&"float64"!==n.type||"float32"!==r.type&&"float64"!==r.type||"float32"!==s.type&&"float64"!==s.type||"float32"!==a.type&&"float64"!==a.type)throw new Error("invalid input tensor types.")}},7839:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.xor=t.sub=t.pRelu=t.pow=t.or=t.mul=t.less=t.greater=t.equal=t.div=t.and=t.add=t.glslPRelu=t.glslPow=t.glslXor=t.glslOr=t.glslAnd=t.glslLess=t.glslGreater=t.glslEqual=t.glslSub=t.glslMul=t.glslDiv=t.glslAdd=void 0;const r=n(2517),s=n(8520),a=n(5060),i=n(2039);function o(){const e="add_";return{body:`\n  float ${e}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function u(){const e="div_";return{body:`\n  float ${e}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function l(){const e="mul_";return{body:`\n  float ${e}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function c(){const e="sub_";return{body:`\n  float ${e}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function h(){const e="equal_";return{body:`\n  float ${e}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function d(){const e="greater_";return{body:`\n  float ${e}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function p(){const e="less_";return{body:`\n  float ${e}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function f(){const e="and_";return{body:`\n  float ${e}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function m(){const e="or_";return{body:`\n  float ${e}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function g(){const e="xor_";return{body:`\n  float ${e}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}function b(){return function(e){const t=`${e}_`;return{body:`\n  float ${t}(float a, float b) {\n    return ${e}(a, b);\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return ${e}(v1, v2);\n  }\n  `,name:t,type:s.FunctionType.ValueBased}}("pow")}function y(){const e="prelu_";return{body:`\n  float ${e}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `,name:e,type:s.FunctionType.ValueBased}}t.glslAdd=o,t.glslDiv=u,t.glslMul=l,t.glslSub=c,t.glslEqual=h,t.glslGreater=d,t.glslLess=p,t.glslAnd=f,t.glslOr=m,t.glslXor=g,t.glslPow=b,t.glslPRelu=y;const x=(e,t,n,r=t[0].type,s)=>{const a=e.session.pack?i.TextureType.packed:i.TextureType.unpacked;return{name:n.name,inputNames:["A","B"],inputTypes:[a,a],cacheHint:s,get:()=>w(e,t,n,r)}},w=(e,t,n,s=t[0].type)=>{const o=e.session.pack?i.TextureType.packed:i.TextureType.unpacked,u=!r.ShapeUtil.areEqual(t[0].dims,t[1].dims);let l=t[0].dims;const c=e.session.pack;if(u){const i=r.BroadcastUtil.calcShape(t[0].dims,t[1].dims,!1);if(!i)throw new Error("Can't perform binary op on the given tensors");l=i;const u=l.length,h=0!==t[0].dims.length?t[0].dims.length:1,d=0!==t[1].dims.length?t[1].dims.length:1,p=0!==t[0].dims.length?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",f=0!==t[1].dims.length?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",m=(0,a.getGlsl)(e.session.backend.glContext.version),g=c?`\n      ${n.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${n.name}(a, b);\n        ${m.output} = result;\n      }`:`\n      ${n.body}\n      float process(int indices[${u}]) {\n        int aindices[${h}];\n        int bindices[${d}];\n        ${p}\n        ${f}\n        return ${n.name}(_A(aindices), _B(bindices));\n      }`;return{name:n.name,inputNames:["A","B"],inputTypes:[o,o],output:{dims:l,type:s,textureType:o},shaderSource:g,hasMain:c}}const h=(0,a.getGlsl)(e.session.backend.glContext.version),d=`\n    ${n.body}\n    void main() {\n      vec4 v1 = ${h.texture2D}(A, TexCoords);\n      vec4 v2 = ${h.texture2D}(B, TexCoords);\n      vec4 result = ${n.name}(v1, v2);\n      ${h.output} = result;\n    }\n    `;return{name:n.name,inputNames:["A","B"],inputTypes:[o,o],output:{dims:t[0].dims,type:s,textureType:o},shaderSource:d,hasMain:!0}};t.add=(e,t)=>[e.run(x(e,t,o()),t)],t.and=(e,t)=>[e.run(x(e,t,f(),"bool"),t)],t.div=(e,t)=>[e.run(x(e,t,u()),t)],t.equal=(e,t)=>[e.run(x(e,t,h(),"bool"),t)],t.greater=(e,t)=>[e.run(x(e,t,d(),"bool"),t)],t.less=(e,t)=>[e.run(x(e,t,p(),"bool"),t)],t.mul=(e,t)=>[e.run(x(e,t,l()),t)],t.or=(e,t)=>[e.run(x(e,t,m(),"bool"),t)],t.pow=(e,t)=>[e.run(x(e,t,b()),t)],t.pRelu=(e,t)=>[e.run(x(e,t,y()),t)],t.sub=(e,t)=>[e.run(x(e,t,c()),t)],t.xor=(e,t)=>[e.run(x(e,t,g(),"bool"),t)]},4196:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseCastAttributes=t.cast=void 0;const r=n(2517);t.cast=(e,t,n)=>(s(t),[e.cast(t[0],n)]),t.parseCastAttributes=e=>r.ProtoUtil.tensorDataTypeFromProto(e.attributes.getInt("to"));const s=e=>{if(!e||1!==e.length)throw new Error("Cast requires 1 input.");if("string"===e[0].type)throw new Error("Invalid input type.")}},1163:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedConcatProgramInfoLoader=void 0;const r=n(5060),s=n(2039),a=n(9390),i=n(2827);t.createPackedConcatProgramInfoLoader=(e,t,n)=>{const u=(l=t.length,c=n.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:l},(e,t)=>`X${t}`),inputTypes:Array(l).fill(s.TextureType.packed),cacheHint:c});var l,c;return Object.assign(Object.assign({},u),{get:()=>((e,t,n,u)=>{const l=n[0].dims.slice();if(u>=l.length||u<-1*l.length)throw new Error("axis specified for concat doesn't match input dimensionality");u<0&&(u=l.length+u);const c=l.slice(0);for(let e=1;e<n.length;e++){const t=n[e].dims.slice();for(let e=0;e<l.length;e++)if(e===u)c[u]+=t[e];else if(l[e]!==t[e])throw new Error("non concat dimensions must match")}const h=c.length,d=(0,i.getChannels)("coords",h),p=(0,a.getCoordsDataType)(h),f=(0,i.unpackFromChannel)(),m=n.map(e=>e.dims),g=(0,a.getGlChannels)(h),b=new Array(m.length-1);b[0]=m[0][u];for(let e=1;e<b.length;e++)b[e]=b[e-1]+m[e][u];const y=g[u],x=g.slice(-2),w=g.join();let v=`if (${y} < ${b[0]}) {\n        return getChannel(\n            getX0(${w}), vec2(${x.join()}));\n        }`;for(let e=1;e<b.length;e++){const t=b[e-1];v+=`\n            if (${y} < ${b[e]}  && ${y} >= ${b[e-1]}) {\n              return getChannel(\n                getX${e}(${o(g,y,t)}),\n                vec2(${o(x,y,t)}));\n            }`}const _=b.length,k=b[b.length-1];v+=`\n            return getChannel(\n              getX${_}(${o(g,y,k)}),\n              vec2(${o(x,y,k)}));`;const T=(0,r.getGlsl)(e.session.backend.glContext.version),S=`\n          ${f}\n          float getValue(${g.map(e=>"int "+e)}) {\n            ${v}\n          }\n\n          void main() {\n            ${p} coords = getOutputCoords();\n            int lastDim = coords.${g[h-1]};\n            coords.${g[h-1]} = coords.${g[h-2]};\n            coords.${g[h-2]} = lastDim;\n\n            vec4 result = vec4(getValue(${d}), 0., 0., 0.);\n\n            ${d[h-1]} = ${d[h-1]} + 1;\n            if (${d[h-1]} < ${c[h-1]}) {\n              result.g = getValue(${d});\n            }\n\n            ${d[h-2]} = ${d[h-2]} + 1;\n            if (${d[h-2]} < ${c[h-2]}) {\n              result.a = getValue(${d});\n            }\n\n            ${d[h-1]} = ${d[h-1]} - 1;\n            if (${d[h-2]} < ${c[h-2]} &&\n                ${d[h-1]} < ${c[h-1]}) {\n              result.b = getValue(${d});\n            }\n            ${T.output} = result;\n          }\n        `;return Object.assign(Object.assign({},t),{output:{dims:c,type:n[0].type,textureType:s.TextureType.packed},shaderSource:S,hasMain:!0})})(e,u,t,n.axis)})};const o=(e,t,n)=>{const r=e.indexOf(t);return e.map((e,t)=>t===r?`${e} - ${n}`:e).join()}},2069:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseConcatAttributes=t.concat=void 0;const r=n(246),s=n(2039),a=n(1163);t.concat=(e,t,n)=>(h(t),e.session.pack&&t[0].dims.length>1?[e.run((0,a.createPackedConcatProgramInfoLoader)(e,t,n),t)]:[e.run(i(e,t,n),t)]);const i=(e,t,n)=>{const r=(a=t.length,i=n.cacheKey,{name:"Concat",inputNames:Array.from({length:a},(e,t)=>`X${t}`),inputTypes:Array(a).fill(s.TextureType.unpacked),cacheHint:i});var a,i;return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const a=n[0].dims.slice();if(r>=a.length||r<-1*a.length)throw new Error("axis specified for concat doesn't match input dimensionality");r<0&&(r=a.length+r);const i=a.slice(0);for(let e=1;e<n.length;e++){const t=n[e].dims.slice();for(let e=0;e<a.length;e++)if(e===r)i[r]+=t[e];else if(a[e]!==t[e])throw new Error("non concat dimensions must match")}const h=i.length,d=new Array(n.length);let p=0;for(let e=0;e<d.length;++e)p+=n[e].dims[r],d[e]=p;let f="";f=n.length<5?o(d):u(d);const m=`\n        ${l(n.length,h)}\n        ${c(d)}\n        ${f}\n        float process(int indices[${h}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${r}]);\n\n          if(textureIndex != 0) {\n            indices[${r}] = indices[${r}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;return Object.assign(Object.assign({},t),{output:{dims:i,type:n[0].type,textureType:s.TextureType.unpacked},shaderSource:m})})(0,r,t,n.axis)})},o=e=>`int getTextureWhereDataResides(int index) {\n      ${e.map((e,t)=>`if(index<${e}) {return ${t};}\n`).join("")}\n    }`,u=e=>o(e),l=(e,t)=>{const n=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${t}]) {`];for(let t=0;t<e;++t)0===t?n.push(`\tif (textureIndex == ${t}) { return _X${t}(indices); }`):t===e-1?n.push(`\telse { return _X${t}(indices); }`):n.push(`\telse if (textureIndex == ${t}) { return _X${t}(indices); }`);return n.push("\t}"),n.join("\n")},c=e=>{const t=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let n=0;n<e.length;++n)0===n?t.push(`\tif (index == ${n}) { return ${e[n]}; }`):n===e.length-1?t.push(`\telse { return ${e[n]}; }`):t.push(`\telse if (index == ${n}) { return ${e[n]}; }`);return t.push("\t}"),t.join("\n")};t.parseConcatAttributes=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis")});const h=e=>{if(!e||e.length<1)throw new Error("too few inputs");const t=e[0].type,n=e[0].dims.length;if("string"===t)throw new Error("string tensor is not supported yet");for(const r of e){if(r.type!==t)throw new Error("input tensors should be one type");if(r.dims.length!==n)throw new Error("input tensors should have the same shape")}}},4770:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createUnpackedGroupedConvProgramInfoLoader=void 0;const r=n(6231),s=n(5060),a=n(2039),i=n(8138),o=n(2823);t.createUnpackedGroupedConvProgramInfoLoader=(e,t,n)=>{const u=(l=t.length>2,c=n.cacheKey,{name:"GroupedConv",inputNames:l?["X","W","Bias"]:["X","W"],inputTypes:l?[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]:[a.TextureType.unpacked,a.TextureType.unpacked],cacheHint:c});var l,c;return Object.assign(Object.assign({},u),{get:()=>((e,t,n,u)=>{const l=t.length>2?"value += getBias(output_channel);":"",c=t[0].dims.slice(),h=t[1].dims.slice(),d=h[0]/u.group;r.Logger.verbose("GroupedConv",`autpPad:${u.autoPad}, dilations:${u.dilations}, group:${u.group}, kernelShape:${u.kernelShape}, pads:${u.pads}, strides:${u.strides}`);const p=(0,i.calculateOutputShape)(c,h,u.dilations,u.pads,u.strides),f=(0,s.getGlsl)(e.session.backend.glContext.version),{activationFunction:m,applyActivation:g}=(0,o.getActivationSnippet)(u),b=`\n  const ivec2 strides = ivec2(${u.strides[0]}, ${u.strides[1]});\n  const ivec2 pads = ivec2(${u.pads[0]}, ${u.pads[1]});\n  ${m}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${d};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${h[1]}; wInChannel++) {\n      int input_channel = group_id * ${h[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${h[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${u.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${c[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${h[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${u.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${c[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${l}\n    ${g}\n    ${f.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},n),{output:{dims:p,type:t[0].type,textureType:a.TextureType.unpacked},shaderSource:b,hasMain:!0})})(e,t,u,n)})}},1386:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.conv2DPacked=t.conv2DPackedPointwise=void 0;const r=n(8138),s=n(8555),a=n(708);t.conv2DPackedPointwise=(e,t,n)=>{const s=t[0].dims,i=t[1].dims,o=(0,r.calculateOutputShape)(s,i,n.dilations,n.pads,n.strides),u=e.reshapePacked(t[0],[s[1],s[2]*s[3]]),l=e.reshapePacked(t[1],[i[0],i[1]]),c=t.length>2?[l,u,t[2]]:[l,u],h=e.run((0,a.createPackedMatmulProgramInfoLoader)(e,c,n),c);return e.reshapePacked(h,o)},t.conv2DPacked=(e,t,n)=>{const i=t[0].dims,o=t[1].dims,u=(0,r.calculateOutputShape)(i,o,n.dilations,n.pads,n.strides),l=e.run((0,s.createPackedIm2ColProgramInfoLoader)(e,t[0],t[1],u,n),[t[0]]),c=e.reshapePacked(t[1],[o[0],o[1]*o[2]*o[3]]),h=3===t.length?[c,l,t[2]]:[c,l],d=e.run((0,a.createPackedMatmulProgramInfoLoader)(e,h,n),h);return e.reshapePacked(d,u)}},9663:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseConvTransposeAttributes=t.convTranspose=void 0;const r=n(246),s=n(5060),a=n(2039),i=n(2823),o=(e,t,n,r,s,a)=>(e-1)*t+n+(r-1)*s+1-a,u=(e,t,n,r,s)=>{const a=Math.floor(e/2);"SAME_UPPER"===t?(n[r]=a,n[s]=e-a):"SAME_LOWER"===t&&(n[r]=e-a,n[s]=a)};t.convTranspose=(e,t,n)=>(d(t,n),l(e,t,n));const l=(e,t,n)=>{const r=h(n,t);return[c(e,t,r)]},c=(e,t,n)=>e.run(((e,t,n)=>{const r=(o=t.length>2,u=n.cacheKey,{name:"ConvTranspose",inputNames:o?["X","W","B"]:["X","W"],inputTypes:o?[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]:[a.TextureType.unpacked,a.TextureType.unpacked],cacheHint:u});var o,u;return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const o=t.length>2?"getB(output_channel)":"0.0",u=t[0].dims,l=t[1].dims,c=l[1],h=l[0]/r.group,d=[t[0].dims[0],t[1].dims[1]*r.group,...r.outputShape],p=(0,s.getGlsl)(e.session.backend.glContext.version),{activationFunction:f,applyActivation:m}=(0,i.getActivationSnippet)(r),g=`\n  const ivec2 strides = ivec2(${r.strides[0]}, ${r.strides[1]});\n  const ivec2 pads = ivec2(${r.pads[0]}, ${r.pads[1]});\n  ${f}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${c};\n    int wOutChannel = output_channel - group_id * ${c};\n\n    float value = ${o};\n    for (int inChannelOffset = 0; inChannelOffset < ${h}; inChannelOffset++) {\n      int input_channel = group_id * ${h} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${l[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${l[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${r.dilations[0]}, wHOff * ${r.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${u[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${u[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${m}\n    ${p.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},n),{output:{dims:d,type:t[0].type,textureType:a.TextureType.unpacked},shaderSource:g,hasMain:!0})})(e,t,r,n)})})(e,t,n),t),h=(e,t)=>{const n=e.kernelShape.slice();if(0===e.kernelShape.length)for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e]);const r=e.pads.slice(),s=e.outputShape.slice();((e,t,n,r,s,a,i,l)=>{const c=e.length-2,h=0===l.length;for(let d=0;d<c;++d){const p=h?e[d+2]*a[d]:l[d],f=o(e[d+2],a[d],s[d],t[d],n[d],p);u(f,r,s,d,d+c),h&&l.push(a[d]*(e[d+2]-1)+i[d]+(t[d]-1)*n[d]+1-s[d]-s[d+c])}})(t[0].dims,n,e.dilations,e.autoPad,r,e.strides,e.outputPadding,s);const a=Object.assign({},e);return Object.assign(a,{kernelShape:n,pads:r,outputShape:s,cacheKey:e.cacheKey}),a};t.parseConvTransposeAttributes=e=>{const t=e.attributes,n=(0,i.parseInternalActivationAttributes)(t),s=t.getString("auto_pad","NOTSET"),a=t.getInts("dilations",[1,1]),o=t.getInt("group",1),u=t.getInts("kernel_shape",[]),l=t.getInts("output_padding",[0,0]),c=t.getInts("output_shape",[]),h=t.getInts("pads",[0,0,0,0]),d=t.getInts("strides",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:s,dilations:a,group:o,kernelShape:u,outputPadding:l,outputShape:c,pads:h,strides:d},n))};const d=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length||4!==e[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims[1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");const r=e[0].dims.length-2;if(t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(t.outputPadding.length!==r)throw new Error(`output_padding should be ${r}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape");if("float32"!==e[0].type||"float32"!==e[1].type)throw new Error("ConvTranspose input(X,W) should be float tensor");if(3===e.length&&"float32"!==e[2].type)throw new Error("ConvTranspose input(bias) should be float tensor")}},8138:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseConvAttributes=t.conv=t.calculateOutputShape=void 0;const r=n(246),s=n(2517),a=n(4770),i=n(1386),o=n(9828),u=n(2823),l=n(3248),c=n(5623);t.calculateOutputShape=(e,t,n,r,s)=>{const a=e[0],i=e.slice(2),o=i.length,u=t[0],l=t.slice(2).map((e,t)=>e+(e-1)*(n[t]-1)),c=i.map((e,t)=>e+r[t]+r[t+o]).map((e,t)=>Math.floor((e-l[t]+s[t])/s[t]));return[a,u].concat(...c)},t.conv=(e,t,n)=>(m(t,n),h(e,t,n));const h=(e,t,n)=>{const r=f(n,t),s=e.session.pack,o=1===r.kernelShape[0]&&1===r.kernelShape[1];return r.group>1?[e.run((0,a.createUnpackedGroupedConvProgramInfoLoader)(e,t,r),t)]:o&&s?[d(e,t,r)]:s&&4===t[0].dims.length&&1===t[0].dims[0]&&!o?[(0,i.conv2DPacked)(e,t,r)]:[p(e,t,r)]},d=(e,n,r)=>{const s=n[0].dims,a=n[1].dims,i=(0,t.calculateOutputShape)(s,a,r.dilations,r.pads,r.strides),o=e.reshapeUnpacked(n[0],[s[1],s[2]*s[3]]),u=e.reshapeUnpacked(n[1],[a[0],a[1]]),l=n.length>2?[u,o,n[2]]:[u,o],h=e.run((0,c.createMatmulProgramInfoLoader)(l,r),l);return e.reshapeUnpacked(h,i)},p=(e,n,r)=>{const s=n[0].dims,a=n[1].dims,i=(0,t.calculateOutputShape)(s,a,r.dilations,r.pads,r.strides),u=e.run((0,l.createIm2ColProgramInfoLoader)(e,n[0],n[1],i,r),[n[0]]),c=3===n.length?[u,n[1],n[2]]:[u,n[1]];return e.run((0,o.createDotProductProgramInfoLoader)(e,n,i,r),c)},f=(e,t)=>{const n=e.kernelShape.slice();if(0===e.kernelShape.length)for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e]);const r=e.pads.slice();s.PoolConvUtil.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,e.autoPad);const a=Object.assign({},e);return Object.assign(a,{kernelShape:n,pads:r,cacheKey:e.cacheKey}),a};t.parseConvAttributes=e=>{const t=e.attributes,n=(0,u.parseInternalActivationAttributes)(t),s=t.getString("auto_pad","NOTSET"),a=t.getInts("dilations",[1,1]),i=t.getInt("group",1),o=t.getInts("kernel_shape",[]),l=t.getInts("pads",[0,0,0,0]),c=t.getInts("strides",[1,1]);return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:s,dilations:a,group:i,kernelShape:o,pads:l,strides:c},n))};const m=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length||4!==e[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims[1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");const n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if("float32"!==e[0].type||"float32"!==e[1].type)throw new Error("Conv input(X,W) should be float tensor");if(3===e.length&&"float32"!==e[2].type)throw new Error("Conv input(bias) should be float tensor")}},5193:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseDepthToSpaceAttributes=t.depthToSpace=void 0;const r=n(3738);t.depthToSpace=(e,t,n)=>{s(t);const a=n.blocksize,i=a*a,o="DCR"===n.mode?[0,3,4,1,5,2]:[0,1,4,2,5,3],u="DCR"===n.mode?[t[0].dims[0],a,a,t[0].dims[1]/i,t[0].dims[2],t[0].dims[3]]:[t[0].dims[0],t[0].dims[1]/i,a,a,t[0].dims[2],t[0].dims[3]],l=e.reshapeUnpacked(t[0],u),c={perm:o,cacheKey:`${o}`},[h]=(0,r.transpose)(e,[l],c),d=[t[0].dims[0],t[0].dims[1]/i,t[0].dims[2]*a,t[0].dims[3]*a];return[e.reshapeUnpacked(h,d)]},t.parseDepthToSpaceAttributes=e=>{const t=e.attributes.getInt("blocksize");if(t<1)throw new Error(`blocksize must be >= 1, but got : ${t} for DepthToSpace`);const n=e.attributes.getString("mode","DCR");if("DCR"!==n&&"CRD"!==n)throw new Error(`unrecognized mode: ${n} for DepthToSpace`);return{mode:n,blocksize:t}};const s=e=>{if(1!==e.length)throw new Error(`DepthToSpace expect 1 inputs, but got ${e.length}`);if("string"===e[0].type||4!==e[0].dims.length)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},9828:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createDotProductProgramInfoLoader=void 0;const r=n(2517),s=n(5060),a=n(2039),i=n(2823),o=n(3248);t.createDotProductProgramInfoLoader=(e,t,n,u)=>{const l=((e,t)=>({name:"ConvDotProduct",inputNames:e?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:e?[a.TextureType.unpacked,a.TextureType.packedLastDimension,a.TextureType.unpacked]:[a.TextureType.unpacked,a.TextureType.packedLastDimension],cacheKey:t.activationCacheKey}))(t.length>2,u);return Object.assign(Object.assign({},l),{get:()=>((e,t,n,u,l)=>{const c=n[0].dims,h=n[1].dims,d=[h[0],Math.ceil(c[1]*h[2]*h[3]/4)],p=(0,o.calculateIm2ColDims)(c,h,u),[f,m]=e.calculateTextureWidthAndHeight(d,a.TextureType.packedLastDimension),g=r.ShapeUtil.computeStrides(p),[b,y]=e.calculateTextureWidthAndHeight(p,a.TextureType.packedLastDimension),x=u.length,w=n.length<3?"0.0":"_B(b)",v=Math.ceil(c[1]*h[2]*h[3]/4),{activationFunction:_,applyActivation:k}=(0,i.getActivationSnippet)(l),T=(0,s.getGlsl)(e.session.backend.glContext.version),S=`\n${_}\nfloat process(int indices[${x}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${g[0]} + im2col[1] * ${g[1]} + im2col[2] * ${g[2]};\n  int kernelOffset = indices[1] * ${d[1]};\n  float value = ${w};\n  for (int i = 0; i < ${v}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${b}, ${y});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${f}, ${m});\n    value += dot(${T.texture2D}(Im2Col, im2colCoords), ${T.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${k}\n  return value;\n}`;return Object.assign(Object.assign({},t),{output:{dims:u,type:n[0].type,textureType:a.TextureType.unpacked},shaderSource:S})})(e,l,t,n,u)})}},7992:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseFlattenAttributes=t.flatten=void 0;const r=n(2517);t.flatten=(e,t,n)=>{s(t,n);const a=r.ShapeUtil.flattenShape(t[0].dims,n);return[e.reshapeUnpacked(t[0],a)]},t.parseFlattenAttributes=e=>e.attributes.getInt("axis",1);const s=(e,t)=>{if(!e||1!==e.length)throw new Error("Flatten requires 1 input.");const n=e[0].dims.length;if(0===n)throw new Error("scalar tensor is not supported.");if(t<-n||t>n)throw new Error("Invalid axis");if("string"===e[0].type)throw new Error("string tensor is not supported.")}},2823:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseInternalActivationAttributes=t.getActivationSnippet=void 0;const r=n(2517),s=n(4909);t.getActivationSnippet=function(e){let t;switch(e.activation){case"Relu":t=(0,s.glslRelu)();break;case"Sigmoid":t=(0,s.glslSigmoid)();break;case"Clip":t=(0,s.glslClip)(e.clipMin,e.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const n=t.name;return{activationFunction:t.body,applyActivation:`value = ${n}_(value);`}},t.parseInternalActivationAttributes=e=>{const t=e.getString("activation","");if("Clip"===t){const[n,s]=e.getFloats("activation_params",[r.MIN_CLIP,r.MAX_CLIP]);return{activation:t,clipMax:s,clipMin:n,activationCacheKey:`${t}:${n},${s}`}}return{activation:t,activationCacheKey:t}}},1253:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseGatherAttributes=t.gather=void 0;const r=n(246),s=n(782),a=n(2517),i=n(2039);t.gather=(e,t,n)=>(l(t,n.axis),[e.run(u(e,t,n),t)]),t.parseGatherAttributes=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis",0)});const o={name:"Gather",inputNames:["A","B"],inputTypes:[i.TextureType.unpacked,i.TextureType.unpacked]},u=(e,t,n)=>{const r=Object.assign(Object.assign({},o),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const s=n[0].dims.slice(),o=n[1].dims.slice(),u=new Array(s.length+o.length-1);r=a.ShapeUtil.normalizeAxis(r,s.length);const l=[];for(let e=0;e<u.length;e++)e<r?(u[e]=s[e],l.push(`inputIdx[${e}] = outputIdx[${e}];`)):e<r+o.length?(u[e]=o[e-r],l.push(`indexDataIdx[${e-r}] = outputIdx[${e}];`)):(u[e]=s[e-o.length+1],l.push(`inputIdx[${e-o.length+1}] = outputIdx[${e}];`));const c=`\n      float process(int outputIdx[${u.length||1}]) {\n        int inputIdx[${s.length}];\n        int indexDataIdx[${o.length||1}];\n        indexDataIdx[0] = 0;\n        ${l.join("\n        ")}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${r}] = idx < 0 ? idx + ${s[r]} : idx;\n        return _A(inputIdx);\n      }`;return Object.assign(Object.assign({},t),{output:{dims:u,type:n[0].type,textureType:i.TextureType.unpacked},shaderSource:c})})(0,r,t,n.axis)})},l=(e,t)=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.");const n=e[0].dims.length;if(n<1)throw new Error("Invalid input shape.");if(t<-n||t>n-1)throw new Error("Invalid axis.");if(-1===s.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invaid input type.");if("int32"!==e[1].type&&"int16"!==e[1].type)throw new Error("Invaid input type.")}},4776:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseGemmAttributesV11=t.parseGemmAttributesV7=t.gemm=void 0;const r=n(246),s=n(2517),a=n(2039);t.gemm=(e,t,n)=>(l(t,n),[e.run(o(t,n),t)]);const i=(e,t)=>{const n=0!==e.attributes.getInt("transA",0),s=0!==e.attributes.getInt("transB",0),a=e.attributes.getFloat("alpha",1),i=e.attributes.getFloat("beta",1);return(0,r.createAttributeWithCacheKey)({transA:n,transB:s,alpha:a,beta:i,isOptionalC:t})};t.parseGemmAttributesV7=e=>i(e,!1),t.parseGemmAttributesV11=e=>i(e,!0);const o=(e,t)=>{const n={name:"Gemm",inputNames:3===e.length?["A","B","C"]:["A","B"],inputTypes:3===e.length?[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]:[a.TextureType.unpacked,a.TextureType.unpacked],key:t.cacheKey};return Object.assign(Object.assign({},n),{get:()=>u(n,e,t)})},u=(e,t,n)=>{const r=t[0].dims.slice(),i=t[1].dims.slice(),[o,u]=s.GemmUtil.getShapeOfGemmResult(r,n.transA,i,n.transB,3===t.length?t[2].dims:void 0),l=[o,u];if(!l)throw new Error("Can't use gemm on the given tensors");let c=r[r.length-1],h="";n.transA&&(c=r[0]),n.transA&&n.transB?h="value += _A_T(a) * _B_T(b);":n.transA&&!n.transB?h="value += _A_T(a) * _B(b);":!n.transA&&n.transB?h="value += _A(a) * _B_T(b);":n.transA||n.transB||(h="value += _A(a) * _B(b);");const d=l.length,p=`\n      float process(int indices[${d}]) {\n          int a[${d}];\n          int b[${d}];\n          ${3===t.length?`int c[${t[2].dims.length}];`:""}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${3===t.length?"bcastIndices_C(indices, c);":""}\n\n          float value = 0.0;\n          for (int k=0; k<${c}; ++k) {\n              a[${d-1}] = k;\n              b[${d-2}] = k;\n              ${h}\n          }\n\n          value = value * alpha;\n          ${3===t.length?"value += beta * _C(c);":""}\n          return value;\n      }`;return Object.assign(Object.assign({},e),{output:{dims:l,type:t[0].type,textureType:a.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:n.alpha},{name:"beta",type:"float",data:n.beta}],shaderSource:p})},l=(e,t)=>{if(!e)throw new Error("Input is missing");if(t.isOptionalC&&(e.length<2||e.length>3))throw new Error("Invaid input shape.");if(!t.isOptionalC&&3!==e.length)throw new Error("Gemm requires 3 inputs");if(3===e.length&&1!==e[2].dims.length&&2!==e[2].dims.length)throw new Error("Invalid input shape of C");if("float32"!==e[0].type&&"float64"!==e[0].type||"float32"!==e[1].type&&"float64"!==e[1].type||3===e.length&&"float32"!==e[2].type&&"float64"!==e[2].type)throw new Error("Invalid input type.");if(e[0].type!==e[1].type||3===e.length&&e[0].type!==e[2].type)throw new Error("Input types are mismatched")}},8555:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedIm2ColProgramInfoLoader=void 0;const r=n(5060),s=n(2039),a=n(2827);t.createPackedIm2ColProgramInfoLoader=(e,t,n,i,o)=>{const u=(l=o.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[s.TextureType.packed],cacheHint:l});var l;return Object.assign(Object.assign({},u),{get:()=>((e,t,n,i,o,u)=>{const l=n.dims,c=i.dims,h=o.length,d=[c[1]*c[2]*c[3],o[2]*o[3]],p=c[2]*c[3],f=(0,a.unpackFromChannel)(),m=(0,r.getGlsl)(e.session.backend.glContext.version);let g="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)g+=`\n            blockIndex = rc.x + ${t};\n            pos = rc.y + ${e};\n\n            if(blockIndex < ${d[1]} && pos < ${d[0]}) {\n              offsetY = int(blockIndex / (${o[h-1]})) * ${u.strides[0]} -\n                ${u.pads[0]};\n              d0 = offsetY + ${u.dilations[0]} * (imod(pos, ${p}) / ${c[2]});\n\n              if(d0 < ${l[2]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${o[h-1]}) * ${u.strides[1]} -\n                  ${u.pads[1]};\n                d1 = offsetX + ${u.dilations[1]} * imod(imod(pos, ${p}), ${c[2]});\n\n                if(d1 < ${l[3]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${p}.);\n                    innerDims = vec2(d0, d1);\n                    result[${2*e+t}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;const b=`\n      ${f}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${g}\n          ${m.output} = result;\n      }\n            `;return Object.assign(Object.assign({},t),{output:{dims:d,type:n.type,textureType:s.TextureType.packed},shaderSource:b,hasMain:!0})})(e,u,t,n,i,o)})}},3248:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.calculateIm2ColDims=t.createIm2ColProgramInfoLoader=void 0;const r=n(2039);t.createIm2ColProgramInfoLoader=(e,n,s,a,i)=>{const o=(u=i.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[r.TextureType.unpacked],cacheHint:u});var u;return Object.assign(Object.assign({},o),{get:()=>((e,n,s,a,i,o)=>{const u=s.dims,l=a.dims,c=i.length,h=(0,t.calculateIm2ColDims)(u,l,i,4),d=`\n        const int XC = ${u[1]};\n        const int XH = ${u[2]};\n        const int XW = ${u[3]};\n        const int KH = ${o.kernelShape[0]};\n        const int KW = ${o.kernelShape[1]};\n        const int dilationH = ${o.dilations[0]};\n        const int dilationW = ${o.dilations[1]};\n        const int strideH = ${o.strides[0]};\n        const int strideW = ${o.strides[1]};\n        const int padH = ${o.pads[0]};\n        const int padW = ${o.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${c}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${u.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;return Object.assign(Object.assign({},n),{output:{dims:h,type:s.type,textureType:r.TextureType.packedLastDimension},shaderSource:d})})(0,o,n,s,a,i)})},t.calculateIm2ColDims=(e,t,n,r=4)=>[n[0],n[2],n[3],Math.ceil(e[1]*t[2]*t[3]/r)]},6572:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseImageScalerAttributes=t.imageScaler=void 0;const r=n(246),s=n(2039);t.imageScaler=(e,t,n)=>(u(t),[e.run(i(e,t,n),t)]),t.parseImageScalerAttributes=e=>{const t=e.attributes.getFloat("scale"),n=e.attributes.getFloats("bias");return(0,r.createAttributeWithCacheKey)({scale:t,bias:n})};const a={name:"ImageScaler",inputNames:["X"],inputTypes:[s.TextureType.unpacked]},i=(e,t,n)=>{const r=Object.assign(Object.assign({},a),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},r),{get:()=>((e,t,n,r)=>{const a=n[0].dims.slice(),i=a.length,u=`\n      ${o(r.bias.length)}\n      float process(int indices[${i}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;return Object.assign(Object.assign({},t),{output:{dims:a,type:n[0].type,textureType:s.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:r.bias.length,data:r.bias},{name:"scale",type:"float",data:r.scale}],shaderSource:u})})(0,r,t,n)})},o=e=>{const t=[`float getBias(float bias[${e}], int channel) {`];for(let n=0;n<e;++n)0===n?t.push(`\tif (channel == ${n}) { return bias[${n}]; }`):n===e-1?t.push(`\telse { return bias[${n}]; }`):t.push(`\telse if (channel == ${n}) { return bias[${n}]; }`);return t.push("\t}"),t.join("\n")},u=e=>{if(!e||1!==e.length)throw new Error("ImageScaler requires 1 input.");if(4!==e[0].dims.length)throw new Error("Invalid input shape.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.")}},3346:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseInstanceNormalizationAttributes=t.instanceNormalization=void 0;const r=n(5060),s=n(2039);t.instanceNormalization=(e,t,n)=>{l(t);const r=e.run(i(t[0]),t);return[e.run(u(e,t[0],n,r.dims),[t[0],r,t[1],t[2]])]},t.parseInstanceNormalizationAttributes=e=>e.attributes.getFloat("epsilon",1e-5);const a={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[s.TextureType.unpacked]},i=e=>Object.assign(Object.assign({},a),{get:()=>((e,t)=>{const n=t.dims.slice(),r=n[1],a=n[2]*n[3],i=[n[0],r],o=`\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${a});\n        temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${a});\n\n        return v;\n      }`;return Object.assign(Object.assign({},e),{output:{dims:i,type:t.type,textureType:s.TextureType.packedLastDimension},shaderSource:o})})(a,e)}),o={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[s.TextureType.unpacked,s.TextureType.packedLastDimension,s.TextureType.unpacked,s.TextureType.unpacked]},u=(e,t,n,a)=>{const i=Object.assign(Object.assign({},o),{cacheHint:`${n}`});return Object.assign(Object.assign({},i),{get:()=>((e,t,n,a,i)=>{const o=(0,r.getGlsl)(e.session.backend.glContext.version),[u,l]=e.calculateTextureWidthAndHeight(i,s.TextureType.packedLastDimension),[c,h]=[u/4,l],d=`\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${c}, ${h});\n        return ${o.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;return Object.assign(Object.assign({},t),{output:{dims:n.dims,type:n.type,textureType:s.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:a}],shaderSource:d})})(e,i,t,n,a)})},l=e=>{if(!e||3!==e.length)throw new Error("InstanceNormalization requires 3 inputs.");const t=e[0],n=e[1],r=e[2];if(t.dims.length<3||1!==n.dims.length||1!==r.dims.length)throw new Error("Invalid input shape.");if(n.dims[0]!==t.dims[1]||r.dims[0]!==t.dims[1])throw new Error("Input shapes are mismatched.");if("float32"!==t.type&&"float64"!==t.type||"float32"!==n.type&&"float64"!==n.type||"float32"!==r.type&&"float64"!==r.type)throw new Error("Invalid input type.");if(4!==e[0].dims.length)throw new Error("Only support 4-D input shape.")}},708:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedMatmulProgramInfoLoader=void 0;const r=n(2517),s=n(5060),a=n(2039),i=n(9390),o=n(2823),u=n(5623);t.createPackedMatmulProgramInfoLoader=(e,t,n)=>{const l=(c=t.length>2,h=n.activationCacheKey,{name:"MatMul (packed)",inputNames:c?["A","B","Bias"]:["A","B"],inputTypes:c?[a.TextureType.packed,a.TextureType.packed,a.TextureType.packed]:[a.TextureType.packed,a.TextureType.packed],cacheHint:h});var c,h;return Object.assign(Object.assign({},l),{get:()=>((e,t,n,l)=>{const c=n.length>2,h=c?"value += getBiasForMatmul();":"",d=n[0].dims,p=n[1].dims,f=r.BroadcastUtil.calcShape(d,p,!0),m=!r.ShapeUtil.areEqual(n[0].dims,n[1].dims);if(!f)throw new Error("Can't use matmul on the given tensors");const g=d[d.length-1],b=Math.ceil(g/2),y=d.length,x=p.length,w=(0,s.getGlsl)(e.session.backend.glContext.version),v=(0,i.getCoordsDataType)(f.length),_=f.length,k=(0,i.getGlChannels)(),{activationFunction:T,applyActivation:S}=(0,o.getActivationSnippet)(l),I=c?`${(0,u.getBiasForMatmul)(v,k,n[2].dims,f,!0)}`:"",N=m?`${function(e,t,n,s){let a=[],i=[];const o=n[0].dims,u=n[1].dims,l=o.length,c=u.length,h=s.length,d=h-l,p=h-c;a=o.map((e,n)=>`coords.${t[n+d]}`),a[l-1]="i*2",a.join(", "),i=u.map((e,n)=>`coords.${t[n+p]}`),i[c-2]="i*2",i.join(", ");const f=r.BroadcastUtil.getBroadcastDims(o,s),m=r.BroadcastUtil.getBroadcastDims(u,s),g=f.map(e=>`coords.${t[e+d]} = 0;`).join("\n"),b=m.map(e=>`coords.${t[e+p]} = 0;`).join("\n"),y=`int lastDim = coords.${t[h-1]};\n  coords.${t[h-1]} = coords.${t[h-2]};\n  coords.${t[h-2]} = lastDim;`;return`\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${e} coords = getOutputCoords();\n  ${y}\n  ${g}\n  vec4 outputValue = getA(${a});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${e} coords = getOutputCoords();\n  ${y}\n  ${b}\n  vec4 outputValue = getB(${i});\n  return outputValue;\n}`}(v,k,n,f)}`:"",E=m?"getAAtOutCoordsMatmul(i)":`getA(${function(e,t){let n="";for(let r=0;r<t-2;r++)n+=`rc.${e[r]}, `;return n+=`rc.${e[t-2]}, i*2`,n}(k,y)})`,$=m?"getBAtOutCoordsMatmul(i)":`getB(${function(e,t){let n="";for(let r=0;r<t-2;r++)n+=`rc.${e[r]}, `;return n+=`i*2, rc.${e[t-1]}`,n}(k,x)})`,A=`\n            ${N}\n            ${I}\n            ${T}\n            void main() {\n              ${m?"":`${v} rc =\n          getOutputCoords(); int lastDim = rc.${k[_-1]}; rc.${k[_-1]} =\n          rc.${k[_-2]}; rc.${k[_-2]} = lastDim;\n      `}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${b}; i++) {\n                vec4 a = ${E};\n                vec4 b = ${$};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${h}\n              ${S}\n              ${w.output} = value;\n            }`;return Object.assign(Object.assign({},t),{output:{dims:f,type:n[0].type,textureType:a.TextureType.packed},shaderSource:A,hasMain:!0})})(e,l,t,n)})}},5623:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getBiasForMatmul=t.createMatmulProgramInfoLoader=t.parseMatMulAttributes=t.matMul=void 0;const r=n(2517),s=n(2039),a=n(9390),i=n(2823),o=n(708);function u(e,t){const n=(o=e.length>2,u=t.activationCacheKey,{name:"MatMul",inputNames:o?["A","B","Bias"]:["A","B"],inputTypes:o?[s.TextureType.unpacked,s.TextureType.unpacked,s.TextureType.unpacked]:[s.TextureType.unpacked,s.TextureType.unpacked],cacheHint:u});var o,u;return Object.assign(Object.assign({},n),{get:()=>function(e,t,n){const o=t[0].dims,u=t[1].dims,l=r.BroadcastUtil.calcShape(o,u,!0);if(!l)throw new Error("Can't use matmul on the given tensors");const h=(0,a.getCoordsDataType)(l.length),d=(0,a.getGlChannels)(),{activationFunction:p,applyActivation:f}=(0,i.getActivationSnippet)(n),m=t.length>2,g=m?"value += getBiasForMatmul();":"",b=m?`${c(h,d,t[2].dims,l,!1)}`:"",y=l.length,x=o.length,w=u.length,v=`\n    ${p}\n    ${b}\n    float process(int indices[${y}]) {\n        int a[${x}];\n        int b[${w}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${o[o.length-1]}; ++k) {\n            a[${x-1}] = k;\n            b[${w-2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${g}\n        ${f}\n        return value;\n    }`;return Object.assign(Object.assign({},e),{output:{dims:l,type:t[0].type,textureType:s.TextureType.unpacked},shaderSource:v})}(n,e,t)})}t.matMul=(e,t,n)=>(l(t),e.session.pack?[e.run((0,o.createPackedMatmulProgramInfoLoader)(e,t,n),t)]:[e.run(u(t,n),t)]),t.parseMatMulAttributes=e=>(0,i.parseInternalActivationAttributes)(e.attributes),t.createMatmulProgramInfoLoader=u;const l=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if("float32"!==e[0].type&&"float64"!==e[0].type||"float32"!==e[1].type&&"float64"!==e[1].type)throw new Error("inputs should be float type");if(e[0].type!==e[1].type)throw new Error("inputs types should match")};function c(e,t,n,s,a){let i="";const o=n.length,u=s.length,l=u-o;i=u<2&&o>0?"coords":n.map((e,n)=>`coords.${t[n+l]}`).join(", ");const c=r.BroadcastUtil.getBroadcastDims(n,s).map(e=>`coords.${t[e+l]} = 0;`).join("\n");let h="vec4(outputValue.xx, outputValue.yy)";return 1===r.ShapeUtil.size(n)&&(h="vec4(outputValue.x)"),a?`\nvec4 getBiasForMatmul() {\n  ${e} coords = getOutputCoords();\n  ${c}\n  vec4 outputValue = getBias(${i});\n  return ${h};\n}`:`\nfloat getBiasForMatmul() {\n  ${e} coords = getOutputCoords();\n  ${c}\n  return getBias(coords.x);\n}`}t.getBiasForMatmul=c},2403:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createPackProgramInfoLoader=void 0;const r=n(5060),s=n(2039),a=n(9390),i=n(2827),o={name:"pack",inputNames:["A"],inputTypes:[s.TextureType.unpackedReversed]};t.createPackProgramInfoLoader=(e,t)=>Object.assign(Object.assign({},o),{get:()=>((e,t)=>{const n=(0,r.getGlsl)(e.session.backend.glContext.version),u=t.dims,l=u.length,c=t.dims.length,h=(0,a.getCoordsDataType)(c),d=(0,i.getChannels)("rc",c),p=(f=c,m=d,g=u[u.length-2],b=u[u.length-1],0===f||1===f?"":`\n    int r = ${m[f-2]};\n    int c = ${m[f-1]};\n    int rp1 = ${m[f-2]} + 1;\n    int cp1 = ${m[f-1]} + 1;\n    bool rEdge = rp1 >= ${b};\n    bool cEdge = cp1 >= ${g};\n    `);var f,m,g,b;let y;y=0===l?[1,1]:1===l?[u[0],1]:[u[c-1],u[c-2]];const x=function(e,t,n){if(0===e)return"false";if(1===e)return`rc > ${t[0]}`;let r="";for(let s=e-2;s<e;s++)r+=`${n[s]} >= ${t[s-e+2]}`,s<e-1&&(r+="||");return r}(c,y,d),w=function(e,t){const n=e.length;if(0===n)return"getA(), 0, 0, 0";if(1===n)return`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`;let r="";if(n>2)for(let e=0;e<n-2;++e)r+=`${t[e]},`;return`getA(${r}r, c),\n          rEdge ? 0. : getA(${r}rp1, c),\n          cEdge ? 0. : getA(${r}r, cp1),\n          rEdge || cEdge ? 0. : getA(${r}rp1, cp1)`}(u,d),v=`\n        void main() {\n          ${h} rc = getOutputCoords();\n\n          if(${x}) {\n            ${n.output} = vec4(0);\n          } else {\n            ${p}\n\n            ${n.output} = vec4(${w});\n          }\n        }\n      `;return Object.assign(Object.assign({},o),{hasMain:!0,output:{dims:t.dims,type:t.type,textureType:s.TextureType.packed},shaderSource:v})})(e,t)})},2827:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.unpackFromChannel=t.getChannels=t.getVecChannels=void 0;const r=n(9390);function s(e,t){return(0,r.getGlChannels)(t).map(t=>`${e}.${t}`)}t.getVecChannels=s,t.getChannels=function(e,t){return 1===t?[e]:s(e,t)},t.unpackFromChannel=function(){return"\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  "}},2870:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parsePadAttributesV11=t.padV11=t.parsePadAttributesV2=t.padV2=void 0;const r=n(246),s=n(2517),a=n(5060),i=n(2039),o={name:"Pad",inputNames:["A"],inputTypes:[i.TextureType.unpacked]};t.padV2=(e,t,n)=>(c(t),[e.run(Object.assign(Object.assign({},o),{cacheHint:n.cacheKey,get:()=>l(e,t[0],n)}),t)]),t.parsePadAttributesV2=e=>{const t=e.attributes.getString("mode","constant"),n=e.attributes.getFloat("value",0),s=e.attributes.getInts("pads");return(0,r.createAttributeWithCacheKey)({mode:t,value:n,pads:s})},t.padV11=(e,n,r)=>{h(n);const s=u(e,n,r);return(0,t.padV2)(e,[n[0]],s)},t.parsePadAttributesV11=e=>e.attributes.getString("mode","constant");const u=(e,t,n)=>{if(!e.session.isInitializer(t[1].dataId)||t.length>=3&&!e.session.isInitializer(t[2].dataId))throw new Error("dynamic pad attributes are not allowed");const s=Array.from(t[1].integerData),a=t.length>=3?t[2].floatData[0]:0;return(0,r.createAttributeWithCacheKey)({mode:n,pads:s,value:a})},l=(e,t,n)=>{const r=s.ShapeUtil.padShape(t.dims.slice(),n.pads),a=r.length,o=`\n      ${d(e,t,n)}\n      float process(int[${a}] indices) {\n          return padA(indices);\n      }`;return{name:"Pad",inputNames:["A"],inputTypes:[i.TextureType.unpacked],output:{dims:r,type:t.type,textureType:i.TextureType.unpacked},shaderSource:o}},c=e=>{if(!e||1!==e.length)throw new Error("Pad requires 1 input");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.")},h=e=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Pad requires 2 or 3 inputs");if("int32"!==e[1].type)throw new Error("Invalid input type.");if(e.length>=3&&"string"===e[2].type)throw new Error("Invalid input type.")},d=(e,t,n)=>{const r=(0,a.getGlsl)(e.session.backend.glContext.version),[o,u]=e.calculateTextureWidthAndHeight(t.dims,i.TextureType.unpacked),l=s.ShapeUtil.computeStrides(t.dims);switch(n.mode){case"constant":return p(r,t.dims,l,o,u,n.pads,n.value);case"reflect":return f(r,t.dims,l,o,u,n.pads);case"edge":return m(r,t.dims,l,o,u,n.pads);default:throw new Error("Invalid mode")}},p=(e,t,n,r,s,a,i)=>{const o=t.length;let u="";for(let e=o-1;e>=0;--e)u+=`\n        k = m[${e}] - ${a[e]};\n        if (k < 0)  return constant;\n        if (k >= ${t[e]}) return constant;\n        offset += k * ${n[e]};\n        `;return`\n      float padA(int m[${o}]) {\n        const float constant = float(${i});\n        int offset = 0;\n        int k = 0;\n        ${u}\n        vec2 coords = offsetToCoords(offset, ${r}, ${s});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `},f=(e,t,n,r,s,a)=>{const i=t.length;let o="";for(let e=i-1;e>=0;--e)o+=`\n        k = m[${e}] - ${a[e]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2*(t[e]-1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${t[e]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${n[e]};\n        `;return`\n      float padA(int m[${i}]) {\n        int offset = 0;\n        int k = 0;\n        ${o}\n        vec2 coords = offsetToCoords(offset, ${r}, ${s});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `},m=(e,t,n,r,s,a)=>{const i=t.length;let o="";for(let e=i-1;e>=0;--e)o+=`\n        k = m[${e}] - ${a[e]};\n        if (k < 0)  k = 0;\n        if (k >= ${t[e]}) k = ${t[e]-1};\n        offset += k * ${n[e]};\n      `;return`\n      float padA(int m[${i}]) {\n        int offset = 0;\n        int k = 0;\n        ${o}\n        vec2 coords = offsetToCoords(offset, ${r}, ${s});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `}},2143:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.globalMaxPool=t.parseMaxPoolAttributes=t.maxPool=t.parseGlobalAveragePoolAttributes=t.globalAveragePool=t.parseAveragePoolAttributes=t.averagePool=void 0;const r=n(246),s=n(2517),a=n(2039);t.averagePool=(e,t,n)=>{h(t);const r={name:"AveragePool",inputNames:["X"],inputTypes:[a.TextureType.unpacked],cacheHint:n.cacheKey};return[e.run(Object.assign(Object.assign({},r),{get:()=>i(t,r,!1,n)}),t)]},t.parseAveragePoolAttributes=e=>{const t=e.attributes.getString("auto_pad","NOTSET"),n=e.attributes.getInt("ceil_mode",0),s=0!==e.attributes.getInt("count_include_pad",0),a=e.attributes.getInts("kernel_shape"),i=e.attributes.getInts("strides",[]),o=e.attributes.getInts("pads",[]);if(0!==n)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,r.createAttributeWithCacheKey)({autoPad:t,ceilMode:n,countIncludePad:s,kernelShape:a,strides:i,pads:o})};const i=(e,t,n,r)=>{const[i,o]=u(e,r,n),l=s.ShapeUtil.size(i.kernelShape);let c="";i.countIncludePad?c+=`value /= float(${l});`:c+=`value /= float(${l} - pad);`;const h=`\n        ${d(e[0].dims,i,"value += _X(x);",c,"0.0")}\n      `;return Object.assign(Object.assign({},t),{output:{dims:o,type:e[0].type,textureType:a.TextureType.unpacked},shaderSource:h})};t.globalAveragePool=(e,t,n)=>{h(t);const r={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[a.TextureType.unpacked],cacheHint:`${n.countIncludePad}`};return[e.run(Object.assign(Object.assign({},r),{get:()=>i(t,r,!0,n)}),t)]},t.parseGlobalAveragePoolAttributes=e=>{const t=0!==e.attributes.getInt("count_include_pad",0);return(0,r.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:t,kernelShape:[],strides:[],pads:[]})},t.maxPool=(e,t,n)=>{h(t);const r={name:"MaxPool",inputNames:["X"],inputTypes:[a.TextureType.unpacked],cacheHint:n.cacheKey};return[e.run(Object.assign(Object.assign({},r),{get:()=>o(t,r,!1,n)}),t)]},t.parseMaxPoolAttributes=e=>{const t=e.attributes.getString("auto_pad","NOTSET"),n=e.attributes.getInt("ceil_mode",0),s=e.attributes.getInts("kernel_shape"),a=e.attributes.getInts("strides",[]),i=e.attributes.getInts("pads",[]),o=e.attributes.getInt("storage_order",0),u=e.attributes.getInts("dilations",[]);if(0!==o)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==n)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,r.createAttributeWithCacheKey)({autoPad:t,ceilMode:n,countIncludePad:!1,kernelShape:s,strides:a,pads:i,storageOrder:o,dilations:u})};const o=(e,t,n,r)=>{const[s,i]=u(e,r,n),o=`\n      ${d(e[0].dims,s,"\n      value = max(_X(x), value);\n    ","","-1e5")}\n    `;return Object.assign(Object.assign({},t),{output:{dims:i,type:e[0].type,textureType:a.TextureType.unpacked},shaderSource:o})},u=(e,t,n)=>{const r=e[0].dims.slice(),a=Object.hasOwnProperty.call(t,"dilations"),i=t.kernelShape.slice(),o=t.strides.slice(),u=a?t.dilations.slice():[],l=t.pads.slice();s.PoolConvUtil.adjustPoolAttributes(n,r,i,o,u,l);const c=s.PoolConvUtil.computePoolOutputShape(n,r,o,u,i,l,t.autoPad),h=Object.assign({},t);return a?Object.assign(h,{kernelShape:i,strides:o,pads:l,dilations:u,cacheKey:t.cacheKey}):Object.assign(h,{kernelShape:i,strides:o,pads:l,cacheKey:t.cacheKey}),[h,c]},l={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},c={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[a.TextureType.unpacked]};t.globalMaxPool=(e,t)=>(h(t),[e.run(Object.assign(Object.assign({},c),{get:()=>o(t,c,!0,l)}),t)]);const h=e=>{if(!e||1!==e.length)throw new Error("Pool ops requires 1 input.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.")},d=(e,t,n,r,a)=>{const i=e.length;if(t.kernelShape.length<=2){const s=t.kernelShape[t.kernelShape.length-1],o=t.strides[t.strides.length-1],u=t.pads[t.pads.length/2-1],l=t.pads[t.pads.length-1],c=e[i-1];let h="",d="",p="";if(h=u+l!==0?`\n          for (int i = 0; i < ${s}; i++) {\n            x[${i} - 1] = indices[${i} - 1] * ${o} - ${u} + i;\n            if (x[${i} - 1] < 0 || x[${i} - 1] >= ${c}) {\n              pad++;\n              continue;\n            }\n            ${n}\n          }`:`\n          for (int i = 0; i < ${s}; i++) {\n            x[${i} - 1] = indices[${i} - 1] * ${o} - ${u} + i;\n            ${n}\n          }`,2===t.kernelShape.length){const n=t.kernelShape[t.kernelShape.length-2],r=t.strides[t.strides.length-2],a=t.pads[t.pads.length/2-2],o=t.pads[t.pads.length-2],u=e[i-2];d=a+o!==0?`\n            for (int j = 0; j < ${n}; j++) {\n              x[${i} - 2] = indices[${i} - 2] * ${r} - ${a} + j;\n              if (x[${i} - 2] < 0 || x[${i} - 2] >= ${u}) {\n                pad+= ${s};\n                continue;\n              }\n          `:`\n            for (int j = 0; j < ${n}; j++) {\n              x[${i} - 2] = indices[${i} - 2] * ${r} - ${a} + j;\n            `,p="\n          }\n        "}return`\n        float process(int indices[${i}]) {\n          int x[${i}];\n          copyVec(indices, x);\n\n          float value = ${a};\n          int pad = 0;\n          ${d}\n          ${h}\n          ${p}\n          ${r}\n          return value;\n        }\n      `}{const o=s.ShapeUtil.size(t.kernelShape),u=s.ShapeUtil.computeStrides(t.kernelShape),l=u.length,c=t.pads.length,h=f(l),d=p(e,"inputDims"),m=p(t.pads,"pads"),g=p(u,"kernelStrides"),b=p(t.strides,"strides");let y="";return y=t.pads.reduce((e,t)=>e+t)?`\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${n}\n          }`:`\n          }\n          ${n}\n        `,`\n        ${h}\n        float process(int indices[${i}]) {\n          int x[${i}];\n          copyVec(indices, x);\n          int offset[${l}];\n          int pads[${c}];\n          int inputDims[${i}];\n          int kernelStrides[${l}];\n          int strides[${l}];\n          ${m}\n          ${d}\n          ${b}\n          ${g}\n\n          float value = ${a};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${o}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${i} - ${l}; j < ${i}; j++) {\n              x[j] = indices[j] * strides[j - ${i} + ${l}]\n                + offset[j - ${i} + ${l}] - pads[j - 2];\n              ${y}\n          }\n          ${r}\n\n          return value;\n        }\n      `}},p=(e,t)=>{let n="";for(let r=0;r<e.length;r++)n+=`\n      ${t}[${r}] = ${e[r]};\n    `;return n},f=e=>`\n  void offsetToIndices(int offset, int[${e}] strides, out int[${e}] indices) {\n    if (${e} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${e} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${e} - 1] = offset;\n  }`},4939:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.reduceLogSumSquare=t.reduceLogSum=t.reduceProd=t.reduceMin=t.reduceMax=t.reduceMean=t.reduceSum=t.parseReduceAttributes=void 0;const r=n(246),s=n(782),a=n(2517),i=n(2039),o=(e,t,n,r,s)=>{l(t);const a={name:r,inputNames:["A"],inputTypes:[i.TextureType.unpacked]};return[e.run(Object.assign(Object.assign({},a),{cacheHint:n.cacheKey,get:()=>u(e,t,n,r,s,a)}),t)]};t.parseReduceAttributes=e=>{const t=e.attributes.getInts("axes",[]),n=1===e.attributes.getInt("keepdims",1);return(0,r.createAttributeWithCacheKey)({axes:t,keepDims:n})};const u=(e,t,n,r,s,o)=>{const u=[],l=t[0].dims.length||1,c=[],h=a.ShapeUtil.normalizeAxes(n.axes,t[0].dims.length),d=s(t,h);let p=d[1];for(let e=0;e<t[0].dims.length;e++)h.indexOf(e)>=0||0===h.length?(n.keepDims&&u.push(1),p=`\n          for(int j${e} = 0; j${e} < ${t[0].dims[e]}; j${e}++) {\n            inputIdx[${e}] = j${e};\n            ${p}\n          }`):(c.push(`inputIdx[${e}] = outputIdx[${u.length}];`),u.push(t[0].dims[e]));const f=`\n      float process(int outputIdx[${u.length||1}]) {\n        float value;                 // final result\n        int inputIdx[${l}];      // addressing input data\n        ${c.join("\n")}\n        ${d[0]}       // init ops for reduce max/min\n        ${p}\n        ${d[2]}       // final computation for reduce mean\n        return value;\n      }`;return Object.assign(Object.assign({},o),{output:{dims:u,type:t[0].type,textureType:i.TextureType.unpacked},shaderSource:f})},l=e=>{if(!e||1!==e.length)throw new Error("Reduce op requires 1 input.");if(-1===s.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invalid input type.")};t.reduceSum=(e,t,n)=>o(e,t,n,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),t.reduceMean=(e,t,n)=>o(e,t,n,"ReduceMean",(e,t)=>{let n=1;for(let r=0;r<e[0].dims.length;r++)(t.indexOf(r)>=0||0===t.length)&&(n*=e[0].dims[r]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${n}.;`]}),t.reduceMax=(e,t,n)=>o(e,t,n,"ReduceMax",(e,t)=>{const n=[];for(let r=0;r<e[0].dims.length;r++)(t.indexOf(r)>=0||0===t.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join("\n")}\nvalue = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),t.reduceMin=(e,t,n)=>o(e,t,n,"ReduceMin",(e,t)=>{const n=[];for(let r=0;r<e[0].dims.length;r++)(t.indexOf(r)>=0||0===t.length)&&n.push(`inputIdx[${r}] = 0;`);return[`${n.join("\n")}\nvalue = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),t.reduceProd=(e,t,n)=>o(e,t,n,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),t.reduceLogSum=(e,t,n)=>o(e,t,n,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),t.reduceLogSumSquare=(e,t,n)=>o(e,t,n,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7019:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isReshapeCheap=t.processDims3D=t.createPackedReshape3DProgramInfoLoader=void 0;const r=n(2517),s=n(5060),a=n(2039),i=n(2827);t.createPackedReshape3DProgramInfoLoader=(e,t,n)=>{const o=(e=>({name:"Reshape (packed)",inputTypes:[a.TextureType.packed],inputNames:["A"],cacheHint:`${e}`}))(n);return Object.assign(Object.assign({},o),{get:()=>((e,t,n,o)=>{const u=t.dims,l=o;let c="";for(let e=0;e<4;e++){let t="";switch(e){case 0:t="outputCoords = rc;";break;case 1:t="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:t="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:t="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}c+=`\n        ${t}\n        ${e>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${e>0?"}":""}\n      `}const h=(0,s.getGlsl)(e.session.backend.glContext.version),d=`\n      ${function(e){const t=r.ShapeUtil.computeStrides(e),n=["b","r","c"],s="index";return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t.map((e,r)=>`int ${n[r]} = ${s} / ${e}; ${r===t.length-1?`int ${n[r+1]} = ${s} - ${n[r]} * ${e}`:`index -= ${n[r]} * ${e}`};`).join("")}\n      return ivec3(b, r, c);\n    }\n  `}(u)}\n      ${function(e){const t=r.ShapeUtil.computeStrides(e);return`\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${t[0]} + coords.z * ${t[1]} + coords.y;\n  }\n`}(l)}\n      ${(0,i.unpackFromChannel)()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${l[2]};\n        int cols = ${l[1]};\n\n        ${c}\n        ${h.output} = result;\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:l,type:t.type,textureType:a.TextureType.packed},shaderSource:d,hasMain:!0})})(e,t,o,n)})},t.processDims3D=function(e){if(0===e.length)return[1,1,1];let t=1;for(let n=0;n<e.length-2;++n)t*=e[n];return[t,e.length>1?e[e.length-2]:1,e[e.length-1]]},t.isReshapeCheap=function(e,t){let n=!1;return n=0===e.length||0===t.length||(e.length<2||t.length<2?e[e.length-1]===t[t.length-1]:e[e.length-1]===t[t.length-1]&&e[e.length-2]===t[t.length-2]),n}},718:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.reshape=void 0;const r=n(2517);t.reshape=(e,t)=>{const n=r.ShapeUtil.calculateReshapedDims(t[0].dims,t[1].integerData);return e.session.pack?[e.reshapePacked(t[0],n)]:[e.reshapeUnpacked(t[0],n)]}},2268:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseResizeAttributesV11=t.parseResizeAttributesV10=t.resize=void 0;const r=n(5060),s=n(2039),a=n(9390),i=n(2827),o=n(9793),u={name:"Resize",inputNames:["A"],inputTypes:[s.TextureType.packed]};t.resize=(e,t,n)=>((0,o.validateInputs)(t,n),[e.run(Object.assign(Object.assign({},u),{cacheHint:n.cacheKey,get:()=>l(e,t,n)}),t)]),t.parseResizeAttributesV10=e=>(0,o.parseUpsampleAttributes)(e,10),t.parseResizeAttributesV11=e=>(0,o.parseUpsampleAttributes)(e,11);const l=(e,t,n)=>{const o=(0,r.getGlsl)(e.session.backend.glContext.version),[l,h]=c(t,n);if(l.every(e=>1===e)&&"tf_crop_and_resize"!==n.coordinateTransformMode)return Object.assign(Object.assign({},u),{output:{dims:h,type:t[0].type,textureType:s.TextureType.packed},hasMain:!0,shaderSource:`void main() {\n                    vec4 v = ${o.texture2D}(X, TexCoords);\n                    ${o.output} = v;\n                }`});const d=h.length;if(d<2)throw new Error(`output dimension should be at least 2, but got ${d}`);const p=h[d-2],f=h[d-1],m=t[0].dims;if(d!==m.length)throw new Error(`output dimension should match input ${m.length}, but got ${d}`);const g=m[d-2],b=m[d-1],y=l[d-2],x=l[d-1];let w="";if("linear"!==n.mode)throw new Error(`resize (packed) does not support mode: '${n.mode}'`);switch(n.coordinateTransformMode){case"asymmetric":w="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";break;case"half_pixel":w="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";break;case"pytorch_half_pixel":w=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${f}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${p}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${f}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${p}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;break;case"align_corners":w=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${f}.0 - 1.0, ${p}.0 - 1.0, ${f}.0 - 1.0,\n                            ${p}.0 - 1.0);\n                        vec4 original = vec4(${b}.0 - 1.0, ${g}.0 - 1.0, ${b}.0 - 1.0,\n                            ${g}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n.coordinateTransformMode}'`)}const v=(0,a.getCoordsDataType)(d),_=`\n            const vec2 inputWH = vec2(${g}.0, ${b}.0);\n            const vec4 scaleWHWH = vec4(float(${y}), float(${x}), float(${y}), float(${x}));\n            ${(0,i.unpackFromChannel)()}\n            ${w}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${v} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${p-1};\n                bool hasNextCol = rc.z < ${f-1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${o.output} = vec4(newValue);\n            }\n        `;return Object.assign(Object.assign({},u),{output:{dims:h,type:t[0].type,textureType:s.TextureType.packed},hasMain:!0,shaderSource:_})},c=(e,t)=>{const n=e[0].dims;let r,s=t.scales;if(0===s.length){const a=e[t.scalesInputIdx];if(a&&0!==a.size){if(e[t.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");s=h(a,t.mode,t.isResize)}else{const a=e[t.sizesInputIdx];if(!a||0===a.size)throw new Error("Either scales or sizes MUST be provided as input.");r=Array.from(a.integerData),s=d(r,n,t.mode,t.isResize)}}else if(e[t.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const a=r||n.map((e,t)=>Math.floor(e*s[t]));return[s,a]},h=(e,t,n)=>{const r=Array.from(e.floatData);return(0,o.scalesValidation)(r,t,n),r},d=(e,t,n,r)=>{const s=t.length,a=new Array(s);for(let n=0,r=s;n<r;n++)if(0===t[n]){if(0!==e[n])throw new Error("Input dim is zero but required output dim is non-zero.");a[n]=1}else a[n]=e[n]/t[n];return(0,o.scalesValidation)(a,n,r),a}},8117:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.shape=void 0;const r=n(9162);t.shape=(e,t)=>(s(t),[new r.Tensor([t[0].dims.length],"int32",void 0,void 0,new Int32Array(t[0].dims))]);const s=e=>{if(!e||1!==e.length)throw new Error("Shape requires 1 input.")}},2278:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.sliceV10=t.parseSliceAttributes=t.slice=void 0;const r=n(246),s=n(782),a=n(2517),i=n(2039),o={name:"Slice",inputNames:["A"],inputTypes:[i.TextureType.unpacked]};t.slice=(e,t,n)=>(l(t),[e.run(Object.assign(Object.assign({},o),{cacheHint:n.cacheKey,get:()=>u(e,t[0],n)}),t)]),t.parseSliceAttributes=e=>{const t=e.attributes.getInts("starts"),n=e.attributes.getInts("ends"),s=e.attributes.getInts("axes",[]);return(0,r.createAttributeWithCacheKey)({starts:t,ends:n,axes:s})};const u=(e,t,n)=>{const r=0===n.axes.length?t.dims.slice(0).map((e,t)=>t):n.axes,s=a.ShapeUtil.normalizeAxes(r,t.dims.length),u=n.starts.map((e,n)=>e>t.dims[s[n]]-1?t.dims[s[n]]:a.ShapeUtil.normalizeAxis(e,t.dims[s[n]])),l=n.ends.map((e,n)=>e>t.dims[s[n]]-1?t.dims[s[n]]:a.ShapeUtil.normalizeAxis(e,t.dims[s[n]])),c=t.dims.slice(),h=[];for(let e=0;e<s.length;e++)c[s[e]]=l[e]-u[e],u[e]>0&&h.push(`outputIdx[${s[e]}] += ${u[e]};`);const d=`\n      float process(int outputIdx[${c.length}]) {\n        ${h.join("\n      ")}\n        return _A(outputIdx);\n      }`;return Object.assign(Object.assign({},o),{output:{dims:c,type:t.type,textureType:i.TextureType.unpacked},shaderSource:d})},l=e=>{if(!e||1!==e.length)throw new Error("Slice requires 1 input.");if(-1===s.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invalid input type.")};t.sliceV10=(e,t)=>{h(t);const n=c(e,t);return[e.run(Object.assign(Object.assign({},o),{cacheHint:n.cacheKey,get:()=>u(e,t[0],n)}),[t[0]])]};const c=(e,t)=>{if(!e.session.isInitializer(t[1].dataId)||!e.session.isInitializer(t[2].dataId)||t.length>=4&&!e.session.isInitializer(t[3].dataId)||t.length>=5&&!e.session.isInitializer(t[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(t.length>=5&&t[4].integerData.some(e=>1!==e))throw new Error("currently non-1 steps is not supported for Slice");const n=Array.from(t[1].integerData),r=Array.from(t[2].integerData),s=t.length>=4?Array.from(t[3].integerData):[];return{starts:n,ends:r,axes:s,cacheKey:`${s};${n};${r}`}},h=e=>{if(!e||e.length<3||e.length>5)throw new Error("Invalid input number.");if("int32"!==e[1].type||1!==e[1].dims.length)throw new Error("Invalid input type.");if("int32"!==e[2].type||1!==e[2].dims.length)throw new Error("Invalid input type.");if(e.length>=4&&("int32"!==e[3].type||1!==e[3].dims.length))throw new Error("Invalid input type.");if(e.length>=5&&("int32"!==e[4].type||1!==e[4].dims.length))throw new Error("Invalid input type.")}},5524:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.softmaxV13=t.parseSoftmaxAttributesV13=t.parseSoftmaxAttributes=t.softmax=void 0;const r=n(246),s=n(2517),a=n(5060),i=n(2039),o=n(3738),u={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[i.TextureType.unpacked]},l={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[i.TextureType.unpacked,i.TextureType.unpacked]},c={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked]};t.softmax=(e,t,n)=>{m(t);const r=t[0].dims.slice(),a=s.ShapeUtil.normalizeAxis(n.axis,r.length),i=s.ShapeUtil.sizeToDimension(r,a),o=s.ShapeUtil.sizeFromDimension(r,a);return h(e,t,n,i,o)},t.parseSoftmaxAttributes=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis",1)}),t.parseSoftmaxAttributesV13=e=>(0,r.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis",-1)}),t.softmaxV13=(e,t,n)=>{m(t);const a=t[0].dims.slice(),i=s.ShapeUtil.normalizeAxis(n.axis,a.length),u=a.length,l=i!==u-1,c=[];let d,p=[],f=[];l&&(p=Array.from({length:u}).map((e,t)=>t),p[i]=u-1,p[u-1]=i,p.map(e=>c.push(a[e])),d=(0,r.createAttributeWithCacheKey)({perm:p}),f=(0,o.transpose)(e,t,d));const g=l?s.ShapeUtil.sizeToDimension(c,u-1):s.ShapeUtil.sizeToDimension(a,u-1),b=l?s.ShapeUtil.sizeFromDimension(c,u-1):s.ShapeUtil.sizeFromDimension(a,u-1),y=h(e,l?f:t,n,g,b);return l?(0,o.transpose)(e,y,d):y};const h=(e,t,n,r,s)=>{const a=d(e,t[0],r,s,[r]),i=e.run(Object.assign(Object.assign({},u),{cacheHint:n.cacheKey,get:()=>a}),t),o=p(e,t[0],r,s,a.output.dims,[r]),h=e.run(Object.assign(Object.assign({},l),{cacheHint:n.cacheKey,get:()=>o}),[t[0],i]),m=f(e,t[0],r,s,a.output.dims,o.output.dims);return[e.run(Object.assign(Object.assign({},c),{cacheHint:n.cacheKey,get:()=>m}),[t[0],i,h])]},d=(e,t,n,r,s)=>{const[o,l]=e.calculateTextureWidthAndHeight(t.dims,i.TextureType.unpacked),c=s.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==s.length)throw new Error("Dimensionality of the output should be 1");if(s[0]!==n)throw new Error("Shape of the output should be equal to logical row count");const h=(0,a.getGlsl)(e.session.backend.glContext.version),d=`\n      float process(int[${c}] indices) {\n        int logical_row_start_offset = indices[0] * ${r};\n\n        float max = getColorAsFloat(${h.texture2D}(A, offsetToCoords(logical_row_start_offset, ${o},\n        ${l} )));\n        for(int i=1; i<${r}; ++i)\n        {\n          float current = getColorAsFloat(${h.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${o}, ${l})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;return Object.assign(Object.assign({},u),{output:{dims:s,type:t.type,textureType:i.TextureType.unpacked},shaderSource:d})},p=(e,t,n,r,s,o)=>{const[u,c]=e.calculateTextureWidthAndHeight(t.dims,i.TextureType.unpacked),h=o.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==o.length)throw new Error("Dimensionality of the output should be 1");if(o[0]!==n)throw new Error("Shape of the output should be equal to logical row count");if(1!==s.length)throw new Error("Dimensionality of the intermediate results should be 1");if(s[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");const d=`\n      float process(int[${h}] indices) {\n        int logical_row_start_offset = indices[0] * ${r};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${r}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${(0,a.getGlsl)(e.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${u}, ${c}))) - max);\n        }\n\n        return norm_factor;\n      }`;return Object.assign(Object.assign({},l),{output:{dims:o,type:t.type,textureType:i.TextureType.unpacked},shaderSource:d})},f=(e,t,n,r,s,a)=>{const[o,u]=e.calculateTextureWidthAndHeight(t.dims,i.TextureType.unpacked),l=t.dims.length;if(n<1||r<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==s.length||1!==a.length)throw new Error("Dimensionality of the intermediate results should be 1");if(s[0]!==n||a[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");const h=`\n      float process(int[${l}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${o}, ${u});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${r};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;return Object.assign(Object.assign({},c),{output:{dims:t.dims,type:t.type,textureType:i.TextureType.unpacked},shaderSource:h})},m=e=>{if(!e||1!==e.length)throw new Error("Softmax requires 1 input.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type")}},5975:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSplitAttributes=t.split=void 0;const r=n(246),s=n(2517),a=n(2039),i={name:"Split",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};t.split=(e,t,n)=>{l(t);const r=s.ShapeUtil.normalizeAxis(n.axis,t[0].dims.length),a=o(e,t,r,n),c=[];for(let s=0;s<a;++s)c.push(e.run(Object.assign(Object.assign({},i),{cacheHint:`${n.cacheKey};${s}`,get:()=>u(e,t[0],n,r,s)}),t));return c},t.parseSplitAttributes=e=>{const t=e.attributes.getInt("axis",0),n=e.attributes.getInts("split",[]),s=e.outputs.length;return(0,r.createAttributeWithCacheKey)({axis:t,split:n,numOutputs:s})};const o=(e,t,n,r)=>{const[,a]=s.SplitUtil.splitShape(t[0].dims,n,r.split,r.numOutputs);return a.length},u=(e,t,n,r,o)=>{const[u,l]=s.SplitUtil.splitShape(t.dims,r,n.split,n.numOutputs),c=l[o],h=u[o],d=`\n      float process(int indices[${h.length}]) {\n        indices[${r}] += ${c};\n        return _A(indices);\n      }\n    `;return Object.assign(Object.assign({},i),{cacheHint:`${n.cacheKey}:${o}`,output:{dims:h,type:t.type,textureType:a.TextureType.unpacked},shaderSource:d})},l=e=>{if(!e||1!==e.length)throw new Error("Split requires one input.");if("int8"!==e[0].type&&"uint8"!==e[0].type&&"int16"!==e[0].type&&"uint16"!==e[0].type&&"int32"!==e[0].type&&"uint32"!==e[0].type&&"float32"!==e[0].type&&"float64"!==e[0].type&&"bool"!==e[0].type)throw new Error("Invalid input type.")}},3933:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSqueezeAttributes=t.squeezeV13=t.squeeze=void 0;const r=n(2517);t.squeeze=(e,t,n)=>{s(t);const a=r.ShapeUtil.squeezeShape(t[0].dims,n);return[e.reshapeUnpacked(t[0],a)]},t.squeezeV13=(e,n)=>(a(n),(0,t.squeeze)(e,[n[0]],Array.from(n[1].integerData))),t.parseSqueezeAttributes=e=>e.attributes.getInts("axes");const s=e=>{if(!e||1!==e.length)throw new Error("Squeeze requires 1 input.");if("string"===e[0].type)throw new Error("invalid input tensor types.")},a=e=>{if(!e||2!==e.length)throw new Error("Squeeze requires 2 inputs.");if("int32"!==e[1].type)throw new Error("Invalid input type.")}},6558:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.sum=void 0;const r=n(5060),s=n(2039);t.sum=(e,t)=>{i(t);const n={name:"Sum",inputNames:t.map((e,t)=>`X${t}`),inputTypes:new Array(t.length).fill(s.TextureType.unpacked)};return[e.run(Object.assign(Object.assign({},n),{get:()=>a(e,t,n)}),t)]};const a=(e,t,n)=>{const a=(0,r.getGlsl)(e.session.backend.glContext.version),i=t[0].dims.slice(),o=`\n      void main() {\n        vec4 result = ${t.map((e,t)=>`${a.texture2D}(X${t},TexCoords)`).join(" + ")};\n        ${a.output} = result;\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:i,type:t[0].type,textureType:s.TextureType.unpacked},hasMain:!0,shaderSource:o})},i=e=>{if(!e||0===e.length)throw new Error("Sum requires inputs.");const t=e[0].dims.length;for(let n=1;n<e.length;n++){if(t!==e[n].dims.length)throw new Error("Input shapes are mismatched.");for(let r=0;r<t;r++)if(e[0].dims[r]!==e[n].dims[r])throw new Error("Input shapes are not matched.")}if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.");for(let t=1;t<e.length;t++)if(e[0].type!==e[t].type)throw new Error("Input types are not matched.")}},5723:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.tile=void 0;const r=n(782),s=n(2039);t.tile=(e,t)=>{i(t);const n={name:"Tile",inputNames:["A"],inputTypes:[s.TextureType.unpacked]};return[e.run(Object.assign(Object.assign({},n),{get:()=>a(e,t,n)}),t)]};const a=(e,t,n)=>{const r=t[0].dims.slice(),a=new Array(r.length),i=[];for(let e=0;e<r.length;e++)a[e]=r[e]*t[1].numberData[e],i.push(`inputIdx[${e}] = int(mod(float(outputIdx[${e}]), ${r[e]}.));`);const o=a.length,u=`\n      float process(int outputIdx[${o}]) {\n        int inputIdx[${o}];\n        ${i.join("\n")}\n        return _A(inputIdx);\n      }\n    `;return Object.assign(Object.assign({},n),{output:{dims:a,type:t[0].type,textureType:s.TextureType.unpacked},shaderSource:u})},i=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 input.");if(1!==e[1].dims.length)throw new Error("The second input shape must 1 dimension.");if(e[1].dims[0]!==e[0].dims.length)throw new Error("Invalid input shape.");if(-1===r.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invalid input type.");if("int32"!==e[1].type&&"int16"!==e[1].type)throw new Error("Invalid repeat type.")}},3738:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseTransposeAttributes=t.transpose=void 0;const r=n(246),s=n(2517),a=n(2039),i={name:"Transpose",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};t.transpose=(e,t,n)=>(h(t),[e.run(Object.assign(Object.assign({},i),{cacheHint:n.cacheKey,get:()=>o(e,t[0],n.perm)}),t)]),t.parseTransposeAttributes=e=>(0,r.createAttributeWithCacheKey)({perm:e.attributes.getInts("perm",[])});const o=(e,t,n)=>{const r=t.dims;n=u(r,n);const s=l(r,n),o=r.length,h=`\n      ${c("perm",n,o)}\n      float process(int indices[${o}]) {\n        int a[${o}];\n        perm(a, indices);\n        return _A(a);\n      }`;return Object.assign(Object.assign({},i),{output:{dims:s,type:t.type,textureType:a.TextureType.unpacked},shaderSource:h})},u=(e,t)=>(t&&t.length!==e.length&&(t=[...e.keys()].reverse()),t),l=(e,t)=>(t=u(e,t),s.ShapeUtil.sortBasedOnPerm(e,t)),c=(e,t,n)=>{const r=[];r.push(`void ${e}(out int a[${n}], int src[${n}]) {`);for(let e=0;e<n;++e)r.push(`\ta[${t[e]}]=src[${e}];`);return r.push("\t}"),r.join("\n")},h=e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("input should be float tensor")}},8710:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.encodeAsUint8=void 0;const r=n(5060),s=n(2039);t.encodeAsUint8=(e,t)=>{const n=t.shape,a=(0,r.getGlsl)(e.session.backend.glContext.version),i=`\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${a.texture2D}(X,TexCoords).r;\n      ${a.output} = encodeAsUint8(value);\n    }`,o={name:"Uint8Encode",inputTypes:[s.TextureType.unpacked],inputNames:["X"],output:{dims:n,type:t.tensor.type,textureType:s.TextureType.downloadUint8AsFloat},shaderSource:i,hasMain:!0};return e.executeProgram(o,[t.tensor])}},4909:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.tanh=t.tan=t.sqrt=t.sin=t.sigmoid=t.relu=t.not=t.neg=t.log=t.parseLeakyReluAttributes=t.leakyRelu=t.identity=t.floor=t.exp=t.parseEluAttributes=t.elu=t.cos=t.ceil=t.clipV11=t.parseClipAttributes=t.clip=t.atan=t.asin=t.acos=t.abs=t.glslTanh=t.glslTan=t.glslSqrt=t.glslSigmoid=t.glslRelu=t.glslSin=t.glslNot=t.glslNeg=t.glslLog=t.glslLeakyRelu=t.glslIdentity=t.glslClip=t.glslFloor=t.glslExp=t.glslElu=t.glslCos=t.glslCeil=t.glslAtan=t.glslAsin=t.glslAcos=t.glslAbs=void 0;const r=n(246),s=n(2517),a=n(8520),i=n(5060),o=n(2039);function u(){return $("abs")}function l(){return $("acos")}function c(){return $("asin")}function h(){return $("atan")}function d(){return $("ceil")}function p(){return $("cos")}function f(e){const t="elu";return{body:`\n  const float alpha = float(${e});\n\n  float ${t}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(${t}_(v.x), ${t}_(v.y), ${t}_(v.z), ${t}_(v.w));\n  }\n  `,name:t,type:a.FunctionType.ValueBased}}function m(){return $("exp")}function g(){return $("floor")}function b(e,t){const n="clip";return{body:`\n  const float min = float(${e});\n  const float max = float(${t});\n\n  float ${n}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${n}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `,name:n,type:a.FunctionType.ValueBased}}function y(){const e="indentity";return{body:`\n  float ${e}_(float a) {\n    return a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return v;\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function x(e){const t="leakyRelu";return{body:`\n  const float alpha = float(${e});\n\n  float ${t}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(${t}_(v.x), ${t}_(v.y), ${t}_(v.z), ${t}_(v.w));\n  }\n  `,name:t,type:a.FunctionType.ValueBased}}function w(){return $("log")}function v(){const e="neg";return{body:`\n  float ${e}_(float a) {\n    return -a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return -v;\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function _(){const e="not";return{body:`\n  float ${e}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${e}_(bool a) {\n    return !a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${e}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function k(){return $("sin")}function T(){const e="relu";return{body:`\n  float ${e}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${e}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function S(){const e="sigmoid";return{body:`\n  float ${e}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${e}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function I(){return $("sqrt")}function N(){return $("tan")}function E(){const e="tanh";return{body:`\n  float ${e}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${e}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function $(e){return{body:`\n  float ${e}_(float a) {\n    return ${e}(a);\n  }\n  vec4 ${e}_(vec4 v) {\n    return ${e}(v);\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}t.glslAbs=u,t.glslAcos=l,t.glslAsin=c,t.glslAtan=h,t.glslCeil=d,t.glslCos=p,t.glslElu=f,t.glslExp=m,t.glslFloor=g,t.glslClip=b,t.glslIdentity=y,t.glslLeakyRelu=x,t.glslLog=w,t.glslNeg=v,t.glslNot=_,t.glslSin=k,t.glslRelu=T,t.glslSigmoid=S,t.glslSqrt=I,t.glslTan=N,t.glslTanh=E;const A=(e,t,n,r)=>{const s=e.session.pack?o.TextureType.packed:o.TextureType.unpacked,a={name:n.name,inputTypes:[s],inputNames:["A"],cacheHint:r};return Object.assign(Object.assign({},a),{get:()=>((e,t,n,r)=>{const s=e.session.pack?o.TextureType.packed:o.TextureType.unpacked,a=(0,i.getGlsl)(e.session.backend.glContext.version);return Object.assign(Object.assign({},t),{output:{dims:n.dims,type:n.type,textureType:s},shaderSource:`\n     ${r.body}\n     void main() {\n       vec4 v = ${a.texture2D}(A, TexCoords);\n       v = ${r.name}_(v);\n       ${a.output} = v;\n     }\n     `,hasMain:!0})})(e,a,t,n)})};t.abs=(e,t)=>[e.run(A(e,t[0],u()),t)],t.acos=(e,t)=>[e.run(A(e,t[0],l()),t)],t.asin=(e,t)=>[e.run(A(e,t[0],c()),t)],t.atan=(e,t)=>[e.run(A(e,t[0],h()),t)],t.clip=(e,t,n)=>[e.run(A(e,t[0],b(n.min,n.max),n.cacheKey),t)],t.parseClipAttributes=e=>(0,r.createAttributeWithCacheKey)({min:e.attributes.getFloat("min",s.MIN_CLIP),max:e.attributes.getFloat("max",s.MAX_CLIP)}),t.clipV11=(e,n)=>{const r=C(e,n);return(0,t.clip)(e,[n[0]],r)};const C=(e,t)=>{if(t.length>=3&&(!e.session.isInitializer(t[1].dataId)||!e.session.isInitializer(t[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const n=t.length>=3?t[1].numberData[0]:s.MIN_CLIP,a=t.length>=3?t[2].numberData[0]:s.MAX_CLIP;return(0,r.createAttributeWithCacheKey)({min:n,max:a})};t.ceil=(e,t)=>[e.run(A(e,t[0],d()),t)],t.cos=(e,t)=>[e.run(A(e,t[0],p()),t)],t.elu=(e,t,n)=>[e.run(A(e,t[0],f(n.alpha),n.cacheKey),t)],t.parseEluAttributes=e=>(0,r.createAttributeWithCacheKey)({alpha:e.attributes.getFloat("alpha",1)}),t.exp=(e,t)=>[e.run(A(e,t[0],m()),t)],t.floor=(e,t)=>[e.run(A(e,t[0],g()),t)],t.identity=(e,t)=>[e.run(A(e,t[0],y()),t)],t.leakyRelu=(e,t,n)=>[e.run(A(e,t[0],x(n.alpha),n.cacheKey),t)],t.parseLeakyReluAttributes=e=>(0,r.createAttributeWithCacheKey)({alpha:e.attributes.getFloat("alpha",.01)}),t.log=(e,t)=>[e.run(A(e,t[0],w()),t)],t.neg=(e,t)=>[e.run(A(e,t[0],v()),t)],t.not=(e,t)=>[e.run(A(e,t[0],_()),t)],t.relu=(e,t)=>[e.run(A(e,t[0],T()),t)],t.sigmoid=(e,t)=>[e.run(A(e,t[0],S()),t)],t.sin=(e,t)=>[e.run(A(e,t[0],k()),t)],t.sqrt=(e,t)=>[e.run(A(e,t[0],I()),t)],t.tan=(e,t)=>[e.run(A(e,t[0],N()),t)],t.tanh=(e,t)=>[e.run(A(e,t[0],E()),t)]},5611:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createUnpackProgramInfoLoader=t.createUnpackProgramInfo=void 0;const r=n(5060),s=n(2039),a=n(9390),i=n(2827),o={name:"unpack",inputNames:["A"],inputTypes:[s.TextureType.packed]};t.createUnpackProgramInfo=(e,t)=>{const n=t.dims.length,u=(0,i.getChannels)("rc",n),l=u.slice(-2),c=(0,a.getCoordsDataType)(n),h=(0,i.unpackFromChannel)(),d=0===t.dims.length?"":function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(n,u),p=n<=1?"rc":`vec2(${l.join(",")})`,f=`\n    ${h}\n    void main() {\n      ${c} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${d});\n\n       ${(0,r.getGlsl)(e.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${p}), 0, 0, 0);\n     }\n   `;return Object.assign(Object.assign({},o),{hasMain:!0,output:{dims:t.dims,type:t.type,textureType:s.TextureType.unpacked},shaderSource:f})},t.createUnpackProgramInfoLoader=(e,n)=>Object.assign(Object.assign({},o),{get:()=>(0,t.createUnpackProgramInfo)(e,n)})},8428:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseUnsqueezeAttributes=t.unsqueezeV13=t.unsqueeze=void 0;const r=n(2517);t.unsqueeze=(e,t,n)=>{s(t);const a=r.ShapeUtil.unsqueezeShape(t[0].dims,n);return[e.reshapeUnpacked(t[0],a)]},t.unsqueezeV13=(e,n)=>(a(n),(0,t.unsqueeze)(e,[n[0]],Array.from(n[1].integerData))),t.parseUnsqueezeAttributes=e=>e.attributes.getInts("axes");const s=e=>{if(!e||1!==e.length)throw new Error("Unsqueeze requires 1 input.");if("string"===e[0].type)throw new Error("invalid input tensor types.")},a=e=>{if(!e||2!==e.length)throw new Error("Unsqueeze requires 2 inputs.");if("int32"!==e[1].type)throw new Error("Invalid input type.")}},9793:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.scalesValidation=t.validateInputs=t.parseUpsampleAttributes=t.parseUpsampleAttributesV9=t.parseUpsampleAttributesV7=t.upsample=void 0;const r=n(246),s=n(5060),a=n(2039),i={name:"Upsample",inputNames:["X"],inputTypes:[a.TextureType.unpacked]};t.upsample=(e,n,r)=>((0,t.validateInputs)(n,r),[e.run(Object.assign(Object.assign({},i),{cacheHint:r.cacheKey,get:()=>o(e,n,r)}),n)]),t.parseUpsampleAttributesV7=e=>(0,t.parseUpsampleAttributes)(e,7),t.parseUpsampleAttributesV9=e=>(0,t.parseUpsampleAttributes)(e,9),t.parseUpsampleAttributes=(e,n)=>{const s=n>=10,a=e.attributes.getString("mode","nearest");if("nearest"!==a&&"linear"!==a&&(n<11||"cubic"!==a))throw new Error(`unrecognized mode: ${a}`);let i=[];n<9&&(i=e.attributes.getFloats("scales"),(0,t.scalesValidation)(i,a,s));const o=e.attributes.getFloat("extrapolation_value",0),u=n>10?e.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(-1===["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(u))throw new Error(`coordinate_transform_mode '${u}' is not supported`);const l="tf_crop_and_resize"===u,c=l,h="nearest"===a&&n>=11?e.attributes.getString("nearest_mode","round_prefer_floor"):"";if(-1===["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(h))throw new Error(`nearest_mode '${h}' is not supported`);const d=e.attributes.getFloat("cubic_coeff_a",-.75),p=0!==e.attributes.getInt("exclude_outside",0);if(p&&"cubic"!==a)throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const f=n<11||"nearest"===a&&"asymmetric"===u&&"floor"===h;let m=0,g=0,b=0;return n>10?e.inputs.length>2?(m=1,g=2,b=3):(g=1,b=2):9===n&&(g=1),(0,r.createAttributeWithCacheKey)({opset:n,isResize:s,mode:a,scales:i,extrapolationValue:o,coordinateTransformMode:u,useExtrapolation:c,needRoiInput:l,nearestMode:h,cubicCoefficientA:d,excludeOutside:p,useNearest2xOptimization:f,roiInputIdx:m,scalesInputIdx:g,sizesInputIdx:b})};const o=(e,t,n)=>{const r=(0,s.getGlsl)(e.session.backend.glContext.version),[o,u]=e.calculateTextureWidthAndHeight(t[0].dims,a.TextureType.unpacked),l=t[0].dims.map((e,t)=>Math.floor(e*n.scales[t])),[c,h]=e.calculateTextureWidthAndHeight(l,a.TextureType.unpacked),d=l.length,p=new Array(d),f=new Array(d);let m=`\n      int output_pitches[${d}];\n      int input_pitches[${d}];\n      `;for(let e=d-1;e>=0;e--)p[e]=e===d-1?1:p[e+1]*l[e+1],f[e]=e===d-1?1:f[e+1]*t[0].dims[e+1],m+=`\n        output_pitches[${e}] = ${p[e]};\n        input_pitches[${e}] = ${f[e]};\n        `;const g=`\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${o}, ${u});\n        float value = getColorAsFloat(${r.texture2D}(X, coords));\n        return value;\n      }\n      `,b="nearest"===n.mode?`\n    ${g}\n    float process(int indices[${d}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${c}, ${h});\n\n      ${m}\n\n      int d, m;\n      for (int dim = 0; dim < ${d}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }`:4===d?`\n    ${g}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${c}, ${h});\n\n      ${m}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${t[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }`:`\n    ${g}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${c}, ${h});\n\n      ${m}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${t[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;return Object.assign(Object.assign({},i),{output:{dims:l,type:t[0].type,textureType:a.TextureType.unpacked},shaderSource:b,variables:[{name:"scales",type:"int",arrayLength:n.scales.length,data:n.scales.map(e=>Math.ceil(e))}]})};t.validateInputs=(e,t)=>{if(!e||t.opset<9&&1!==e.length||t.opset>=9&&t.opset<11&&2!==e.length||t.opset>=11&&e.length<2)throw new Error("invalid inputs.");if(t.scales.length>0&&e[0].dims.length!==t.scales.length)throw new Error("Invalid input shape.");if("string"===e[0].type)throw new Error("Invalid input tensor types.")},t.scalesValidation=(e,t,n)=>{if(n){for(const t of e)if(t<=0)throw new Error("Scale value should be greater than 0.")}else for(const t of e)if(t<1)throw new Error("Scale value should be greater than or equal to 1.");if(!("linear"!==t&&"cubic"!==t||2===e.length||4===e.length&&1===e[0]&&1===e[1]))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n?"Resize":"Upsample"} opeartor.`)}},1958:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ProgramManager=void 0;const r=n(1670),s=n(6231),a=n(8879),i=n(5060);t.ProgramManager=class{constructor(e,t,n){this.profiler=e,this.glContext=t,this.textureLayoutStrategy=n,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n){var r;this.profiler.event("op",`ProgramManager.run ${null!==(r=e.programInfo.name)&&void 0!==r?r:"unknown kernel"}`,()=>{var r;const a=this.glContext.gl,i=e.program;a.useProgram(i);try{this.bindOutput(n),this.attributesBound||this.bindAttributes(e.attribLocations),this.bindUniforms(e.uniformLocations,null!==(r=e.programInfo.variables)&&void 0!==r?r:[],t)}catch(t){throw s.Logger.error("ProgramManager",e.programInfo.shaderSource),t}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(e=>this.glContext.deleteProgram(e.program))}build(e,t,n){return this.profiler.event("backend","ProgramManager.build",()=>{const r=new a.GlslPreprocessor(this.glContext,e,t,n),s=r.preprocess(),i=this.compile(s);return{programInfo:e,program:i,uniformLocations:this.getUniformLocations(i,r.context.programInfo.inputNames,r.context.programInfo.variables),attribLocations:this.getAttribLocations(i)}})}compile(e){if(!this.vertexShader){s.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const e=(0,i.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(e,this.glContext.gl.VERTEX_SHADER)}r.env.debug&&s.Logger.verbose("ProrgramManager",`FragShader:\n${e}\n`);const t=this.glContext.compileShader(e,this.glContext.gl.FRAGMENT_SHADER),n=this.glContext.createProgram(this.vertexShader,t);return this.glContext.deleteShader(t),n}bindOutput(e){const t=e.width,n=e.height;s.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${t}/${n}, shape=${e.shape}, type=${e.tensor.type}`),this.glContext.attachFramebuffer(e.texture,t,n)}bindAttributes(e){const t=e.position,n=e.textureCoord;this.glContext.setVertexAttributes(t,n),this.attributesBound=!0}bindUniforms(e,t,n){var r;const s=this.glContext.gl;let a=0;for(const{name:i,type:o,location:u,arrayLength:l}of e){const e=null===(r=t.find(e=>e.name===i))||void 0===r?void 0:r.data;if("sampler2D"!==o&&!e)throw new Error(`variable '${i}' does not have data defined in program info`);switch(o){case"sampler2D":this.bindTexture(n[a],u,a),a++;break;case"float":l?s.uniform1fv(u,e):s.uniform1f(u,e);break;case"int":l?s.uniform1iv(u,e):s.uniform1i(u,e);break;default:throw new Error(`Uniform not implemented: ${o}`)}}}bindTexture(e,t,n){this.glContext.bindTextureToUniform(e.texture,n,t)}getAttribLocations(e){return{position:this.getAttribLocation(e,"position"),textureCoord:this.getAttribLocation(e,"textureCoord")}}getUniformLocations(e,t,n){const r=[];if(t)for(const n of t)r.push({name:n,type:"sampler2D",location:this.getUniformLocation(e,n)});if(n)for(const t of n)r.push(Object.assign(Object.assign({},t),{location:this.getUniformLocation(e,t.name)}));return r}getUniformLocation(e,t){const n=this.glContext.gl.getUniformLocation(e,t);if(null===n)throw new Error(`Uniform ${t} not found.`);return n}getAttribLocation(e,t){return this.glContext.gl.getAttribLocation(e,t)}}},6416:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLSessionHandler=void 0;const r=n(6231),s=n(1047),a=n(8316),i=n(1640),o=n(1958),u=n(7859),l=n(5702);t.WebGLSessionHandler=class{constructor(e,t){this.backend=e,this.context=t,this.layoutStrategy=new u.PreferLogicalStrategy(e.glContext.maxTextureSize),this.programManager=new o.ProgramManager(this.context.profiler,e.glContext,this.layoutStrategy),this.textureManager=new l.TextureManager(e.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:"full"===e.textureCacheMode}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=e.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new a.WebGLInferenceHandler(this)}onGraphInitialized(e){const t=e.getValues().filter(e=>-1===e.from&&e.tensor).map(e=>e.tensor.dataId);this.initializers=new Set(t)}isInitializer(e){return!!this.initializers&&this.initializers.has(e)}addInitializer(e){this.initializers.add(e)}getTextureData(e,t){return t?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,t,n=!1){r.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),n?this.packedTextureDataCache.set(e,t):this.unpackedTextureDataCache.set(e,t)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.unpackedTextureDataCache=new Map}resolve(e,t,n){const r=(0,s.resolveOperator)(e,t,i.WEBGL_OP_RESOLVE_RULES);return{impl:r.opImpl,context:r.opInit?r.opInit(e,n):e}}}},7769:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Uint8DataEncoder=t.RGBAFloatDataEncoder=t.RedFloat32DataEncoder=void 0;const r=n(6231);t.RedFloat32DataEncoder=class{constructor(e,t=1){if(1===t)this.internalFormat=e.R32F,this.format=e.RED,this.textureType=e.FLOAT,this.channelSize=t;else{if(4!==t)throw new Error(`Invalid number of channels: ${t}`);this.internalFormat=e.RGBA32F,this.format=e.RGBA,this.textureType=e.FLOAT,this.channelSize=t}}encode(e,t){let n,s;return e.constructor!==Float32Array&&(r.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),s=new Float32Array(e)),t*this.channelSize>e.length?(r.Logger.warning("Encoder","Source data too small. Allocating larger array"),s=e,n=this.allocate(t*this.channelSize),s.forEach((e,t)=>n[t]=e)):(s=e,n=s),n}allocate(e){return new Float32Array(4*e)}decode(e,t){return 1===this.channelSize?e.filter((e,t)=>t%4==0).subarray(0,t):e.subarray(0,t)}},t.RGBAFloatDataEncoder=class{constructor(e,t=1,n){if(1!==t&&4!==t)throw new Error(`Invalid number of channels: ${t}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.channelSize=t,this.textureType=n||e.FLOAT}encode(e,t){let n=e;return 1===this.channelSize&&(r.Logger.verbose("Encoder","Exploding into a larger array"),n=this.allocate(t),e.forEach((e,t)=>n[4*t]=e)),n}allocate(e){return new Float32Array(4*e)}decode(e,t){return 1===this.channelSize?e.filter((e,t)=>t%4==0).subarray(0,t):e.subarray(0,t)}},t.Uint8DataEncoder=class{constructor(e,t=1){if(this.channelSize=4,1===t)this.internalFormat=e.ALPHA,this.format=e.ALPHA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=t;else{if(4!==t)throw new Error(`Invalid number of channels: ${t}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=t}}encode(e,t){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}allocate(e){return new Uint8Array(e*this.channelSize)}decode(e,t){if(e instanceof Uint8Array)return e.subarray(0,t);throw new Error(`Invalid array type: ${e.constructor}`)}}},7859:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getBatchDim=t.sizeToSquarishShape=t.getRowsCols=t.sizeFromShape=t.isInt=t.parseAxisParam=t.squeezeShape=t.PreferLogicalStrategy=t.AlwaysKeepOriginalSizeStrategy=void 0;const r=n(6231),s=n(2517);function a(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:i(t,e).sort();let o=0;for(let t=0;t<e.length;++t){if(null!=a){if(a[o]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==a[o]||a[o]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),a[o]<=t&&o++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function i(e,t){const n=t.length;return e=null==e?t.map((e,t)=>t):[].concat(e),(0,s.assert)(e.every(e=>e>=-n&&e<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),(0,s.assert)(e.every(o),()=>`All values in axis param must be integers but got axis ${e}`),e.map(e=>e<0?n+e:e)}function o(e){return e%1==0}function u(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function l(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}t.AlwaysKeepOriginalSizeStrategy=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,t){if(0===e.length)return[1,1];const n=this.maxTextureSize;if(t&&void 0!==t.breakAxis){const s=t.breakAxis>=e.length?1:e.slice(t.breakAxis).reduce((e,t)=>e*t),a=t.breakAxis<=0?1:e.slice(0,t.breakAxis).reduce((e,t)=>e*t);if(!(s>n||a>n))return[s,a];r.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${t.breakAxis}`)}const s=e.reduce((e,t)=>e*t);let a=Math.floor(Math.sqrt(s));for(;a<n&&a<s&&s%a!=0;a++);if(a>=n||s%a!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${e}`);return[a,s/a]}},t.PreferLogicalStrategy=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,t){const n=this.computeTexture(e,t);return t&&t.isPacked&&(n[0]/=2,n[1]/=2),t&&t.reverseWH?[n[1],n[0]]:n}computeTexture(e,t){const n=t&&t.isPacked;if(0===e.length)return n?[2,2]:[1,1];let s=this.maxTextureSize;if(t&&void 0!==t.breakAxis){const n=t.breakAxis>=e.length?1:e.slice(t.breakAxis).reduce((e,t)=>e*t),a=t.breakAxis<=0?1:e.slice(0,t.breakAxis).reduce((e,t)=>e*t);if(!(n>s||a>s))return[n,a];r.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${t.breakAxis}`)}let i=e.slice(0);if(n&&(s*=2,i=i.map((e,t)=>t>=i.length-2?i[t]%2==0?i[t]:i[t]+1:i[t]),1===i.length&&(i=[2,i[0]])),2!==i.length){const e=a(i);i=e.newShape}const o=u(i);return i.length<=1&&o<=s?[1,o]:2===i.length&&i[0]<=s&&i[1]<=s?i:3===i.length&&i[0]*i[1]<=s&&i[2]<=s?[i[0]*i[1],i[2]]:3===i.length&&i[0]<=s&&i[1]*i[2]<=s?[i[0],i[1]*i[2]]:4===i.length&&i[0]*i[1]*i[2]<=s&&i[3]<=s?[i[0]*i[1]*i[2],i[3]]:4===i.length&&i[0]<=s&&i[1]*i[2]*i[3]<=s?[i[0],i[1]*i[2]*i[3]]:n?l(o/4).map(e=>2*e):l(o)}},t.squeezeShape=a,t.parseAxisParam=i,t.isInt=o,t.sizeFromShape=u,t.getRowsCols=function(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]},t.sizeToSquarishShape=l,t.getBatchDim=function(e,t=2){return u(e.slice(0,e.length-t))}},4057:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createTextureLayoutFromShape=t.calculateTextureWidthAndHeight=t.createTextureLayoutFromTextureType=void 0;const r=n(2517),s=n(2039);t.createTextureLayoutFromTextureType=(e,n,r)=>{const a=r===s.TextureType.unpacked||r===s.TextureType.unpackedReversed?1:4,i=r===s.TextureType.packed,o=r===s.TextureType.unpackedReversed||r===s.TextureType.packed,u=r===s.TextureType.packedLastDimension?n.length-1:void 0,l=r===s.TextureType.packedLastDimension?n.map((e,t)=>t===n.length-1?4*e:e):void 0;return(0,t.createTextureLayoutFromShape)(e,n,a,l,{isPacked:i,reverseWH:o,breakAxis:u})},t.calculateTextureWidthAndHeight=(e,n,r)=>{const s=(0,t.createTextureLayoutFromTextureType)(e,n,r);return[s.width,s.height]},t.createTextureLayoutFromShape=(e,t,n=1,s,a)=>{const i=!(!a||!a.isPacked),[o,u]=e.computeTextureWH(i&&s||t,a),l=t.length;let c=t.slice(0);if(0===l&&(c=[1]),1===n)s=t;else if(i){if(4!==n)throw new Error("a packed texture must be 4-channel");s=t,l>0&&(c[l-1]=Math.ceil(c[l-1]/2)),l>1&&(c[l-2]=Math.ceil(c[l-2]/2))}else if(!s)throw new Error("Unpacked shape is needed when using channels > 1");return{width:o,height:u,channels:n,isPacked:i,shape:c,strides:r.ShapeUtil.computeStrides(c),unpackedShape:s,reversedWH:a&&a.reverseWH}}},5702:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.TextureManager=void 0;const r=n(6231);t.TextureManager=class{constructor(e,t,n,r){this.glContext=e,this.layoutStrategy=t,this.profiler=n,this.config=r,this.pendingRead=new Map,r.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(e,t,n,s){const a=this.toEncoderType(e),i=this.glContext.getEncoder(a,t.channels||1,s);if(t.isPacked&&1===s)throw new Error("not implemented");const o=t.width,u=t.height;let l,c;if(this.config.reuseTextures){l=`${o}x${u}_${i.format}_${i.internalFormat}_${i.textureType}`,c=this.inUseTextures.get(l),c||(c=[],this.inUseTextures.set(l,c));const t=this.idleTextures.get(l);if(t&&t.length>0){const r=t.pop();return c.push(r),1===s&&this.glContext.updateTexture(r,o,u,i,this.toTextureData(e,n)),r}}r.Logger.verbose("TextureManager",`Creating new texture of size ${t.width}x${t.height}`);const h=this.glContext.allocateTexture(o,u,i,this.toTextureData(e,n));return this.config.reuseTextures&&(c.push(h),this.textureLookup.set(h,l)),h}readTexture(e,t,n){return n||(n=1),this.profiler.event("backend","TextureManager.readTexture",()=>{const r=e.shape.reduce((e,t)=>e*t)*n,s=this.glContext.readTexture(e.texture,e.width,e.height,r,this.toEncoderType(t),n);return this.toTensorData(t,s)})}async readTextureAsync(e,t,n){const r=e.tensor.dataId;if(n||(n=1),this.pendingRead.has(r)){const e=this.pendingRead.get(r);return new Promise(t=>null==e?void 0:e.push(t))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(r,[]);const s=e.shape.reduce((e,t)=>e*t)*n;await this.glContext.createAndWaitForFence();const a=this.glContext.readTexture(e.texture,e.width,e.height,s,this.toEncoderType(t),n),i=this.toTensorData(t,a),o=this.pendingRead.get(r);return this.pendingRead.delete(r),null==o||o.forEach(e=>e(i)),i})}readUint8TextureAsFloat(e){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{const t=e.shape.reduce((e,t)=>e*t),n=this.glContext.readTexture(e.texture,e.width,e.height,4*t,"byte",4);return new Float32Array(n.buffer,n.byteOffset,t)})}releaseTexture(e,t){let n;if(this.config.reuseTextures&&(n=this.textureLookup.get(e.texture),n)){t&&this.textureLookup.delete(n);const r=this.inUseTextures.get(n);if(r){const t=r.indexOf(e.texture);if(-1!==t){r.splice(t,1);let s=this.idleTextures.get(n);s||(s=[],this.idleTextures.set(n,s)),s.push(e.texture)}}}n&&!t||(r.Logger.verbose("TextureManager",`Deleting texture of size ${e.width}x${e.height}`),this.glContext.deleteTexture(e.texture))}toTensorData(e,t){switch(e){case"int16":return t instanceof Int16Array?t:Int16Array.from(t);case"int32":return t instanceof Int32Array?t:Int32Array.from(t);case"int8":return t instanceof Int8Array?t:Int8Array.from(t);case"uint16":return t instanceof Uint16Array?t:Uint16Array.from(t);case"uint32":return t instanceof Uint32Array?t:Uint32Array.from(t);case"uint8":case"bool":return t instanceof Uint8Array?t:Uint8Array.from(t);case"float32":return t instanceof Float32Array?t:Float32Array.from(t);case"float64":return t instanceof Float64Array?t:Float64Array.from(t);default:throw new Error(`TensorData type ${e} is not supported`)}}toTextureData(e,t){if(t)return t instanceof Float32Array?t:new Float32Array(t)}toEncoderType(e){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},2039:(e,t)=>{"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),t.TextureType=void 0,(n=t.TextureType||(t.TextureType={}))[n.unpacked=0]="unpacked",n[n.unpackedReversed=1]="unpackedReversed",n[n.packed=2]="packed",n[n.downloadUint8AsFloat=3]="downloadUint8AsFloat",n[n.packedLastDimension=4]="packedLastDimension"},9390:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getGlChannels=t.getCoordsDataType=t.getSqueezedParams=t.squeezeInputShape=t.generateShaderFuncNameFromInputSamplerNameAtOutCoords=t.generateShaderFuncNameFromInputSamplerName=t.repeatedTry=t.getPackedShape=void 0;const r=n(2517);t.getPackedShape=function(e){const t=e.length;return e.slice(0,t-1).concat(e[t-1]/4)},t.repeatedTry=async function(e,t=e=>0,n){return new Promise((r,s)=>{let a=0;const i=()=>{if(e())return void r();a++;const o=t(a);null!=n&&a>=n?s():setTimeout(i,o)};i()})},t.generateShaderFuncNameFromInputSamplerName=function(e){return(0,r.assert)(void 0!==e&&0!==e.length,()=>"empty string found for sampler name"),"get"+e.charAt(0).toUpperCase()+e.slice(1)},t.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(e){return(0,r.assert)(void 0!==e&&0!==e.length,()=>"empty string found for sampler name"),"get"+e.charAt(0).toUpperCase()+e.slice(1)+"AtOutCoords"},t.squeezeInputShape=function(e,t){let n=JSON.parse(JSON.stringify(e));return n=t,n},t.getSqueezedParams=function(e,t){return t.map(t=>e[t]).join(", ")},t.getCoordsDataType=function(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)},t.getGlChannels=function(e=6){return["x","y","z","w","u","v"].slice(0,e)}},7305:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createNewWebGLContext=t.createWebGLContext=void 0;const r=n(6231),s=n(1713),a={};function i(e){const t=function(){if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas)throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const e=document.createElement("canvas");return e.width=1,e.height=1,e}();let n;const a={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!e||"webgl2"===e)&&(n=t.getContext("webgl2",a),n))try{return new s.WebGLContext(n,2)}catch(e){r.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${e}`)}if((!e||"webgl"===e)&&(n=t.getContext("webgl",a)||t.getContext("experimental-webgl",a),n))try{return new s.WebGLContext(n,1)}catch(e){r.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${e}`)}throw new Error("WebGL is not supported")}t.createWebGLContext=function e(t){let n;t&&"webgl2"!==t||!("webgl2"in a)?t&&"webgl"!==t||!("webgl"in a)||(n=a.webgl):n=a.webgl2,n=n||i(t),t=t||1===n.version?"webgl":"webgl2";const r=n.gl;return a[t]=n,r.isContextLost()?(delete a[t],e(t)):(r.disable(r.DEPTH_TEST),r.disable(r.STENCIL_TEST),r.disable(r.BLEND),r.disable(r.DITHER),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SAMPLE_COVERAGE),r.enable(r.SCISSOR_TEST),r.enable(r.CULL_FACE),r.cullFace(r.BACK),n)},t.createNewWebGLContext=i},1713:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var s=Object.getOwnPropertyDescriptor(t,n);s&&!("get"in s?!t.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,s)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return s(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLContext=t.linearSearchLastTrue=void 0;const i=n(1670),o=a(n(7769)),u=n(9390);function l(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}t.linearSearchLastTrue=l,t.WebGLContext=class{constructor(e,t){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=e,this.version=t,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(e,t,n,r){const s=this.gl,a=s.createTexture();s.bindTexture(s.TEXTURE_2D,a),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MIN_FILTER,s.NEAREST),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_MAG_FILTER,s.NEAREST),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_S,s.CLAMP_TO_EDGE),s.texParameteri(s.TEXTURE_2D,s.TEXTURE_WRAP_T,s.CLAMP_TO_EDGE);const i=r?n.encode(r,e*t):null;return s.texImage2D(s.TEXTURE_2D,0,n.internalFormat,e,t,0,n.format,n.textureType,i),this.checkError(),a}updateTexture(e,t,n,r,s){const a=this.gl;a.bindTexture(a.TEXTURE_2D,e);const i=r.encode(s,t*n);a.texSubImage2D(a.TEXTURE_2D,0,0,0,t,n,r.format,r.textureType,i),this.checkError()}attachFramebuffer(e,t,n){const r=this.gl;r.bindTexture(r.TEXTURE_2D,e),r.bindFramebuffer(r.FRAMEBUFFER,this.framebuffer),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0),this.checkError(),r.viewport(0,0,t,n),r.scissor(0,0,t,n)}readTexture(e,t,n,r,s,a){const i=this.gl;a||(a=1),this.frameBufferBound||this.attachFramebuffer(e,t,n);const o=this.getEncoder(s,a),u=o.allocate(t*n);return i.bindTexture(i.TEXTURE_2D,e),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,e,0),i.readPixels(0,0,t,n,i.RGBA,o.textureType,u),this.checkError(),o.decode(u,r)}isFramebufferReady(){return!0}getActiveTexture(){const e=this.gl;return"TEXTURE"+(e.getParameter(this.gl.ACTIVE_TEXTURE)-e.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(e,t){const n=this.gl;n.vertexAttribPointer(e,3,n.FLOAT,!1,20,0),n.enableVertexAttribArray(e),-1!==t&&(n.vertexAttribPointer(t,2,n.FLOAT,!1,20,12),n.enableVertexAttribArray(t)),this.checkError()}createProgram(e,t){const n=this.gl,r=n.createProgram();return n.attachShader(r,e),n.attachShader(r,t),n.linkProgram(r),r}compileShader(e,t){const n=this.gl,r=n.createShader(t);if(!r)throw new Error(`createShader() returned null with type ${t}`);if(n.shaderSource(r,e),n.compileShader(r),!1===n.getShaderParameter(r,n.COMPILE_STATUS))throw new Error(`Failed to compile shader: ${n.getShaderInfoLog(r)}\nShader source:\n${e}`);return r}deleteShader(e){this.gl.deleteShader(e)}bindTextureToUniform(e,t,n){const r=this.gl;r.activeTexture(r.TEXTURE0+t),this.checkError(),r.bindTexture(r.TEXTURE_2D,e),this.checkError(),r.uniform1i(n,t),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(i.env.debug){const e=this.gl,t=e.getError();let n="";switch(t){case e.NO_ERROR:return;case e.INVALID_ENUM:n="INVALID_ENUM";break;case e.INVALID_VALUE:n="INVALID_VALUE";break;case e.INVALID_OPERATION:n="INVALID_OPERATION";break;case e.INVALID_FRAMEBUFFER_OPERATION:n="INVALID_FRAMEBUFFER_OPERATION";break;case e.OUT_OF_MEMORY:n="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:n="CONTEXT_LOST_WEBGL";break;default:n=`Unknown WebGL Error: ${t.toString(16)}`}throw new Error(n)}}deleteTexture(e){this.gl.deleteTexture(e)}deleteProgram(e){this.gl.deleteProgram(e)}getEncoder(e,t,n=0){if(2===this.version)return new o.RedFloat32DataEncoder(this.gl,t);switch(e){case"float":return 1===n||this.isRenderFloat32Supported?new o.RGBAFloatDataEncoder(this.gl,t):new o.RGBAFloatDataEncoder(this.gl,t,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new o.Uint8DataEncoder(this.gl,t);default:throw new Error(`Invalid dataType: ${e}`)}}clearActiveTextures(){const e=this.gl;for(let t=0;t<this.maxTextureImageUnits;++t)e.activeTexture(e.TEXTURE0+t),e.bindTexture(e.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.framebuffer),e.bindBuffer(e.ARRAY_BUFFER,null),e.deleteBuffer(this.vertexbuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const e=this.gl,t=e.createBuffer();if(!t)throw new Error("createBuffer() returned null");const n=this.createDefaultGeometry();return e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW),this.checkError(),t}createFramebuffer(){const e=this.gl.createFramebuffer();if(!e)throw new Error("createFramebuffer returned null");return e}queryVitalParameters(){const e=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),1===this.version&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){2===this.version?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const e=this.gl,t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t);const n=2===this.version?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,n,1,1,0,e.RGBA,e.FLOAT,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(t),e.deleteFramebuffer(r),s}checkRenderFloat32(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else{if(!this.textureFloatExtension)return!1;if(!this.gl.getExtension("WEBGL_color_buffer_float"))return!1}return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const e=this.gl;let t,n,r,s,a;try{t=e.createTexture(),n=e.createFramebuffer(),e.bindTexture(e.TEXTURE_2D,t);const i=2===this.version?e.RGBA32F:e.RGBA;return e.texImage2D(e.TEXTURE_2D,0,i,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0),e.enable(e.BLEND),r=e.createShader(e.VERTEX_SHADER),!!r&&(e.shaderSource(r,"void main(){}"),e.compileShader(r),s=e.createShader(e.FRAGMENT_SHADER),!!s&&(e.shaderSource(s,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),e.compileShader(s),a=e.createProgram(),!!a&&(e.attachShader(a,r),e.attachShader(a,s),e.linkProgram(a),e.useProgram(a),e.drawArrays(e.POINTS,0,1),e.getError()===e.NO_ERROR)))}finally{e.disable(e.BLEND),a&&e.deleteProgram(a),r&&e.deleteShader(r),s&&e.deleteShader(s),n&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(n)),t&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(t))}}beginTimer(){if(2===this.version&&this.disjointTimerQueryWebgl2Extension){const e=this.gl,t=this.disjointTimerQueryWebgl2Extension,n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const e=this.gl,t=this.disjointTimerQueryWebgl2Extension;e.endQuery(t.TIME_ELAPSED_EXT)}}isTimerResultAvailable(e){let t=!1,n=!1;if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const r=this.gl,s=this.disjointTimerQueryWebgl2Extension;t=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE),n=r.getParameter(s.GPU_DISJOINT_EXT)}return t&&!n}getTimerResult(e){let t=0;if(2!==this.version)throw new Error("WebGL1 profiling currently not supported");{const n=this.gl;t=n.getQueryParameter(e,n.QUERY_RESULT),n.deleteQuery(e)}return t/1e6}async waitForQueryAndGetTime(e){return await(0,u.repeatedTry)(()=>this.isTimerResultAvailable(e)),this.getTimerResult(e)}async createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t;const n=e,r=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),t=null===r?()=>!0:()=>{const e=n.clientWaitSync(r,0,0);return e===n.ALREADY_SIGNALED||e===n.CONDITION_SATISFIED},{query:r,isFencePassed:t}}async pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=l(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}async addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||await(0,u.repeatedTry)(()=>(this.pollItems(),0===this.itemsToPoll.length))}}},1036:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ExecutionPlan=void 0;const r=n(6231);class s{constructor(e,t){this.op=e,this.node=t}}t.ExecutionPlan=class{constructor(e,t,n){this.graph=e,this.profiler=n,this.initialize(t)}initialize(e){this.profiler.event("session","ExecutionPlan.initialize",()=>{const t=this.graph.getNodes();if(t.length!==e.length)throw new Error("The size of nodes and OPs do not match.");this._ops=e.map((e,n)=>new s(e,t[n])),this.reset(),this._starter=[],this._ops.forEach((e,t)=>{let n=!0;for(const t of e.node.inputs)if(!this._values[t]&&-1===this.graph.getInputIndices().indexOf(t)){n=!1;break}n&&this._starter.push(t)})})}reset(){this._values=this.graph.getValues().map(e=>e.tensor)}async execute(e,t){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();const n=e.createInferenceHandler(),s=this.graph.getInputIndices();if(t.length!==s.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${t.length} expected: ${s.length}`);t.forEach((e,t)=>{const n=s[t];this._values[n]=e});const a=this._starter.slice(0),i=this.graph.getValues(),o=this.graph.getNodes();let u=0;for(;u<a.length;){const e=a[u++],t=this._ops[e],s=t.node.inputs.map(e=>this._values[e]);if(-1!==s.indexOf(void 0))throw new Error(`unresolved input detected: op: ${t.node}`);const l=s;r.Logger.verbose("ExecPlan",`Runing op:${t.node.name} (${l.map((e,n)=>`'${t.node.inputs[n]}': ${e.type}[${e.dims.join(",")}]`).join(", ")})`);const c=await this.profiler.event("node",t.node.name,async()=>t.op.impl(n,l,t.op.context));if(c.length!==t.node.outputs.length)throw new Error("the size of output does not match model definition.");c.forEach((e,n)=>{const r=t.node.outputs[n];if(this._values[r])throw new Error(`output [${r}] already has value: op:${t.node.name}`);this._values[r]=e});const h=new Set;c.forEach((e,n)=>{const r=t.node.outputs[n];for(const e of i[r].to){const t=o[e];let n=!0;for(const e of t.inputs)if(!this._values[e]){n=!1;break}n&&h.add(e)}}),a.push(...h)}const l=[];for(let e=0;e<this.graph.getOutputIndices().length;e++){const t=this.graph.getOutputIndices()[e],n=this._values[t];if(void 0===n)throw new Error(`required output [${t}] does not have value`);0===t?await n.getData():n.data,l.push(n)}return r.Logger.verbose("ExecPlan","disposing of inferenceHandler"),n.dispose(),l})}}},7070:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Graph=void 0;const r=n(1446),s=n(7778),a=n(9395),i=n(9162),o=n(2517);var u=a.onnxruntime.experimental.fbs;t.Graph={from:(e,t)=>new h(e,t)};class l{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=o.ProtoUtil.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}}class c{constructor(e,t){e instanceof r.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new s.Attribute(e.attribute)):e instanceof u.Node&&(this.name=null!=t?t:e.name(),this.opType=e.opType(),this.attributes=new s.Attribute(o.ProtoUtil.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class h{constructor(e,t){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(t),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof r.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else{if(!(e instanceof u.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(e)}}buildGraphFromOnnxFormat(e){const t=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const n=new Map;if(!e.input)throw new Error("missing information in graph: input");const r=[];for(const n of e.input){if(t.has(n.name))throw new Error(`duplicated input name: ${n.name}`);const e=this._allData.push(new l(n))-1;t.set(n.name,e),r.push(n.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(const n of e.initializer){let e=t.get(n.name);if(void 0===e){const r=new l;r.type={shape:{dims:o.ProtoUtil.tensorDimsFromProto(n.dims)},tensorType:o.ProtoUtil.tensorDataTypeFromProto(n.dataType)},e=this._allData.push(r)-1,t.set(n.name,e)}this._allData[e]._from=-1,this._allData[e].tensor=i.Tensor.fromProto(n)}for(let e=0;e<this._allData.length;e++)this._allData[e].tensor||(this._allInputIndices.push(e),this._allInputNames.push(r[e]));if(!e.output)throw new Error("missing information in graph: output");for(const n of e.output){if(t.has(n.name))throw new Error(`duplicated output name: ${n.name}`);const e=this._allData.push(new l(n))-1;t.set(n.name,e),this._allOutputIndices.push(e),this._allOutputNames.push(n.name)}if(!e.node)throw new Error("missing information in graph: node");for(const t of e.node){if(!t.name)for(let e=0;;e++){const r=`unnamed_${t.opType}_${e}`;if(!n.has(r)){t.name=r;break}}if(n.has(t.name))throw new Error(`duplicated node name: ${t.name}`);const e=this._nodes.push(new c(t))-1;n.set(t.name,e)}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],s=e.node[n];if(!s.output)throw new Error(`missing output for node: ${s.name}`);for(const e of s.output){let a=t.get(e);if(void 0===a&&(a=this._allData.push(new l)-1,t.set(e,a)),r.outputs.push(a),void 0!==this._allData[a]._from)throw new Error(`multiple nodes output to one data value: ${a}`);if(this._allData[a]._from=n,"Constant"===s.opType){if(!s.attribute||1!==s.attribute.length||!s.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!s.output||1!==s.output.length)throw new Error("missing output or incorrect number of outputs for this Constant operator");r.outputs.pop(),r.executeNode=!1,this._allData[a]._from=-1,this._allData[a].tensor=i.Tensor.fromProto(s.attribute[0].t)}}}for(let n=0;n<this._nodes.length;n++){const r=this._nodes[n],s=e.node[n];if(!s.input)throw new Error(`missing input for node: ${s.name}`);for(const e of s.input){const a=t.get(e);if(void 0===a){if(""===e&&3===s.input.length&&"Resize"===s.opType)continue;throw new Error(`unrecognized input '${e}' for node: ${s.name}`)}r.inputs.push(a),this._allData[a]._to.push(n)}}return!0}buildGraphFromOrtFormat(e){var t,n,r;const s=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const a=new Map,h=[];for(let a=0;a<e.inputsLength();a++){const i=e.inputs(a);if(s.has(i))throw new Error(`duplicated input name: ${i}`);for(let a=0;a<e.nodeArgsLength();a++)if((null===(t=e.nodeArgs(a))||void 0===t?void 0:t.name())===i){const t=new l;if((null===(r=null===(n=e.nodeArgs(a))||void 0===n?void 0:n.type())||void 0===r?void 0:r.valueType())!==u.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const c=e.nodeArgs(a).type().value(new u.TensorTypeAndShape),d=o.ProtoUtil.tensorDataTypeFromProto(c.elemType()),p=c.shape(),f=[];for(let e=0;e<p.dimLength();e++)f.push(o.LongUtil.longToNumber(p.dim(e).value().dimValue()));t.type={shape:{dims:f},tensorType:d};const m=this._allData.push(t)-1;s.set(i,m),h.push(i)}}for(let t=0;t<e.initializersLength();t++){const n=e.initializers(t);let r=s.get(n.name());if(void 0===r){const e=new l,t=o.ProtoUtil.tensorDimsFromORTFormat(n),a=o.ProtoUtil.tensorDataTypeFromProto(n.dataType());e.type={shape:{dims:t},tensorType:a},r=this._allData.push(e)-1,s.set(n.name(),r)}this._allData[r]._from=-1,this._allData[r].tensor=i.Tensor.fromOrtTensor(n)}for(let e=0;e<this._allData.length;e++)this._allData[e].tensor||(this._allInputIndices.push(e),this._allInputNames.push(h[e]));for(let t=0;t<e.outputsLength();t++){const n=e.outputs(t);if(s.has(n))throw new Error(`duplicated output name: ${n}`);const r=this._allData.push(new l)-1;s.set(n,r),this._allOutputIndices.push(r),this._allOutputNames.push(n)}if(!e.nodes)throw new Error("missing information in graph: node");for(let t=0;t<e.nodesLength();t++){const n=e.nodes(t);let r=n.name();if(!r)for(let e=0;r=`unnamed_${n.opType()}_${e}`,a.has(r);e++);if(a.has(r))throw new Error(`duplicated node name: ${r}`);const s=this._nodes.push(new c(n,r))-1;a.set(r,s)}for(let t=0;t<this._nodes.length;t++){const n=this._nodes[t],r=e.nodes(t);if(null==r)throw new Error(`No node exists at index ${t}`);if(0===(null==r?void 0:r.outputsLength()))throw new Error(`missing output for node: ${r.name}`);for(let e=0;e<(null==r?void 0:r.outputsLength());e++){const a=null==r?void 0:r.outputs(e);let o=s.get(a);if(void 0===o&&(o=this._allData.push(new l)-1,s.set(a,o)),n.outputs.push(o),void 0!==this._allData[o]._from)throw new Error(`multiple nodes output to one data value: ${o}`);if(this._allData[o]._from=t,"Constant"===r.opType()){if(1!==r.attributesLength()||!r.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(1!==r.outputsLength())throw new Error("missing output or incorrect number of outputs for this Constant operator");n.outputs.pop(),n.executeNode=!1,this._allData[o]._from=-1,this._allData[o].tensor=i.Tensor.fromOrtTensor(r.attributes(0).t())}}}for(let t=0;t<this._nodes.length;t++){const n=this._nodes[t],r=e.nodes(t);if(0===r.inputsLength())throw new Error(`missing input for node: ${r.name}`);for(let e=0;e<r.inputsLength();e++){const a=r.inputs(e),i=s.get(a);if(void 0===i)throw new Error(`unrecognized input '${a}' for node: ${r.name()}`);n.inputs.push(i),this._allData[i]._to.push(t)}}}checkIsAcyclic(){const e=new Set;this._allInputIndices.forEach(t=>{this._allData[t]._to.forEach(t=>{e.add(t)})});const t=Array.from(e),n=new Array(this._nodes.length).fill("white");for(;t.length>0;){const e=t.pop();"gray"===n[e]?n[e]="black":(t.push(e),n[e]="gray",this._nodes[e].outputs.forEach(r=>{const s=this._allData[r];if(void 0!==s.tensor)throw new Error("node outputs should not be initialized");if(s._from!==e)throw new Error("from property of the Value object doesn't match index of Node being processed");s._to.forEach(e=>{if("gray"===n[e])throw new Error("model graph is cyclic");"white"===n[e]&&t.push(e)})}))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0;for(let t=0;t<this._nodes.length;t++)this._nodes[t].executeNode?e>0&&(this._nodes[t].inputs.forEach(n=>{const r=this._allData[n]._to.indexOf(t+e);-1!==r&&(this._allData[n]._to[r]=t)}),this._nodes[t].outputs.forEach(n=>{this._allData[n]._from&&this._allData[n]._from===t+e&&(this._allData[n]._from=t)})):(e++,this._nodes[t].outputs.forEach(e=>{this._allData[e]._from=-2}),this._nodes.splice(t,1),t--);e=0;for(let t=0;t<this._allData.length;t++)if(-2!==this._allData[t].from||-1!==this._allOutputIndices.indexOf(t+e)){if(e>0){let n=-1;void 0!==this._allData[t].from&&-1!==this._allData[t].from?(n=this._nodes[this._allData[t].from].outputs.indexOf(t+e),-1!==n&&(this._nodes[this._allData[t].from].outputs[n]=t)):(n=this._allInputIndices.indexOf(t+e),-1!==n&&(this._allInputIndices[n]=t)),this._allData[t].to.forEach(r=>{n=this._nodes[r].inputs.indexOf(t+e),-1!==n&&(this._nodes[r].inputs[n]=t)}),0===this._allData[t].to.length&&(n=this._allOutputIndices.indexOf(t+e),-1!==n&&(this._allOutputIndices[n]=t))}}else e++,this._allData.splice(t,1),t--}deleteNode(e){const t=this._nodes[e];if(t.outputs.length>1)for(let e=1;e<t.outputs.length;e++)if(this._allData[t.outputs[e]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");t.executeNode=!1;const n=t.inputs[0],r=t.outputs[0],s=this._allData[r].to,a=this._allData[n].to.indexOf(e);if(-1===a)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[n].to.splice(a,1),this._allData[r]._to=[];const i=this._allOutputIndices.indexOf(r);if(-1!==i&&(this._allOutputIndices[i]=n),s&&s.length>0)for(const e of s){const t=this._nodes[e].inputs.indexOf(r);if(-1===t)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[e].inputs[t]=n,this._allData[n].to.push(e)}}removeAllDropoutNodes(){let e=0;for(const t of this._nodes){if("Dropout"===t.opType){if(1!==t.inputs.length)throw new Error("Dropout nodes should only contain one input. ");if(1!==t.outputs.length&&2!==t.outputs.length)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(2===t.outputs.length&&0!==this._allData[t.outputs[1]]._to.length)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(const t of this._nodes)"Identity"===t.opType&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const e of this._nodes)if("Conv"===e.opType){const t=this._allData[e.outputs[0]]._to;if(1===t.length&&this.isActivation(this._nodes[t[0]])){const n=this._nodes[t[0]];if("Clip"===n.opType)if(1===n.inputs.length)try{e.attributes.set("activation_params","floats",[n.attributes.getFloat("min"),n.attributes.getFloat("max")])}catch(t){e.attributes.set("activation_params","floats",[o.MIN_CLIP,o.MAX_CLIP])}else{if(!(n.inputs.length>=3&&void 0!==this._allData[n.inputs[1]].tensor&&void 0!==this._allData[n.inputs[2]].tensor))continue;e.attributes.set("activation_params","floats",[this._allData[n.inputs[1]].tensor.floatData[0],this._allData[n.inputs[2]].tensor.floatData[0]])}e.attributes.set("activation","string",n.opType),this.deleteNode(t[0])}}}}},6231:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.now=t.Profiler=t.Logger=void 0;const n={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},r={none:new class{log(e,t,n){}},console:new class{log(e,t,n){console.log(`${this.color(e)} ${n?"[35m"+n+"[0m ":""}${t}`)}color(e){switch(e){case"verbose":return"[34;40mv[0m";case"info":return"[32mi[0m";case"warning":return"[30;43mw[0m";case"error":return"[31;40me[0m";case"fatal":return"[101mf[0m";default:throw new Error(`unsupported severity: ${e}`)}}}},s={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let a={"":s};function i(e,t,n,r){if(void 0===t)return s=e,{verbose:i.verbose.bind(null,s),info:i.info.bind(null,s),warning:i.warning.bind(null,s),error:i.error.bind(null,s),fatal:i.fatal.bind(null,s)};if(void 0===n)o(e,t);else if("number"==typeof n&&void 0===r)o(e,t);else if("string"==typeof n&&void 0===r)o(e,n,0,t);else{if("string"!=typeof n||"number"!=typeof r)throw new TypeError("input is valid");o(e,n,0,t)}var s}function o(e,t,s,i){const o=a[i||""]||a[""];n[e]<n[o.minimalSeverity]||(o.logDateTime&&(t=`${(new Date).toISOString()}|${t}`),o.logSourceLocation,r[o.provider].log(e,t,i))}!function(e){function t(e){a={},n("",e||{})}function n(e,n){if("*"===e)t(n);else{const t=a[e]||s;a[e]={provider:n.provider||t.provider,minimalSeverity:n.minimalSeverity||t.minimalSeverity,logDateTime:void 0===n.logDateTime?t.logDateTime:n.logDateTime,logSourceLocation:void 0===n.logSourceLocation?t.logSourceLocation:n.logSourceLocation}}}e.verbose=function(t,n){e("verbose",t,n)},e.info=function(t,n){e("info",t,n)},e.warning=function(t,n){e("warning",t,n)},e.error=function(t,n){e("error",t,n)},e.fatal=function(t,n){e("fatal",t,n)},e.reset=t,e.set=n,e.setWithEnv=function(e){const t={};e.logLevel&&(t.minimalSeverity=e.logLevel),n("",t)}}(i||(i={})),t.Logger=i;class u{constructor(e,t,n,r,s,a){this.category=e,this.name=t,this.startTime=n,this.endCallback=r,this.timer=s,this.ctx=a}end(){return this.endCallback(this)}async checkTimer(){if(void 0===this.ctx||void 0===this.timer)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class l{constructor(e,t,n,r){this.category=e,this.name=t,this.startTime=n,this.endTime=r}}t.Profiler=class{static create(e){return void 0===e?new this:new this(e.maxNumberEvents,e.flushBatchSize,e.flushIntervalInMilliseconds)}constructor(e,t,n){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=void 0===e?1e4:e,this._flushBatchSize=void 0===t?10:t,this._flushIntervalInMilliseconds=void 0===n?5e3:n}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,t.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(e,t,n,r){const s=this._started?this.begin(e,t,r):void 0;let a=!1;const i=n();if(i&&"function"==typeof i.then)return a=!0,new Promise((e,t)=>{i.then(async t=>{s&&await s.end(),e(t)},async e=>{s&&await s.end(),t(e)})});if(!a&&s){const e=s.end();if(e&&"function"==typeof e.then)return new Promise((t,n)=>{e.then(()=>{t(i)},e=>{n(e)})})}return i}begin(e,n,r){if(!this._started)throw new Error("profiler is not started yet");if(void 0===r){const r=(0,t.now)();return this.flush(r),new u(e,n,r,e=>this.endSync(e))}{const t=r.beginTimer();return new u(e,n,0,async e=>this.end(e),t,r)}}async end(e){const t=await e.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new l(e.category,e.name,e.startTime,t)),this.flush(t))}endSync(e){const n=(0,t.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new l(e.category,e.name,e.startTime,n)),this.flush(n))}logOneEvent(e){t.Logger.verbose(`Profiler.${e.category}`,`${(e.endTime-e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`)}flush(e){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||e-this._flushTime>=this._flushIntervalInMilliseconds){for(const e=this._flushPointer;this._flushPointer<e+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,t.now)()}}get started(){return this._started}},t.now="undefined"!=typeof performance&&performance.now?()=>performance.now():Date.now},2644:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Model=void 0;const r=n(5686),s=n(1446),a=n(7070),i=n(9395),o=n(2517);var u=i.onnxruntime.experimental.fbs;t.Model=class{constructor(){}load(e,t,n){if(!n)try{return void this.loadFromOnnxFormat(e,t)}catch(e){if(void 0!==n)throw e}this.loadFromOrtFormat(e,t)}loadFromOnnxFormat(e,t){const n=s.onnx.ModelProto.decode(e);if(o.LongUtil.longToNumber(n.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=n.opsetImport.map(e=>({domain:e.domain,version:o.LongUtil.longToNumber(e.version)})),this._graph=a.Graph.from(n.graph,t)}loadFromOrtFormat(e,t){const n=new r.flatbuffers.ByteBuffer(e),s=u.InferenceSession.getRootAsInferenceSession(n).model();if(o.LongUtil.longToNumber(s.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let e=0;e<s.opsetImportLength();e++){const t=s.opsetImport(e);this._opsets.push({domain:null==t?void 0:t.domain(),version:o.LongUtil.longToNumber(t.version())})}this._graph=a.Graph.from(s.graph(),t)}get graph(){return this._graph}get opsets(){return this._opsets}}},782:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FLOAT_TYPES=t.INT_TYPES=t.NUMBER_TYPES=void 0,t.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],t.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],t.FLOAT_TYPES=["float32","float64"]},1047:(e,t)=>{"use strict";function n(e,t){if(t.endsWith("+")){const n=Number.parseInt(t.substring(0,t.length-1),10);return!isNaN(n)&&n<=e}if(2===t.split("-").length){const n=t.split("-"),r=Number.parseInt(n[0],10),s=Number.parseInt(n[1],10);return!isNaN(r)&&!isNaN(s)&&r<=e&&e<=s}return Number.parseInt(t,10)===e}Object.defineProperty(t,"__esModule",{value:!0}),t.resolveOperator=void 0,t.resolveOperator=function(e,t,r){for(const s of r){const r=s[0],a=s[1],i=s[2],o=s[3],u=s[4];if(e.opType===r)for(const e of t)if((e.domain===a||"ai.onnx"===e.domain&&""===a)&&n(e.version,i))return{opImpl:o,opInit:u}}throw new TypeError(`cannot resolve operator '${e.opType}' with opsets: ${t.map(e=>`${e.domain||"ai.onnx"} v${e.version}`).join(", ")}`)}},9395:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.onnxruntime=void 0;const r=n(5686);var s,a;(function(e){let t;!function(e){e[e.UNDEFINED=0]="UNDEFINED",e[e.FLOAT=1]="FLOAT",e[e.INT=2]="INT",e[e.STRING=3]="STRING",e[e.TENSOR=4]="TENSOR",e[e.GRAPH=5]="GRAPH",e[e.FLOATS=6]="FLOATS",e[e.INTS=7]="INTS",e[e.STRINGS=8]="STRINGS",e[e.TENSORS=9]="TENSORS",e[e.GRAPHS=10]="GRAPHS",e[e.SPARSE_TENSOR=11]="SPARSE_TENSOR",e[e.SPARSE_TENSORS=12]="SPARSE_TENSORS"}(t=e.AttributeType||(e.AttributeType={}))})((a=(s=t.onnxruntime||(t.onnxruntime={})).experimental||(s.experimental={})).fbs||(a.fbs={})),function(e){!function(e){!function(e){let t;!function(e){e[e.UNKNOWN=0]="UNKNOWN",e[e.VALUE=1]="VALUE",e[e.PARAM=2]="PARAM"}(t=e.DimensionValueType||(e.DimensionValueType={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){let t;!function(e){e[e.UNDEFINED=0]="UNDEFINED",e[e.FLOAT=1]="FLOAT",e[e.UINT8=2]="UINT8",e[e.INT8=3]="INT8",e[e.UINT16=4]="UINT16",e[e.INT16=5]="INT16",e[e.INT32=6]="INT32",e[e.INT64=7]="INT64",e[e.STRING=8]="STRING",e[e.BOOL=9]="BOOL",e[e.FLOAT16=10]="FLOAT16",e[e.DOUBLE=11]="DOUBLE",e[e.UINT32=12]="UINT32",e[e.UINT64=13]="UINT64",e[e.COMPLEX64=14]="COMPLEX64",e[e.COMPLEX128=15]="COMPLEX128",e[e.BFLOAT16=16]="BFLOAT16"}(t=e.TensorDataType||(e.TensorDataType={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){let t;!function(e){e[e.Primitive=0]="Primitive",e[e.Fused=1]="Fused"}(t=e.NodeType||(e.NodeType={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){let t;!function(e){e[e.NONE=0]="NONE",e[e.tensor_type=1]="tensor_type",e[e.sequence_type=2]="sequence_type",e[e.map_type=3]="map_type"}(t=e.TypeInfoValue||(e.TypeInfoValue={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsShape(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsShape(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}dim(t,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}dimLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}static startShape(e){e.startObject(1)}static addDim(e,t){e.addFieldOffset(0,t,0)}static createDimVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startDimVector(e,t){e.startVector(4,t,4)}static endShape(e){return e.endObject()}static createShape(e,t){return n.startShape(e),n.addDim(e,t),n.endShape(e)}}t.Shape=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsDimension(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsDimension(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}value(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}denotation(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}static startDimension(e){e.startObject(2)}static addValue(e,t){e.addFieldOffset(0,t,0)}static addDenotation(e,t){e.addFieldOffset(1,t,0)}static endDimension(e){return e.endObject()}static createDimension(e,t,r){return n.startDimension(e),n.addValue(e,t),n.addDenotation(e,r),n.endDimension(e)}}t.Dimension=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsDimensionValue(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsDimensionValue(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}dimType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt8(this.bb_pos+t):e.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}dimParam(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}static startDimensionValue(e){e.startObject(3)}static addDimType(t,n){t.addFieldInt8(0,n,e.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(e,t){e.addFieldInt64(1,t,e.createLong(0,0))}static addDimParam(e,t){e.addFieldOffset(2,t,0)}static endDimensionValue(e){return e.endObject()}static createDimensionValue(e,t,r,s){return n.startDimensionValue(e),n.addDimType(e,t),n.addDimValue(e,r),n.addDimParam(e,s),n.endDimensionValue(e)}}t.DimensionValue=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTensorTypeAndShape(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTensorTypeAndShape(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}elemType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.TensorDataType.UNDEFINED}shape(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startTensorTypeAndShape(e){e.startObject(2)}static addElemType(t,n){t.addFieldInt32(0,n,e.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(e,t){e.addFieldOffset(1,t,0)}static endTensorTypeAndShape(e){return e.endObject()}static createTensorTypeAndShape(e,t,r){return n.startTensorTypeAndShape(e),n.addElemType(e,t),n.addShape(e,r),n.endTensorTypeAndShape(e)}}t.TensorTypeAndShape=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsMapType(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsMapType(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}keyType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.TensorDataType.UNDEFINED}valueType(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startMapType(e){e.startObject(2)}static addKeyType(t,n){t.addFieldInt32(0,n,e.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(e,t){e.addFieldOffset(1,t,0)}static endMapType(e){return e.endObject()}static createMapType(e,t,r){return n.startMapType(e),n.addKeyType(e,t),n.addValueType(e,r),n.endMapType(e)}}t.MapType=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSequenceType(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSequenceType(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}elemType(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSequenceType(e){e.startObject(1)}static addElemType(e,t){e.addFieldOffset(0,t,0)}static endSequenceType(e){return e.endObject()}static createSequenceType(e,t){return n.startSequenceType(e),n.addElemType(e,t),n.endSequenceType(e)}}t.SequenceType=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){(e.fbs||(e.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(e,t,n,r){return e.prep(4,12),e.writeInt32(r),e.writeInt32(n),e.writeInt32(t),e.offset()}}}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsNodeEdge(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsNodeEdge(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}nodeIndex(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb_pos+e):0}inputEdges(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*t,this.bb):null}inputEdgesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}outputEdges(t,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+r)+12*t,this.bb):null}outputEdgesLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}static startNodeEdge(e){e.startObject(3)}static addNodeIndex(e,t){e.addFieldInt32(0,t,0)}static addInputEdges(e,t){e.addFieldOffset(1,t,0)}static startInputEdgesVector(e,t){e.startVector(12,t,4)}static addOutputEdges(e,t){e.addFieldOffset(2,t,0)}static startOutputEdgesVector(e,t){e.startVector(12,t,4)}static endNodeEdge(e){return e.endObject()}static createNodeEdge(e,t,r,s){return n.startNodeEdge(e),n.addNodeIndex(e,t),n.addInputEdges(e,r),n.addOutputEdges(e,s),n.endNodeEdge(e)}}t.NodeEdge=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsNode(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsNode(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}domain(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}sinceVersion(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readInt32(this.bb_pos+e):0}index(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb_pos+e):0}opType(e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb_pos+t,e):null}type(){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.NodeType.Primitive}executionProviderType(e){let t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__string(this.bb_pos+t,e):null}inputs(e,t){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}inputsLength(){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__vector_len(this.bb_pos+e):0}outputs(e,t){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}outputsLength(){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__vector_len(this.bb_pos+e):0}attributes(t,n){let r=this.bb.__offset(this.bb_pos,24);return r?(n||new e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}attributesLength(){let e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__vector_len(this.bb_pos+e):0}inputArgCounts(e){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readInt32(this.bb.__vector(this.bb_pos+t)+4*e):0}inputArgCountsLength(){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__vector_len(this.bb_pos+e):0}inputArgCountsArray(){let e=this.bb.__offset(this.bb_pos,26);return e?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}implicitInputs(e,t){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}implicitInputsLength(){let e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__vector_len(this.bb_pos+e):0}static startNode(e){e.startObject(13)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addDomain(e,t){e.addFieldOffset(2,t,0)}static addSinceVersion(e,t){e.addFieldInt32(3,t,0)}static addIndex(e,t){e.addFieldInt32(4,t,0)}static addOpType(e,t){e.addFieldOffset(5,t,0)}static addType(t,n){t.addFieldInt32(6,n,e.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(e,t){e.addFieldOffset(7,t,0)}static addInputs(e,t){e.addFieldOffset(8,t,0)}static createInputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startInputsVector(e,t){e.startVector(4,t,4)}static addOutputs(e,t){e.addFieldOffset(9,t,0)}static createOutputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startOutputsVector(e,t){e.startVector(4,t,4)}static addAttributes(e,t){e.addFieldOffset(10,t,0)}static createAttributesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startAttributesVector(e,t){e.startVector(4,t,4)}static addInputArgCounts(e,t){e.addFieldOffset(11,t,0)}static createInputArgCountsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addInt32(t[n]);return e.endVector()}static startInputArgCountsVector(e,t){e.startVector(4,t,4)}static addImplicitInputs(e,t){e.addFieldOffset(12,t,0)}static createImplicitInputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startImplicitInputsVector(e,t){e.startVector(4,t,4)}static endNode(e){return e.endObject()}static createNode(e,t,r,s,a,i,o,u,l,c,h,d,p,f){return n.startNode(e),n.addName(e,t),n.addDocString(e,r),n.addDomain(e,s),n.addSinceVersion(e,a),n.addIndex(e,i),n.addOpType(e,o),n.addType(e,u),n.addExecutionProviderType(e,l),n.addInputs(e,c),n.addOutputs(e,h),n.addAttributes(e,d),n.addInputArgCounts(e,p),n.addImplicitInputs(e,f),n.endNode(e)}}t.Node=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsValueInfo(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsValueInfo(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}type(t){let n=this.bb.__offset(this.bb_pos,8);return n?(t||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startValueInfo(e){e.startObject(3)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addType(e,t){e.addFieldOffset(2,t,0)}static endValueInfo(e){return e.endObject()}static createValueInfo(e,t,r,s){return n.startValueInfo(e),n.addName(e,t),n.addDocString(e,r),n.addType(e,s),n.endValueInfo(e)}}t.ValueInfo=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTypeInfo(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTypeInfo(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}denotation(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}valueType(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint8(this.bb_pos+t):e.experimental.fbs.TypeInfoValue.NONE}value(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__union(e,this.bb_pos+t):null}static startTypeInfo(e){e.startObject(3)}static addDenotation(e,t){e.addFieldOffset(0,t,0)}static addValueType(t,n){t.addFieldInt8(1,n,e.experimental.fbs.TypeInfoValue.NONE)}static addValue(e,t){e.addFieldOffset(2,t,0)}static endTypeInfo(e){return e.endObject()}static createTypeInfo(e,t,r,s){return n.startTypeInfo(e),n.addDenotation(e,t),n.addValueType(e,r),n.addValue(e,s),n.endTypeInfo(e)}}t.TypeInfo=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){class t{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsOperatorSetId(e,n){return(n||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsOperatorSetId(e,n){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new t).__init(e.readInt32(e.position())+e.position(),e)}domain(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}version(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}static startOperatorSetId(e){e.startObject(2)}static addDomain(e,t){e.addFieldOffset(0,t,0)}static addVersion(e,t){e.addFieldInt64(1,t,e.createLong(0,0))}static endOperatorSetId(e){return e.endObject()}static createOperatorSetId(e,n,r){return t.startOperatorSetId(e),t.addDomain(e,n),t.addVersion(e,r),t.endOperatorSetId(e)}}e.OperatorSetId=t}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTensor(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTensor(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}dims(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}dimsLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}dataType(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.TensorDataType.UNDEFINED}rawData(e){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readUint8(this.bb.__vector(this.bb_pos+t)+e):0}rawDataLength(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__vector_len(this.bb_pos+e):0}rawDataArray(){let e=this.bb.__offset(this.bb_pos,12);return e?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}stringData(e,t){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}stringDataLength(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__vector_len(this.bb_pos+e):0}static startTensor(e){e.startObject(6)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addDims(e,t){e.addFieldOffset(2,t,0)}static createDimsVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startDimsVector(e,t){e.startVector(8,t,8)}static addDataType(t,n){t.addFieldInt32(3,n,e.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(e,t){e.addFieldOffset(4,t,0)}static createRawDataVector(e,t){e.startVector(1,t.length,1);for(let n=t.length-1;n>=0;n--)e.addInt8(t[n]);return e.endVector()}static startRawDataVector(e,t){e.startVector(1,t,1)}static addStringData(e,t){e.addFieldOffset(5,t,0)}static createStringDataVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startStringDataVector(e,t){e.startVector(4,t,4)}static endTensor(e){return e.endObject()}static createTensor(e,t,r,s,a,i,o){return n.startTensor(e),n.addName(e,t),n.addDocString(e,r),n.addDims(e,s),n.addDataType(e,a),n.addRawData(e,i),n.addStringData(e,o),n.endTensor(e)}}t.Tensor=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSparseTensor(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSparseTensor(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}values(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}indices(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}dims(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}dimsLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}static startSparseTensor(e){e.startObject(3)}static addValues(e,t){e.addFieldOffset(0,t,0)}static addIndices(e,t){e.addFieldOffset(1,t,0)}static addDims(e,t){e.addFieldOffset(2,t,0)}static createDimsVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startDimsVector(e,t){e.startVector(8,t,8)}static endSparseTensor(e){return e.endObject()}static createSparseTensor(e,t,r,s){return n.startSparseTensor(e),n.addValues(e,t),n.addIndices(e,r),n.addDims(e,s),n.endSparseTensor(e)}}t.SparseTensor=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsAttribute(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsAttribute(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}type(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.AttributeType.UNDEFINED}f(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readFloat32(this.bb_pos+e):0}i(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}s(e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb_pos+t,e):null}t(t){let n=this.bb.__offset(this.bb_pos,16);return n?(t||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}g(t){let n=this.bb.__offset(this.bb_pos,18);return n?(t||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}floats(e){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.readFloat32(this.bb.__vector(this.bb_pos+t)+4*e):0}floatsLength(){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__vector_len(this.bb_pos+e):0}floatsArray(){let e=this.bb.__offset(this.bb_pos,20);return e?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}ints(e){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}intsLength(){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__vector_len(this.bb_pos+e):0}strings(e,t){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}stringsLength(){let e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__vector_len(this.bb_pos+e):0}tensors(t,n){let r=this.bb.__offset(this.bb_pos,26);return r?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}tensorsLength(){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__vector_len(this.bb_pos+e):0}graphs(t,n){let r=this.bb.__offset(this.bb_pos,28);return r?(n||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}graphsLength(){let e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__vector_len(this.bb_pos+e):0}static startAttribute(e){e.startObject(13)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addType(t,n){t.addFieldInt32(2,n,e.experimental.fbs.AttributeType.UNDEFINED)}static addF(e,t){e.addFieldFloat32(3,t,0)}static addI(e,t){e.addFieldInt64(4,t,e.createLong(0,0))}static addS(e,t){e.addFieldOffset(5,t,0)}static addT(e,t){e.addFieldOffset(6,t,0)}static addG(e,t){e.addFieldOffset(7,t,0)}static addFloats(e,t){e.addFieldOffset(8,t,0)}static createFloatsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addFloat32(t[n]);return e.endVector()}static startFloatsVector(e,t){e.startVector(4,t,4)}static addInts(e,t){e.addFieldOffset(9,t,0)}static createIntsVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startIntsVector(e,t){e.startVector(8,t,8)}static addStrings(e,t){e.addFieldOffset(10,t,0)}static createStringsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startStringsVector(e,t){e.startVector(4,t,4)}static addTensors(e,t){e.addFieldOffset(11,t,0)}static createTensorsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startTensorsVector(e,t){e.startVector(4,t,4)}static addGraphs(e,t){e.addFieldOffset(12,t,0)}static createGraphsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startGraphsVector(e,t){e.startVector(4,t,4)}static endAttribute(e){return e.endObject()}static createAttribute(e,t,r,s,a,i,o,u,l,c,h,d,p,f){return n.startAttribute(e),n.addName(e,t),n.addDocString(e,r),n.addType(e,s),n.addF(e,a),n.addI(e,i),n.addS(e,o),n.addT(e,u),n.addG(e,l),n.addFloats(e,c),n.addInts(e,h),n.addStrings(e,d),n.addTensors(e,p),n.addGraphs(e,f),n.endAttribute(e)}}t.Attribute=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsGraph(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsGraph(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}initializers(t,n){let r=this.bb.__offset(this.bb_pos,4);return r?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}initializersLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}nodeArgs(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}nodeArgsLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}nodes(t,n){let r=this.bb.__offset(this.bb_pos,8);return r?(n||new e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}nodesLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}maxNodeIndex(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb_pos+e):0}nodeEdges(t,n){let r=this.bb.__offset(this.bb_pos,12);return r?(n||new e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}nodeEdgesLength(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__vector_len(this.bb_pos+e):0}inputs(e,t){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}inputsLength(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__vector_len(this.bb_pos+e):0}outputs(e,t){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*e,t):null}outputsLength(){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__vector_len(this.bb_pos+e):0}sparseInitializers(t,n){let r=this.bb.__offset(this.bb_pos,18);return r?(n||new e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}sparseInitializersLength(){let e=this.bb.__offset(this.bb_pos,18);return e?this.bb.__vector_len(this.bb_pos+e):0}static startGraph(e){e.startObject(8)}static addInitializers(e,t){e.addFieldOffset(0,t,0)}static createInitializersVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startInitializersVector(e,t){e.startVector(4,t,4)}static addNodeArgs(e,t){e.addFieldOffset(1,t,0)}static createNodeArgsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startNodeArgsVector(e,t){e.startVector(4,t,4)}static addNodes(e,t){e.addFieldOffset(2,t,0)}static createNodesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startNodesVector(e,t){e.startVector(4,t,4)}static addMaxNodeIndex(e,t){e.addFieldInt32(3,t,0)}static addNodeEdges(e,t){e.addFieldOffset(4,t,0)}static createNodeEdgesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startNodeEdgesVector(e,t){e.startVector(4,t,4)}static addInputs(e,t){e.addFieldOffset(5,t,0)}static createInputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startInputsVector(e,t){e.startVector(4,t,4)}static addOutputs(e,t){e.addFieldOffset(6,t,0)}static createOutputsVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startOutputsVector(e,t){e.startVector(4,t,4)}static addSparseInitializers(e,t){e.addFieldOffset(7,t,0)}static createSparseInitializersVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startSparseInitializersVector(e,t){e.startVector(4,t,4)}static endGraph(e){return e.endObject()}static createGraph(e,t,r,s,a,i,o,u,l){return n.startGraph(e),n.addInitializers(e,t),n.addNodeArgs(e,r),n.addNodes(e,s),n.addMaxNodeIndex(e,a),n.addNodeEdges(e,i),n.addInputs(e,o),n.addOutputs(e,u),n.addSparseInitializers(e,l),n.endGraph(e)}}t.Graph=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsModel(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsModel(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}irVersion(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}opsetImport(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}opsetImportLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}producerName(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}producerVersion(e){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__string(this.bb_pos+t,e):null}domain(e){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__string(this.bb_pos+t,e):null}modelVersion(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}docString(e){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__string(this.bb_pos+t,e):null}graph(t){let n=this.bb.__offset(this.bb_pos,18);return n?(t||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}graphDocString(e){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__string(this.bb_pos+t,e):null}static startModel(e){e.startObject(9)}static addIrVersion(e,t){e.addFieldInt64(0,t,e.createLong(0,0))}static addOpsetImport(e,t){e.addFieldOffset(1,t,0)}static createOpsetImportVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startOpsetImportVector(e,t){e.startVector(4,t,4)}static addProducerName(e,t){e.addFieldOffset(2,t,0)}static addProducerVersion(e,t){e.addFieldOffset(3,t,0)}static addDomain(e,t){e.addFieldOffset(4,t,0)}static addModelVersion(e,t){e.addFieldInt64(5,t,e.createLong(0,0))}static addDocString(e,t){e.addFieldOffset(6,t,0)}static addGraph(e,t){e.addFieldOffset(7,t,0)}static addGraphDocString(e,t){e.addFieldOffset(8,t,0)}static endModel(e){return e.endObject()}static createModel(e,t,r,s,a,i,o,u,l,c){return n.startModel(e),n.addIrVersion(e,t),n.addOpsetImport(e,r),n.addProducerName(e,s),n.addProducerVersion(e,a),n.addDomain(e,i),n.addModelVersion(e,o),n.addDocString(e,u),n.addGraph(e,l),n.addGraphDocString(e,c),n.endModel(e)}}t.Model=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){class t{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsKernelCreateInfos(e,n){return(n||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsKernelCreateInfos(e,n){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(n||new t).__init(e.readInt32(e.position())+e.position(),e)}nodeIndices(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb.__vector(this.bb_pos+t)+4*e):0}nodeIndicesLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}nodeIndicesArray(){let e=this.bb.__offset(this.bb_pos,4);return e?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}kernelDefHashes(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}kernelDefHashesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}static startKernelCreateInfos(e){e.startObject(2)}static addNodeIndices(e,t){e.addFieldOffset(0,t,0)}static createNodeIndicesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addInt32(t[n]);return e.endVector()}static startNodeIndicesVector(e,t){e.startVector(4,t,4)}static addKernelDefHashes(e,t){e.addFieldOffset(1,t,0)}static createKernelDefHashesVector(e,t){e.startVector(8,t.length,8);for(let n=t.length-1;n>=0;n--)e.addInt64(t[n]);return e.endVector()}static startKernelDefHashesVector(e,t){e.startVector(8,t,8)}static endKernelCreateInfos(e){return e.endObject()}static createKernelCreateInfos(e,n,r){return t.startKernelCreateInfos(e),t.addNodeIndices(e,n),t.addKernelDefHashes(e,r),t.endKernelCreateInfos(e)}}e.KernelCreateInfos=t}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSubGraphSessionState(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSubGraphSessionState(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}graphId(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}sessionState(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startSubGraphSessionState(e){e.startObject(2)}static addGraphId(e,t){e.addFieldOffset(0,t,0)}static addSessionState(e,t){e.addFieldOffset(1,t,0)}static endSubGraphSessionState(e){let t=e.endObject();return e.requiredField(t,4),t}static createSubGraphSessionState(e,t,r){return n.startSubGraphSessionState(e),n.addGraphId(e,t),n.addSessionState(e,r),n.endSubGraphSessionState(e)}}t.SubGraphSessionState=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSessionState(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSessionState(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}kernels(t){let n=this.bb.__offset(this.bb_pos,4);return n?(t||new e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}subGraphSessionStates(t,n){let r=this.bb.__offset(this.bb_pos,6);return r?(n||new e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+r)+4*t),this.bb):null}subGraphSessionStatesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}static startSessionState(e){e.startObject(2)}static addKernels(e,t){e.addFieldOffset(0,t,0)}static addSubGraphSessionStates(e,t){e.addFieldOffset(1,t,0)}static createSubGraphSessionStatesVector(e,t){e.startVector(4,t.length,4);for(let n=t.length-1;n>=0;n--)e.addOffset(t[n]);return e.endVector()}static startSubGraphSessionStatesVector(e,t){e.startVector(4,t,4)}static endSessionState(e){return e.endObject()}static createSessionState(e,t,r){return n.startSessionState(e),n.addKernels(e,t),n.addSubGraphSessionStates(e,r),n.endSessionState(e)}}t.SessionState=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class n{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsInferenceSession(e,t){return(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsInferenceSession(e,t){return e.setPosition(e.position()+r.flatbuffers.SIZE_PREFIX_LENGTH),(t||new n).__init(e.readInt32(e.position())+e.position(),e)}static bufferHasIdentifier(e){return e.__has_identifier("ORTM")}ortVersion(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}model(t){let n=this.bb.__offset(this.bb_pos,6);return n?(t||new e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}sessionState(t){let n=this.bb.__offset(this.bb_pos,8);return n?(t||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+n),this.bb):null}static startInferenceSession(e){e.startObject(3)}static addOrtVersion(e,t){e.addFieldOffset(0,t,0)}static addModel(e,t){e.addFieldOffset(1,t,0)}static addSessionState(e,t){e.addFieldOffset(2,t,0)}static endInferenceSession(e){return e.endObject()}static finishInferenceSessionBuffer(e,t){e.finish(t,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(e,t){e.finish(t,"ORTM",!0)}static createInferenceSession(e,t,r,s){return n.startInferenceSession(e),n.addOrtVersion(e,t),n.addModel(e,r),n.addSessionState(e,s),n.endInferenceSession(e)}}t.InferenceSession=n}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={}))},7448:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.OnnxjsSessionHandler=void 0;const r=n(1670),s=n(9162);t.OnnxjsSessionHandler=class{constructor(e){this.session=e,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(e,t,n){const a=new Map;for(const t in e)if(Object.hasOwnProperty.call(e,t)){const n=e[t];a.set(t,new s.Tensor(n.dims,n.type,void 0,void 0,n.data))}const i=await this.session.run(a),o={};return i.forEach((e,t)=>{o[t]=new r.Tensor(e.type,e.data,e.dims)}),o}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6919:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Session=void 0;const r=n(7067),s=n(1296),a=n(7091),i=n(1036),o=n(6231),u=n(2644);t.Session=class{constructor(e={}){this._initialized=!1,this.backendHint=e.backendHint,this.profiler=o.Profiler.create(e.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(e,t,n){await this.profiler.event("session","Session.loadModel",async()=>{const i=await(0,a.resolveBackend)(this.backendHint);if(this.sessionHandler=i.createSessionHandler(this.context),this._model=new u.Model,"string"==typeof e){const t=e.endsWith(".ort");if("undefined"==typeof fetch){const n=await(0,s.promisify)(r.readFile)(e);this.initialize(n,t)}else{const n=await fetch(e),r=await n.arrayBuffer();this.initialize(new Uint8Array(r),t)}}else if(ArrayBuffer.isView(e))this.initialize(e);else{const r=new Uint8Array(e,t||0,n||e.byteLength);this.initialize(r)}})}initialize(e,t){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{const n=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(e,n,t),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new i.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(e){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{const t=this.normalizeAndValidateInputs(e),n=await this._executionPlan.execute(this.sessionHandler,t);return this.createOutput(n)})}normalizeAndValidateInputs(e){const t=this._model.graph.getInputNames();if(Array.isArray(e)){if(e.length!==t.length)throw new Error(`incorrect input array length: expected ${t.length} but got ${e.length}`)}else{if(e.size!==t.length)throw new Error(`incorrect input map size: expected ${t.length} but got ${e.size}`);const n=new Array(e.size);let r=0;for(let s=0;s<t.length;++s){const a=e.get(t[s]);if(!a)throw new Error(`missing input tensor for: '${name}'`);n[r++]=a}e=n}if(this.context.graphInputTypes&&0!==this.context.graphInputTypes.length&&this.context.graphInputDims&&0!==this.context.graphInputDims.length)this.validateInputTensorDims(this.context.graphInputDims,e,!1);else{const t=this._model.graph.getInputIndices(),n=this._model.graph.getValues(),r=new Array(t.length);for(let s=0;s<t.length;++s){const a=n[t[s]];r[s]=a.type.shape.dims,this.context.graphInputTypes.push(a.type.tensorType),this.context.graphInputDims.push(e[s].dims)}this.validateInputTensorDims(r,e,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,e),e}validateInputTensorTypes(e,t){for(let n=0;n<t.length;n++){const r=e[n],s=t[n].type;if(r!==s)throw new Error(`input tensor[${n}] check failed: expected type '${r}' but got ${s}`)}}validateInputTensorDims(e,t,n){for(let r=0;r<t.length;r++){const s=e[r],a=t[r].dims;if(!this.compareTensorDims(s,a,n))throw new Error(`input tensor[${r}] check failed: expected shape '[${s.join(",")}]' but got [${a.join(",")}]`)}}compareTensorDims(e,t,n){if(e.length!==t.length)return!1;for(let r=0;r<e.length;++r)if(e[r]!==t[r]&&(!n||0!==e[r]))return!1;return!0}createOutput(e){const t=this._model.graph.getOutputNames();if(e.length!==t.length)throw new Error("expected number of outputs do not match number of generated outputs");const n=new Map;for(let r=0;r<t.length;++r)n.set(t[r],e[r]);return n}initializeOps(e){const t=e.getNodes();this._ops=new Array(t.length);for(let n=0;n<t.length;n++)this._ops[n]=this.sessionHandler.resolve(t[n],this._model.opsets,e)}}},9162:function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.Tensor=void 0;const s=n(3442),a=r(n(3720)),i=n(1446),o=n(9395),u=n(2517);var l=o.onnxruntime.experimental.fbs;class c{get data(){if(void 0===this.cache){const e=this.dataProvider(this.dataId);if(e.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=e}return this.cache}get stringData(){if("string"!==this.type)throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if("string"!==this.type)return this.data;throw new TypeError("type cannot be non-number (string)")}get(e){return this.data[u.ShapeUtil.indicesToOffset(e,this.strides)]}set(e,t){this.data[u.ShapeUtil.indicesToOffset(e,this.strides)]=t}async getData(){return void 0===this.cache&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=u.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(e,t,n,r,a,i=s.Guid.create()){this.dims=e,this.type=t,this.dataProvider=n,this.asyncDataProvider=r,this.cache=a,this.dataId=i,this.size=u.ShapeUtil.validateDimsAndCalcSize(e);const o=this.size,l=void 0===n&&void 0===r&&void 0===a;if(void 0!==a&&a.length!==o)throw new RangeError("Input dims doesn't match data length.");if("string"===t){if(!(void 0===a||Array.isArray(a)&&a.every(e=>"string"==typeof e)))throw new TypeError("cache should be a string array");l&&(this.cache=new Array(o))}else{if(void 0!==a){const e=d(t);if(!(a instanceof e))throw new TypeError(`cache should be type ${e.name}`)}if(l){const e=new ArrayBuffer(o*function(e){switch(e){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${e}`)}}(t));this.cache=function(e,t){return new(d(t))(e)}(e,t)}}}static fromProto(e){if(!e)throw new Error("cannot construct Value from an empty tensor");const t=u.ProtoUtil.tensorDataTypeFromProto(e.dataType),n=u.ProtoUtil.tensorDimsFromProto(e.dims),r=new c(n,t);if("string"===t)e.stringData.forEach((e,t)=>{r.data[t]=(0,u.decodeUtf8String)(e)});else if(e.rawData&&"number"==typeof e.rawData.byteLength&&e.rawData.byteLength>0){const t=r.data,n=new DataView(e.rawData.buffer,e.rawData.byteOffset,e.rawData.byteLength),s=h(e.dataType),a=e.rawData.byteLength/s;if(e.rawData.byteLength%s!=0)throw new Error("invalid buffer length");if(t.length!==a)throw new Error("buffer length mismatch");for(let r=0;r<a;r++){const a=f(n,e.dataType,r*s);t[r]=a}}else{let t;switch(e.dataType){case i.onnx.TensorProto.DataType.FLOAT:t=e.floatData;break;case i.onnx.TensorProto.DataType.INT32:case i.onnx.TensorProto.DataType.INT16:case i.onnx.TensorProto.DataType.UINT16:case i.onnx.TensorProto.DataType.INT8:case i.onnx.TensorProto.DataType.UINT8:case i.onnx.TensorProto.DataType.BOOL:t=e.int32Data;break;case i.onnx.TensorProto.DataType.INT64:t=e.int64Data;break;case i.onnx.TensorProto.DataType.DOUBLE:t=e.doubleData;break;case i.onnx.TensorProto.DataType.UINT32:case i.onnx.TensorProto.DataType.UINT64:t=e.uint64Data;break;default:throw new Error("unspecific error")}if(null==t)throw new Error("failed to populate data from a tensorproto value");const n=r.data;if(n.length!==t.length)throw new Error("array length mismatch");for(let r=0;r<t.length;r++){const s=t[r];a.default.isLong(s)?n[r]=p(s,e.dataType):n[r]=s}}return r}static fromData(e,t,n){return new c(t,n,void 0,void 0,e)}static fromOrtTensor(e){if(!e)throw new Error("cannot construct Value from an empty tensor");const t=u.ProtoUtil.tensorDimsFromORTFormat(e),n=u.ProtoUtil.tensorDataTypeFromProto(e.dataType()),r=new c(t,n);if("string"===n)for(let t=0;t<e.stringDataLength();t++)r.data[t]=e.stringData(t);else if(e.rawDataArray()&&"number"==typeof e.rawDataLength()&&e.rawDataLength()>0){const t=r.data,n=new DataView(e.rawDataArray().buffer,e.rawDataArray().byteOffset,e.rawDataLength()),s=h(e.dataType()),a=e.rawDataLength()/s;if(e.rawDataLength()%s!=0)throw new Error("invalid buffer length");if(t.length!==a)throw new Error("buffer length mismatch");for(let r=0;r<a;r++){const a=f(n,e.dataType(),r*s);t[r]=a}}return r}}function h(e){switch(e){case i.onnx.TensorProto.DataType.UINT8:case i.onnx.TensorProto.DataType.INT8:case i.onnx.TensorProto.DataType.BOOL:return 1;case i.onnx.TensorProto.DataType.UINT16:case i.onnx.TensorProto.DataType.INT16:return 2;case i.onnx.TensorProto.DataType.FLOAT:case i.onnx.TensorProto.DataType.INT32:case i.onnx.TensorProto.DataType.UINT32:return 4;case i.onnx.TensorProto.DataType.INT64:case i.onnx.TensorProto.DataType.DOUBLE:case i.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${i.onnx.TensorProto.DataType[e]}`)}}function d(e){switch(e){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function p(e,t){if(t===i.onnx.TensorProto.DataType.INT64||t===l.TensorDataType.INT64){if(e.greaterThanOrEqual(2147483648)||e.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(t!==i.onnx.TensorProto.DataType.UINT32&&t!==l.TensorDataType.UINT32&&t!==i.onnx.TensorProto.DataType.UINT64&&t!==l.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${i.onnx.TensorProto.DataType[t]}`);if(e.greaterThanOrEqual(4294967296)||e.lessThan(0))throw new TypeError("uint64 is not supported")}return e.toNumber()}function f(e,t,n){switch(t){case i.onnx.TensorProto.DataType.BOOL:case i.onnx.TensorProto.DataType.UINT8:return e.getUint8(n);case i.onnx.TensorProto.DataType.INT8:return e.getInt8(n);case i.onnx.TensorProto.DataType.UINT16:return e.getUint16(n,!0);case i.onnx.TensorProto.DataType.INT16:return e.getInt16(n,!0);case i.onnx.TensorProto.DataType.FLOAT:return e.getFloat32(n,!0);case i.onnx.TensorProto.DataType.INT32:return e.getInt32(n,!0);case i.onnx.TensorProto.DataType.UINT32:return e.getUint32(n,!0);case i.onnx.TensorProto.DataType.INT64:return p(a.default.fromBits(e.getUint32(n,!0),e.getUint32(n+4,!0),!1),t);case i.onnx.TensorProto.DataType.DOUBLE:return e.getFloat64(n,!0);case i.onnx.TensorProto.DataType.UINT64:return p(a.default.fromBits(e.getUint32(n,!0),e.getUint32(n+4,!0),!0),t);default:throw new Error(`cannot read from DataView for type ${i.onnx.TensorProto.DataType[t]}`)}}t.Tensor=c},2517:function(e,t,n){"use strict";var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.decodeUtf8String=t.MAX_CLIP=t.MIN_CLIP=t.PoolConvUtil=t.ReduceUtil=t.SplitUtil=t.MathUtil=t.ShapeUtil=t.LongUtil=t.ProtoUtil=t.GemmUtil=t.arrayCopyHelper=t.BroadcastUtil=t.MatMulUtil=t.ArrayUtil=t.assert=t.checkInputsShape=void 0;const s=n(5686),a=r(n(3720)),i=n(1446),o=n(9162);t.checkInputsShape=function(e,...t){if(!e||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(!e[n].dims||e[n].dims.length!==t[n])return!1;return!0},t.assert=function(e,t){if(!e)throw new Error("string"==typeof t?t:t())},t.ArrayUtil=class{static arraysEqual(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}};class u{static preprocessInputShapes(e,t){return[1===e.length?[1,e[0]]:e,1===t.length?[t[0],1]:t]}static postprocessOutputShape(e,t,n){1===t&&e.splice(e.length-2,1),1===n&&e.pop()}static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}}t.MatMulUtil=u;class l{static calcShape(e,t,n=!1){const r=e.length,s=t.length;if(0===r)return t;if(0===s)return e;const a=Math.max(e.length,t.length),i=new Array(a);if(n){if(r<2||s<2)return;const n=u.calcMatMulShape([e[r-2],e[r-1]],[t[s-2],t[s-1]]);if(void 0===n)return;[i[a-2],i[a-1]]=n}for(let o=n?3:1;o<=a;o++){const n=r-o<0?1:e[r-o],u=s-o<0?1:t[s-o];if(n!==u&&n>1&&u>1)return;i[a-o]=Math.max(n,u)}return i}static index(e,t){const n=new Array(t.length);return l.fillIndex(e,t,n),n}static fillIndex(e,t,n){const r=e.length-t.length;for(let s=0;s<t.length;s++)n[s]=e[r+s]%t[s]}static calc(e,t,n,r,s){const a=l.calcShape(e.dims,t.dims);if(a){if(r&&!d.areEqual(a,e.dims))return;const i=d.size(a),u=r?e:new o.Tensor(a,s||e.type);if(0===a.length)u.set([],n(e.get([]),t.get([])));else{const r=new Array(a.length),s=new Array(e.dims.length),o=new Array(t.dims.length);let c,h=0,d=0,p=!1,f=!1;0===e.dims.length&&(h=e.get([]),p=!0),0===t.dims.length&&(d=t.get([]),f=!0);for(let m=0;m<i;m++){c=m;for(let e=a.length-1;e>=0;e--)r[e]=c%a[e],c=Math.floor(c/a[e]);p||(l.fillIndex(r,e.dims,s),h=e.get(s)),f||(l.fillIndex(r,t.dims,o),d=t.get(o)),u.set(r,n(h,d))}}return u}}static isValidBroadcast(e,t){const n=e.length,r=t.length;if(n>r)return!1;for(let s=1;s<=n;s++)if(1!==e[n-s]&&e[n-s]!==t[r-s])return!1;return!0}static getBroadcastDims(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(a)}return r}}t.BroadcastUtil=l,t.arrayCopyHelper=function(e,t,n,r,s){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+s>t.length)throw new Error("source indices to be copied are outside bounds");if(n+s>e.length)throw new Error("target array is too small to hold result");for(let a=0;a<s;a++)e[n+a]=t[r+a]},t.GemmUtil=class{static getShapeOfGemmResult(e,t,n,r,s){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let a,i,o;t?(a=e[1],i=e[0]):(a=e[0],i=e[1]);let u=-1;if(r?(o=n[0],u=1):(o=n[1],u=0),n[u]!==i)throw new Error("dimension mismatch");if(a<=0||o<=0||i<=0)throw new Error("invalid shape specified");if(s&&!l.isValidBroadcast(s,[a,o]))throw new Error("gemm: invalid bias shape for broadcast");return[a,o,i]}};class c{static tensorDataTypeFromProto(e){switch(e){case i.onnx.TensorProto.DataType.INT8:return"int8";case i.onnx.TensorProto.DataType.UINT8:return"uint8";case i.onnx.TensorProto.DataType.BOOL:return"bool";case i.onnx.TensorProto.DataType.INT16:return"int16";case i.onnx.TensorProto.DataType.UINT16:return"uint16";case i.onnx.TensorProto.DataType.INT32:return"int32";case i.onnx.TensorProto.DataType.UINT32:return"uint32";case i.onnx.TensorProto.DataType.FLOAT:return"float32";case i.onnx.TensorProto.DataType.DOUBLE:return"float64";case i.onnx.TensorProto.DataType.STRING:return"string";case i.onnx.TensorProto.DataType.INT64:return"int32";case i.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${i.onnx.TensorProto.DataType[e]}`)}}static tensorDataTypeStringToEnum(e){switch(e){case"int8":return i.onnx.TensorProto.DataType.INT8;case"uint8":return i.onnx.TensorProto.DataType.UINT8;case"bool":return i.onnx.TensorProto.DataType.BOOL;case"int16":return i.onnx.TensorProto.DataType.INT16;case"uint16":return i.onnx.TensorProto.DataType.UINT16;case"int32":return i.onnx.TensorProto.DataType.INT32;case"uint32":return i.onnx.TensorProto.DataType.UINT32;case"float32":return i.onnx.TensorProto.DataType.FLOAT;case"float64":return i.onnx.TensorProto.DataType.DOUBLE;case"string":return i.onnx.TensorProto.DataType.STRING;case"int64":return i.onnx.TensorProto.DataType.INT64;case"uint64":return i.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${e}`)}}static tensorDimsFromProto(e){return e.map(e=>a.default.isLong(e)?e.toNumber():e)}static tensorValueTypeFromProto(e){return{tensorType:c.tensorDataTypeFromProto(e.elemType),shape:{dims:c.tensorDimsFromProto(e.shape.dim.map(e=>e.dimValue))}}}static tensorDimsFromORTFormat(e){const t=[];for(let n=0;n<e.dimsLength();n++)t.push(h.longToNumber(e.dims(n)));return t}static tensorAttributesFromORTFormat(e){const t=[];for(let n=0;n<e.attributesLength();n++)t.push(e.attributes(n));return t}}t.ProtoUtil=c;class h{static longToNumber(e,t){return a.default.isLong(e)?e.toNumber():e instanceof s.flatbuffers.Long?a.default.fromValue({low:e.low,high:e.high,unsigned:null!=t&&t}).toNumber():e}static isLong(e){return a.default.isLong(e)||e instanceof s.flatbuffers.Long}}t.LongUtil=h;class d{static size(e){return d.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return d.getSizeFromDimensionRange(e,t,e.length)}static sizeToDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${e.length} dimensions.`);return d.getSizeFromDimensionRange(e,0,t)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let s=t;s<n;s++){if(e[s]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");r*=e[s]}return r}static computeStrides(e){const t=e.length;if(0===t)return[];if(1===t)return[1];const n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static transpose(e){return e.slice().reverse()}static indicesToOffset(e,t,n){void 0===n&&(n=e.length);let r=0;for(let s=0;s<n;++s)r+=t[s]*e[s];return r}static offsetToIndices(e,t){const n=t.length;if(0===n)return[];if(1===n)return[e*t[0]];const r=new Array(t.length);for(let n=0;n<r.length-1;++n)r[n]=Math.floor(e/t[n]),e-=r[n]*t[n];return r[r.length-1]=e,r}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map(e=>this.normalizeAxis(e,t))}static incrementIndex(e,t,n){if(0===t.length||0===e.length)throw new Error("Index incrementing unsupported for scalar Tensor");if(void 0===n)n=t.length;else if(n<=0||n>t.length)throw new Error("Incorrect axis to increment on");for(let r=n-1;r>=0&&(e[r]++,!(e[r]<t[r]));--r)e[r]=0}static calculateReshapedDims(e,t){if(0===t.length){if(0===e.length||1===d.size(e))return[];throw new Error("cannot reshape to a scalar Tensor")}const n=t.length,r=new Array(n);let s=-1,a=1;for(let i=0;i<n;i++){if(t[i]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(-1===t[i]){if(-1!==s)throw new Error("at most one dimension in shape hints can be -1");s=i}else{if(0===t[i]){if(i>=e.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");r[i]=e[i]}else r[i]=t[i];a*=r[i]}}const i=d.size(e);if(-1!==s){if(i%a!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${t}]`);r[s]=i/a}else if(a!==i)throw new Error("reshapedDims and originalDims don't have matching sizes");return r}static sortBasedOnPerm(e,t){return t?t.map(t=>e[t]):e.slice().reverse()}static padShape(e,t){const n=e.length;return e.map((e,r)=>e+t[r]+t[r+n])}static areEqual(e,t){return e.length===t.length&&e.every((e,n)=>e===t[n])}static validateDimsAndCalcSize(e){if(e.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let t=1;for(const n of e){if(!Number.isInteger(n))throw new TypeError(`Invalid shape: ${n} is not an integer`);if(n<0||n>2147483647)throw new TypeError(`Invalid shape: length ${n} is not allowed`);t*=n}return t}static flattenShape(e,t){t<0&&(t+=e.length);const n=e.reduce((e,t)=>e*t,1),r=e.slice(t).reduce((e,t)=>e*t,1);return[n/r,r]}static squeezeShape(e,t){const n=new Array;t=d.normalizeAxes(t,e.length);for(let r=0;r<e.length;r++){const s=t.indexOf(r)>=0;if(s&&1!==e[r])throw new Error("squeeze an axis of size different than 1");(0===t.length&&e[r]>1||t.length>0&&!s)&&n.push(e[r])}return n}static unsqueezeShape(e,t){const n=new Array(e.length+t.length);n.fill(0);for(let e=0;e<t.length;e++){const r=d.normalizeAxis(t[e],n.length);if(r>=n.length)throw new Error("'axes' has an out of range axis");if(0!==n[r])throw new Error("'axes' has a duplicate axis");n[r]=1}let r=0;for(let t=0;t<n.length;t++)0===n[t]&&(n[t]=e[r++]);if(r!==e.length)throw new Error("the unsqueezed dimension could not be established");return n}}t.ShapeUtil=d,t.MathUtil=class{static sqr(e,t,n,r,s){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+s>t.length)throw new Error("source indices to be copied are outside bounds");if(n+s>e.length)throw new Error("target array is too small to hold result");for(let a=0;a<s;a++)e[n+a]+=Math.pow(t[r+a],2)}static axpy(e,t,n,r,s,a){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+s>t.length)throw new Error("source indices to be copied are outside bounds");if(n+s>e.length)throw new Error("target array is too small to hold result");for(let i=0;i<s;i++)e[n+i]+=a*t[r+i]}static powx(e,t,n,r,s,a){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+s>t.length)throw new Error("source indices to be copied are outside bounds");if(n+s>e.length)throw new Error("target array is too small to hold result");for(let i=0;i<s;i++)e[n+i]=Math.pow(t[r+i],a)}static mul(e,t,n,r,s){if(r<0||r>=t.length)throw new Error("sourceIndex out of bounds");if(n<0||n>=e.length)throw new Error("targetIndex out of bounds");if(r+s>t.length)throw new Error("source indices to be copied are outside bounds");if(n+s>e.length)throw new Error("target array is too small to hold result");for(let a=0;a<s;a++)e[n+a]=t[r+a]*e[n+a]}};class p{static splitShape(e,t,n,r){if(0===n.length){if(!r)throw new Error("need to know number of outputs when the 'split' attribute is not specified");p.determineSplit(e[t],r,n)}const s=[],a=[0];for(let r=0;r<n.length;++r){0!==r&&a.push(a[r-1]+n[r-1]);const i=e.slice();i[t]=n[r],s.push(i)}return[s,a]}static determineSplit(e,t,n){if(e%t!=0)throw new Error("cannot split tensor to equal sized parts");for(let r=0;r<t;++r)n.push(e/t)}}t.SplitUtil=p;class f{static calcReduce(e,t,n,r,s){const a=e.dims.slice(0);0===t.length&&a.forEach((e,n)=>t.push(n));const i=f.calcReduceShape(a,t,!0),u=d.size(i),c=new o.Tensor(i,e.type),h=d.computeStrides(i),p=d.computeStrides(a),m=new Array(a.length);for(let n=0;n<u;n++){const i=d.offsetToIndices(n,h);l.fillIndex(i,a,m),c.set(i,f.calcReduceByAxis(e.numberData,t,a,0,d.indicesToOffset(m,p),r,s))}return n?c:new o.Tensor(f.calcReduceShape(a,t,n),c.type,void 0,void 0,c.data,c.dataId)}static calcReduceByAxis(e,t,n,r,s,a,i){let o=0;if(r>=t.length)return a(e[s]);const u=t[r],l=u>=n.length?1:d.size(n.slice(u+1));for(let c=0;c<n[u];c++)o=0===c?f.calcReduceByAxis(e,t,n,r+1,s,a,i):i(o,f.calcReduceByAxis(e,t,n,r+1,s,a,i)),s+=l;return o}static calcReduceShape(e,t,n){const r=e.slice();for(let e=0;e<t.length;e++)r[t[e]]=n?1:0;return r.filter(e=>0!==e)}}t.ReduceUtil=f;class m{static adjustPoolAttributes(e,t,n,r,s,a){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<s.length){if(s[e]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let e=0;e<2*n.length;e++)if(e<a.length){if(a[e]<0)throw new Error("pad should be greater than or equal to 1")}else a.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(a[e]>=n[e]||a[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,t,n,r,s,a){if(a){if(s.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let i=0;i<e.length-2;i++)m.adjustPadAndReturnShape(e[i+2],t[i],n[i],r[i],s,i,i+e.length-2,a)}}static computePoolOutputShape(e,t,n,r,s,a,i){if(t.length<=0)throw new Error("input shape must be of size greater than 0");const o=[t[0],t[1]];return m.computeShapeHelper(e,t,o,n,r,s,a,i),o}static computeConvOutputShape(e,t,n,r,s,a,i){if(e.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const o=[e[0],t[0]];return m.computeShapeHelper(!1,e,o,n,r,s,a,i),o}static computeShapeHelper(e,t,n,r,s,a,i,o){if(e)for(let e=0;e<t.length-2;e++)n.push(1);else for(let e=0;e<t.length-2;e++)n.push(m.adjustPadAndReturnShape(t[e+2],r[e],s[e],a[e],i,e,e+t.length-2,o))}static adjustPadAndReturnShape(e,t,n,r,s,a,i,o){const u=n*(r-1)+1;if(!o||"NOTSET"===o)return Math.floor((e+s[a]+s[i]-u)/t+1);switch(o){case"VALID":return s[a]=0,s[i]=0,Math.floor((e-u)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const n=((e+t-1)/t-1)*t+r-e;return s[a]="SAME_LOWER"===o?Math.floor((n+1)/2):Math.floor(n/2),s[i]=n-s[a],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}}t.PoolConvUtil=m,t.MIN_CLIP=-34028234663852886e22,t.MAX_CLIP=34028234663852886e22,t.decodeUtf8String=function(e){return(new TextDecoder).decode(e)}},7967:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,n,r,s)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([e,a])=>{const i=n?n+e:e;if("object"==typeof a)(0,t.iterateExtraOptions)(a,i+".",r,s);else if("string"==typeof a||"number"==typeof a)s(i,a.toString());else{if("boolean"!=typeof a)throw new Error("Can't handle extra config type: "+typeof a);s(i,a?"1":"0")}})}},2157:function(e,t,n){"use strict";var r,s=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var s=Object.getOwnPropertyDescriptor(t,n);s&&!("get"in s?!t.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,s)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&s(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=t.initWasm=void 0;const o=n(1670),u=i(n(349)),l=n(6361),c=()=>!!o.env.wasm.proxy&&"undefined"!=typeof document;let h,d,p,f=!1,m=!1,g=!1;const b=[],y=[],x=[],w=[],v=[],_=[],k=()=>{if(f||!m||g||!h)throw new Error("worker not ready")},T=e=>{switch(e.data.type){case"init-wasm":f=!1,e.data.err?(g=!0,d[1](e.data.err)):(m=!0,d[0]());break;case"init-ort":e.data.err?p[1](e.data.err):p[0]();break;case"create_allocate":e.data.err?b.shift()[1](e.data.err):b.shift()[0](e.data.out);break;case"create_finalize":e.data.err?y.shift()[1](e.data.err):y.shift()[0](e.data.out);break;case"create":e.data.err?x.shift()[1](e.data.err):x.shift()[0](e.data.out);break;case"release":e.data.err?w.shift()[1](e.data.err):w.shift()[0]();break;case"run":e.data.err?v.shift()[1](e.data.err):v.shift()[0](e.data.out);break;case"end-profiling":e.data.err?_.shift()[1](e.data.err):_.shift()[0]()}},S="undefined"!=typeof document?null===(r=null===document||void 0===document?void 0:document.currentScript)||void 0===r?void 0:r.src:void 0;t.initWasm=async()=>{if(c()){if(m)return;if(f)throw new Error("multiple calls to 'initWasm()' detected.");if(g)throw new Error("previous call to 'initWasm()' failed.");return f=!0,void 0===o.env.wasm.wasmPaths&&S&&0!==S.indexOf("blob:")&&(o.env.wasm.wasmPaths=S.substr(0,+S.lastIndexOf("/")+1)),new Promise((e,t)=>{null==h||h.terminate(),h=n(9710).Z(),h.onmessage=T,d=[e,t];const r={type:"init-wasm",in:o.env.wasm};h.postMessage(r)})}return(0,l.initializeWebAssembly)(o.env.wasm)},t.initOrt=async(e,t)=>{if(c())return k(),new Promise((n,r)=>{p=[n,r];const s={type:"init-ort",in:{numThreads:e,loggingLevel:t}};h.postMessage(s)});u.initOrt(e,t)},t.createSessionAllocate=async e=>c()?(k(),new Promise((t,n)=>{b.push([t,n]);const r={type:"create_allocate",in:{model:e}};h.postMessage(r,[e.buffer])})):u.createSessionAllocate(e),t.createSessionFinalize=async(e,t)=>c()?(k(),new Promise((n,r)=>{y.push([n,r]);const s={type:"create_finalize",in:{modeldata:e,options:t}};h.postMessage(s)})):u.createSessionFinalize(e,t),t.createSession=async(e,t)=>c()?(k(),new Promise((n,r)=>{x.push([n,r]);const s={type:"create",in:{model:e,options:t}};h.postMessage(s,[e.buffer])})):u.createSession(e,t),t.releaseSession=async e=>{if(c())return k(),new Promise((t,n)=>{w.push([t,n]);const r={type:"release",in:e};h.postMessage(r)});u.releaseSession(e)},t.run=async(e,t,n,r,s)=>c()?(k(),new Promise((a,i)=>{v.push([a,i]);const o={type:"run",in:{sessionId:e,inputIndices:t,inputs:n,outputIndices:r,options:s}};h.postMessage(o,u.extractTransferableBuffers(n))})):u.run(e,t,n,r,s),t.endProfiling=async e=>{if(c())return k(),new Promise((t,n)=>{_.push([t,n]);const r={type:"end-profiling",in:e};h.postMessage(r)});u.endProfiling(e)}},586:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(7967),s=n(4983),a=n(6361);t.setRunOptions=e=>{const t=(0,a.getInstance)();let n=0;const i=[],o=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))o.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))o.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(o.terminate=!1);let a=0;if(void 0!==(null==e?void 0:e.tag)&&(a=(0,s.allocWasmString)(e.tag,i)),n=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,a),0===n)throw new Error("Can't create run options");return void 0!==(null==e?void 0:e.extra)&&(0,r.iterateExtraOptions)(e.extra,"",new WeakSet,(e,r)=>{const a=(0,s.allocWasmString)(e,i),o=(0,s.allocWasmString)(r,i);if(0!==t._OrtAddRunConfigEntry(n,a,o))throw new Error(`Can't set a run config entry: ${e} - ${r}`)}),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach(t._free),e}}},2306:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.OnnxruntimeWebAssemblySessionHandler=void 0;const r=n(2806),s=n(1670),a=n(2850),i=n(2157);let o;t.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(e){const t=await fetch(e),n=await t.arrayBuffer();return(0,i.createSessionAllocate)(new Uint8Array(n))}async loadModel(e,t){if(o||(await(0,i.initOrt)(s.env.wasm.numThreads,(e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}})(s.env.logLevel)),o=!0),"string"==typeof e)if("undefined"==typeof fetch){const n=await(0,a.promisify)(r.readFile)(e);[this.sessionId,this.inputNames,this.outputNames]=await(0,i.createSession)(n,t)}else{const n=await this.createSessionAllocate(e);[this.sessionId,this.inputNames,this.outputNames]=await(0,i.createSessionFinalize)(n,t)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,i.createSession)(e,t)}async dispose(){return(0,i.releaseSession)(this.sessionId)}async run(e,t,n){const r=[],a=[];Object.entries(e).forEach(e=>{const t=e[0],n=e[1],s=this.inputNames.indexOf(t);if(-1===s)throw new Error(`invalid input '${t}'`);r.push(n),a.push(s)});const o=[];Object.entries(t).forEach(e=>{const t=e[0],n=this.outputNames.indexOf(t);if(-1===n)throw new Error(`invalid output '${t}'`);o.push(n)});const u=await(0,i.run)(this.sessionId,a,r.map(e=>[e.type,e.dims,e.data]),o,n),l={};for(let e=0;e<u.length;e++)l[this.outputNames[o[e]]]=new s.Tensor(u[e][0],u[e][2],u[e][1]);return l}startProfiling(){}endProfiling(){(0,i.endProfiling)(this.sessionId)}}},4919:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(7967),s=n(4983),a=n(6361);t.setSessionOptions=e=>{const t=(0,a.getInstance)();let n=0;const i=[],o=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1")})(o);try{void 0===(null==e?void 0:e.graphOptimizationLevel)&&(o.graphOptimizationLevel="all");const u=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(o.graphOptimizationLevel);void 0===(null==e?void 0:e.enableCpuMemArena)&&(o.enableCpuMemArena=!0),void 0===(null==e?void 0:e.enableMemPattern)&&(o.enableMemPattern=!0),void 0===(null==e?void 0:e.executionMode)&&(o.executionMode="sequential");const l=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(o.executionMode);let c=0;if(void 0!==(null==e?void 0:e.logId)&&(c=(0,s.allocWasmString)(e.logId,i)),void 0===(null==e?void 0:e.logSeverityLevel))o.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))o.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);if(void 0===(null==e?void 0:e.enableProfiling)&&(o.enableProfiling=!1),n=t._OrtCreateSessionOptions(u,!!o.enableCpuMemArena,!!o.enableMemPattern,l,!!o.enableProfiling,0,c,o.logSeverityLevel,o.logVerbosityLevel),0===n)throw new Error("Can't create session options");return(null==e?void 0:e.executionProviders)&&((e,t,n)=>{for(const r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${t}`)}const i=(0,s.allocWasmString)(t,n);if(0!==(0,a.getInstance)()._OrtAppendExecutionProvider(e,i))throw new Error(`Can't append execution provider: ${t}`)}})(n,e.executionProviders,i),void 0!==(null==e?void 0:e.extra)&&(0,r.iterateExtraOptions)(e.extra,"",new WeakSet,(e,r)=>{const a=(0,s.allocWasmString)(e,i),o=(0,s.allocWasmString)(r,i);if(0!==t._OrtAddSessionConfigEntry(n,a,o))throw new Error(`Can't set a session config entry: ${e} - ${r}`)}),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseSessionOptions(n),i.forEach(t._free),e}}},4983:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const r=n(6361);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),s=n.lengthBytesUTF8(e)+1,a=n._malloc(s);return n.stringToUTF8(e,a,s),t.push(a),a}},349:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const r=n(586),s=n(4919),a=n(4983),i=n(6361);t.initOrt=(e,t)=>{const n=(0,i.getInstance)()._OrtInit(e,t);if(0!==n)throw new Error(`Can't initialize onnxruntime. error code = ${n}`)};const o=new Map;t.createSessionAllocate=e=>{const t=(0,i.getInstance)(),n=t._malloc(e.byteLength);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,i.getInstance)();let r=0,a=0,u=[];try{if([a,u]=(0,s.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],a),0===r)throw new Error("Can't create a session")}finally{n._free(e[0]),n._OrtReleaseSessionOptions(a),u.forEach(n._free)}const l=n._OrtGetInputCount(r),c=n._OrtGetOutputCount(r),h=[],d=[],p=[],f=[];for(let e=0;e<l;e++){const t=n._OrtGetInputName(r,e);if(0===t)throw new Error("Can't get an input name");d.push(t),h.push(n.UTF8ToString(t))}for(let e=0;e<c;e++){const t=n._OrtGetOutputName(r,e);if(0===t)throw new Error("Can't get an output name");f.push(t),p.push(n.UTF8ToString(t))}return o.set(r,[r,d,f]),[r,h,p]},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,i.getInstance)(),n=o.get(e);if(!n)throw new Error("invalid session id");const r=n[0],s=n[1],a=n[2];s.forEach(t._OrtFree),a.forEach(t._OrtFree),t._OrtReleaseSession(r),o.delete(e)};const u=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},l=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},c=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}};t.run=(e,t,n,s,h)=>{const d=(0,i.getInstance)(),p=o.get(e);if(!p)throw new Error("invalid session id");const f=p[0],m=p[1],g=p[2],b=t.length,y=s.length;let x=0,w=[];const v=[],_=[];try{[x,w]=(0,r.setRunOptions)(h);for(let e=0;e<b;e++){const t=n[e][0],r=n[e][1],s=n[e][2];let i,o;if(Array.isArray(s)){o=4*s.length,i=d._malloc(o),_.push(i);let e=i/4;for(let t=0;t<s.length;t++){if("string"!=typeof s[t])throw new TypeError(`tensor data at index ${t} is not a string`);d.HEAPU32[e++]=(0,a.allocWasmString)(s[t],_)}}else o=s.byteLength,i=d._malloc(o),_.push(i),d.HEAPU8.set(new Uint8Array(s.buffer,s.byteOffset,o),i);const l=d.stackSave(),c=d.stackAlloc(4*r.length);try{let e=c/4;r.forEach(t=>d.HEAP32[e++]=t);const n=d._OrtCreateTensor(u(t),i,o,c,r.length);if(0===n)throw new Error("Can't create a tensor");v.push(n)}finally{d.stackRestore(l)}}const e=d.stackSave(),i=d.stackAlloc(4*b),o=d.stackAlloc(4*b),p=d.stackAlloc(4*y),k=d.stackAlloc(4*y);try{let e=i/4,n=o/4,r=p/4,a=k/4;for(let r=0;r<b;r++)d.HEAPU32[e++]=v[r],d.HEAPU32[n++]=m[t[r]];for(let e=0;e<y;e++)d.HEAPU32[r++]=0,d.HEAPU32[a++]=g[s[e]];let u=d._OrtRun(f,o,i,b,k,y,p,x);const h=[];if(0===u)for(let e=0;e<y;e++){const t=d.HEAPU32[p/4+e],n=d.stackSave(),r=d.stackAlloc(16);let s,a=0;try{if(u=d._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==u)throw new Error(`Can't access output tensor data. error code = ${u}`);let e=r/4;const n=d.HEAPU32[e++];a=d.HEAPU32[e++];const i=d.HEAPU32[e++],o=d.HEAPU32[e++],p=[];for(let e=0;e<o;e++)p.push(d.HEAPU32[i/4+e]);d._OrtFree(i);const f=0===p.length?1:p.reduce((e,t)=>e*t);if(s=l(n),"string"===s){const e=[];let t=a/4;for(let n=0;n<f;n++){const r=d.HEAPU32[t++],s=n===f-1?void 0:d.HEAPU32[t]-r;e.push(d.UTF8ToString(r,s))}h.push([s,p,e])}else{const e=new(c(s))(f);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(d.HEAPU8.subarray(a,a+e.byteLength)),h.push([s,p,e])}}finally{d.stackRestore(n),"string"===s&&a&&d._free(a),d._OrtReleaseTensor(t)}}if(0===u)return h;throw new Error(`failed to call OrtRun(). error code = ${u}.`)}finally{d.stackRestore(e)}}finally{v.forEach(d._OrtReleaseTensor),_.forEach(d._free),d._OrtReleaseRunOptions(x),w.forEach(d._free)}},t.endProfiling=e=>{const t=(0,i.getInstance)(),n=o.get(e);if(!n)throw new Error("invalid session id");const r=n[0],s=t._OrtEndProfiling(r);if(0===s)throw new Error("Can't get an profile file name");t._OrtFree(s)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},6361:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var s=Object.getOwnPropertyDescriptor(t,n);s&&!("get"in s?!t.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,s)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return s(t,e),t},i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const o=a(n(6449)),u=i(n(932)),l=n(3474);let c,h=!1,d=!1,p=!1;const f=(e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm";t.initializeWebAssembly=async e=>{if(h)return Promise.resolve();if(d)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(p)throw new Error("previous call to 'initializeWebAssembly()' failed.");d=!0;const t=e.initTimeout,r=e.numThreads,s=e.simd,a=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),i=s&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),m="string"==typeof e.wasmPaths?e.wasmPaths:void 0,g=f(!1,a),b=f(i,a),y="object"==typeof e.wasmPaths?e.wasmPaths[b]:void 0;let x=!1;const w=[];if(t>0&&w.push(new Promise(e=>{setTimeout(()=>{x=!0,e()},t)})),w.push(new Promise((e,t)=>{const r=a?l:u.default,s={locateFile:(e,t)=>a&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(4154)],{type:"text/javascript"})):e===g?null!=y?y:(null!=m?m:t)+b:t+e};if(a)if("undefined"==typeof Blob)s.mainScriptUrlOrBlob=o.join("/","ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;s.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(s).then(t=>{d=!1,h=!0,c=t,e()},e=>{d=!1,p=!0,t(e)})})),await Promise.race(w),x)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(h&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!h||d||p||(d=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,d=!1,h=!1,p=!0)}},9710:(e,t,n)=>{"use strict";n.d(t,{Z:()=>a});var r=n(477),s=n.n(r);function a(){return s()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n',"Worker",void 0,void 0)}},477:e=>{"use strict";e.exports=function(e,t,n,r){var s=self||window;try{try{var a;try{a=new s.Blob([e])}catch(t){(a=new(s.BlobBuilder||s.WebKitBlobBuilder||s.MozBlobBuilder||s.MSBlobBuilder)).append(e),a=a.getBlob()}var i=s.URL||s.webkitURL,o=i.createObjectURL(a),u=new s[t](o,n);return i.revokeObjectURL(o),u}catch(r){return new s[t]("data:application/javascript,".concat(encodeURIComponent(e)),n)}}catch(e){if(!r)throw Error("Inline worker is not supported");return new s[t](r,n)}}},4154:e=>{"use strict";e.exports='"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n'},1670:e=>{"use strict";e.exports=__WEBPACK_EXTERNAL_MODULE__1670__},7067:()=>{},1296:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(e,t,n)=>{"use strict";n.r(t),n.d(t,{flatbuffers:()=>r});var r={};r.Offset,r.Table,r.SIZEOF_SHORT=2,r.SIZEOF_INT=4,r.FILE_IDENTIFIER_LENGTH=4,r.SIZE_PREFIX_LENGTH=4,r.Encoding={UTF8_BYTES:1,UTF16_STRING:2},r.int32=new Int32Array(2),r.float32=new Float32Array(r.int32.buffer),r.float64=new Float64Array(r.int32.buffer),r.isLittleEndian=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0],r.Long=function(e,t){this.low=0|e,this.high=0|t},r.Long.create=function(e,t){return 0==e&&0==t?r.Long.ZERO:new r.Long(e,t)},r.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},r.Long.prototype.equals=function(e){return this.low==e.low&&this.high==e.high},r.Long.ZERO=new r.Long(0,0),r.Builder=function(e){if(e)t=e;else var t=1024;this.bb=r.ByteBuffer.allocate(t),this.space=t,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},r.Builder.prototype.forceDefaults=function(e){this.force_defaults=e},r.Builder.prototype.dataBuffer=function(){return this.bb},r.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},r.Builder.prototype.prep=function(e,t){e>this.minalign&&(this.minalign=e);for(var n=1+~(this.bb.capacity()-this.space+t)&e-1;this.space<n+e+t;){var s=this.bb.capacity();this.bb=r.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-s}this.pad(n)},r.Builder.prototype.pad=function(e){for(var t=0;t<e;t++)this.bb.writeInt8(--this.space,0)},r.Builder.prototype.writeInt8=function(e){this.bb.writeInt8(this.space-=1,e)},r.Builder.prototype.writeInt16=function(e){this.bb.writeInt16(this.space-=2,e)},r.Builder.prototype.writeInt32=function(e){this.bb.writeInt32(this.space-=4,e)},r.Builder.prototype.writeInt64=function(e){this.bb.writeInt64(this.space-=8,e)},r.Builder.prototype.writeFloat32=function(e){this.bb.writeFloat32(this.space-=4,e)},r.Builder.prototype.writeFloat64=function(e){this.bb.writeFloat64(this.space-=8,e)},r.Builder.prototype.addInt8=function(e){this.prep(1,0),this.writeInt8(e)},r.Builder.prototype.addInt16=function(e){this.prep(2,0),this.writeInt16(e)},r.Builder.prototype.addInt32=function(e){this.prep(4,0),this.writeInt32(e)},r.Builder.prototype.addInt64=function(e){this.prep(8,0),this.writeInt64(e)},r.Builder.prototype.addFloat32=function(e){this.prep(4,0),this.writeFloat32(e)},r.Builder.prototype.addFloat64=function(e){this.prep(8,0),this.writeFloat64(e)},r.Builder.prototype.addFieldInt8=function(e,t,n){(this.force_defaults||t!=n)&&(this.addInt8(t),this.slot(e))},r.Builder.prototype.addFieldInt16=function(e,t,n){(this.force_defaults||t!=n)&&(this.addInt16(t),this.slot(e))},r.Builder.prototype.addFieldInt32=function(e,t,n){(this.force_defaults||t!=n)&&(this.addInt32(t),this.slot(e))},r.Builder.prototype.addFieldInt64=function(e,t,n){!this.force_defaults&&t.equals(n)||(this.addInt64(t),this.slot(e))},r.Builder.prototype.addFieldFloat32=function(e,t,n){(this.force_defaults||t!=n)&&(this.addFloat32(t),this.slot(e))},r.Builder.prototype.addFieldFloat64=function(e,t,n){(this.force_defaults||t!=n)&&(this.addFloat64(t),this.slot(e))},r.Builder.prototype.addFieldOffset=function(e,t,n){(this.force_defaults||t!=n)&&(this.addOffset(t),this.slot(e))},r.Builder.prototype.addFieldStruct=function(e,t,n){t!=n&&(this.nested(t),this.slot(e))},r.Builder.prototype.nested=function(e){if(e!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},r.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},r.Builder.prototype.slot=function(e){this.vtable[e]=this.offset()},r.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},r.Builder.growByteBuffer=function(e){var t=e.capacity();if(3221225472&t)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var n=t<<1,s=r.ByteBuffer.allocate(n);return s.setPosition(n-t),s.bytes().set(e.bytes(),n-t),s},r.Builder.prototype.addOffset=function(e){this.prep(r.SIZEOF_INT,0),this.writeInt32(this.offset()-e+r.SIZEOF_INT)},r.Builder.prototype.startObject=function(e){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=e;for(var t=0;t<e;t++)this.vtable[t]=0;this.isNested=!0,this.object_start=this.offset()},r.Builder.prototype.endObject=function(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var e=this.offset(),t=this.vtable_in_use-1;t>=0&&0==this.vtable[t];t--);for(var n=t+1;t>=0;t--)this.addInt16(0!=this.vtable[t]?e-this.vtable[t]:0);this.addInt16(e-this.object_start);var s=(n+2)*r.SIZEOF_SHORT;this.addInt16(s);var a=0,i=this.space;e:for(t=0;t<this.vtables.length;t++){var o=this.bb.capacity()-this.vtables[t];if(s==this.bb.readInt16(o)){for(var u=r.SIZEOF_SHORT;u<s;u+=r.SIZEOF_SHORT)if(this.bb.readInt16(i+u)!=this.bb.readInt16(o+u))continue e;a=this.vtables[t];break}}return a?(this.space=this.bb.capacity()-e,this.bb.writeInt32(this.space,a-e)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-e,this.offset()-e)),this.isNested=!1,e},r.Builder.prototype.finish=function(e,t,n){var s=n?r.SIZE_PREFIX_LENGTH:0;if(t){var a=t;if(this.prep(this.minalign,r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH+s),a.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+r.FILE_IDENTIFIER_LENGTH);for(var i=r.FILE_IDENTIFIER_LENGTH-1;i>=0;i--)this.writeInt8(a.charCodeAt(i))}this.prep(this.minalign,r.SIZEOF_INT+s),this.addOffset(e),s&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},r.Builder.prototype.finishSizePrefixed=function(e,t){this.finish(e,t,!0)},r.Builder.prototype.requiredField=function(e,t){var n=this.bb.capacity()-e,r=n-this.bb.readInt32(n);if(0==this.bb.readInt16(r+t))throw new Error("FlatBuffers: field "+t+" must be set")},r.Builder.prototype.startVector=function(e,t,n){this.notNested(),this.vector_num_elems=t,this.prep(r.SIZEOF_INT,e*t),this.prep(n,e*t)},r.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},r.Builder.prototype.createString=function(e){if(e instanceof Uint8Array)var t=e;else{t=[];for(var n=0;n<e.length;){var r,s=e.charCodeAt(n++);(r=s<55296||s>=56320?s:(s<<10)+e.charCodeAt(n++)+-56613888)<128?t.push(r):(r<2048?t.push(r>>6&31|192):(r<65536?t.push(r>>12&15|224):t.push(r>>18&7|240,r>>12&63|128),t.push(r>>6&63|128)),t.push(63&r|128))}}this.addInt8(0),this.startVector(1,t.length,1),this.bb.setPosition(this.space-=t.length),n=0;for(var a=this.space,i=this.bb.bytes();n<t.length;n++)i[a++]=t[n];return this.endVector()},r.Builder.prototype.createLong=function(e,t){return r.Long.create(e,t)},r.ByteBuffer=function(e){this.bytes_=e,this.position_=0},r.ByteBuffer.allocate=function(e){return new r.ByteBuffer(new Uint8Array(e))},r.ByteBuffer.prototype.clear=function(){this.position_=0},r.ByteBuffer.prototype.bytes=function(){return this.bytes_},r.ByteBuffer.prototype.position=function(){return this.position_},r.ByteBuffer.prototype.setPosition=function(e){this.position_=e},r.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},r.ByteBuffer.prototype.readInt8=function(e){return this.readUint8(e)<<24>>24},r.ByteBuffer.prototype.readUint8=function(e){return this.bytes_[e]},r.ByteBuffer.prototype.readInt16=function(e){return this.readUint16(e)<<16>>16},r.ByteBuffer.prototype.readUint16=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8},r.ByteBuffer.prototype.readInt32=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8|this.bytes_[e+2]<<16|this.bytes_[e+3]<<24},r.ByteBuffer.prototype.readUint32=function(e){return this.readInt32(e)>>>0},r.ByteBuffer.prototype.readInt64=function(e){return new r.Long(this.readInt32(e),this.readInt32(e+4))},r.ByteBuffer.prototype.readUint64=function(e){return new r.Long(this.readUint32(e),this.readUint32(e+4))},r.ByteBuffer.prototype.readFloat32=function(e){return r.int32[0]=this.readInt32(e),r.float32[0]},r.ByteBuffer.prototype.readFloat64=function(e){return r.int32[r.isLittleEndian?0:1]=this.readInt32(e),r.int32[r.isLittleEndian?1:0]=this.readInt32(e+4),r.float64[0]},r.ByteBuffer.prototype.writeInt8=function(e,t){this.bytes_[e]=t},r.ByteBuffer.prototype.writeUint8=function(e,t){this.bytes_[e]=t},r.ByteBuffer.prototype.writeInt16=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8},r.ByteBuffer.prototype.writeUint16=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8},r.ByteBuffer.prototype.writeInt32=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8,this.bytes_[e+2]=t>>16,this.bytes_[e+3]=t>>24},r.ByteBuffer.prototype.writeUint32=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8,this.bytes_[e+2]=t>>16,this.bytes_[e+3]=t>>24},r.ByteBuffer.prototype.writeInt64=function(e,t){this.writeInt32(e,t.low),this.writeInt32(e+4,t.high)},r.ByteBuffer.prototype.writeUint64=function(e,t){this.writeUint32(e,t.low),this.writeUint32(e+4,t.high)},r.ByteBuffer.prototype.writeFloat32=function(e,t){r.float32[0]=t,this.writeInt32(e,r.int32[0])},r.ByteBuffer.prototype.writeFloat64=function(e,t){r.float64[0]=t,this.writeInt32(e,r.int32[r.isLittleEndian?0:1]),this.writeInt32(e+4,r.int32[r.isLittleEndian?1:0])},r.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+r.SIZEOF_INT+r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var e="",t=0;t<r.FILE_IDENTIFIER_LENGTH;t++)e+=String.fromCharCode(this.readInt8(this.position_+r.SIZEOF_INT+t));return e},r.ByteBuffer.prototype.__offset=function(e,t){var n=e-this.readInt32(e);return t<this.readInt16(n)?this.readInt16(n+t):0},r.ByteBuffer.prototype.__union=function(e,t){return e.bb_pos=t+this.readInt32(t),e.bb=this,e},r.ByteBuffer.prototype.__string=function(e,t){e+=this.readInt32(e);var n=this.readInt32(e),s="",a=0;if(e+=r.SIZEOF_INT,t===r.Encoding.UTF8_BYTES)return this.bytes_.subarray(e,e+n);for(;a<n;){var i,o=this.readUint8(e+a++);if(o<192)i=o;else{var u=this.readUint8(e+a++);if(o<224)i=(31&o)<<6|63&u;else{var l=this.readUint8(e+a++);i=o<240?(15&o)<<12|(63&u)<<6|63&l:(7&o)<<18|(63&u)<<12|(63&l)<<6|63&this.readUint8(e+a++)}}i<65536?s+=String.fromCharCode(i):(i-=65536,s+=String.fromCharCode(55296+(i>>10),56320+(1023&i)))}return s},r.ByteBuffer.prototype.__indirect=function(e){return e+this.readInt32(e)},r.ByteBuffer.prototype.__vector=function(e){return e+this.readInt32(e)+r.SIZEOF_INT},r.ByteBuffer.prototype.__vector_len=function(e){return this.readInt32(e+this.readInt32(e))},r.ByteBuffer.prototype.__has_identifier=function(e){if(e.length!=r.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+r.FILE_IDENTIFIER_LENGTH);for(var t=0;t<r.FILE_IDENTIFIER_LENGTH;t++)if(e.charCodeAt(t)!=this.readInt8(this.position_+r.SIZEOF_INT+t))return!1;return!0},r.ByteBuffer.prototype.createLong=function(e,t){return r.Long.create(e,t)}}},__webpack_module_cache__={};function __nested_webpack_require_546802__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(n.exports,n,n.exports,__nested_webpack_require_546802__),n.exports}__nested_webpack_require_546802__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __nested_webpack_require_546802__.d(t,{a:t}),t},__nested_webpack_require_546802__.d=(e,t)=>{for(var n in t)__nested_webpack_require_546802__.o(t,n)&&!__nested_webpack_require_546802__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__nested_webpack_require_546802__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__nested_webpack_require_546802__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__nested_webpack_require_546802__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __nested_webpack_exports__=__nested_webpack_require_546802__(6018);return __nested_webpack_exports__})(),module.exports=e(__webpack_require__(450))},391:(e,t,n)=>{var r=n(180),s=n(181),a=n(31),i=n(67),o=n(833),u=n(717),l=n(801);l.alea=r,l.xor128=s,l.xorwow=a,l.xorshift7=i,l.xor4096=o,l.tychei=u,e.exports=l},450:(e,t,n)=>{"use strict";n.r(t),n.d(t,{InferenceSession:()=>f,Tensor:()=>d,env:()=>i,registerBackend:()=>a});const r={},s=[],a=(e,t,n)=>{if(t&&"function"==typeof t.init&&"function"==typeof t.createSessionHandler){const a=r[e];if(void 0===a)r[e]={backend:t,priority:n};else{if(a.priority>n)return;if(a.priority===n&&a.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){const t=s.indexOf(e);-1!==t&&s.splice(t,1);for(let t=0;t<s.length;t++)if(r[s[t]].priority<=n)return void s.splice(t,0,e);s.push(e)}return}throw new TypeError("not a valid backend")},i=new class{constructor(){this.wasm={},this.webgl={},this.logLevelInternal="warning"}set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);this.logLevelInternal=e}}get logLevel(){return this.logLevelInternal}},o="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,u="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from,l=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),c=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);o&&(l.set("int64",BigInt64Array),c.set(BigInt64Array,"int64")),u&&(l.set("uint64",BigUint64Array),c.set(BigUint64Array,"uint64"));class h{constructor(e,t,n){let r,s,a;if("string"==typeof e)if(r=e,a=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");s=t}else{const n=l.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t))s=n.from(t);else{if(!(t instanceof n))throw new TypeError(`A ${r} tensor's data must be type of ${n}`);s=t}}else if(a=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const t=typeof e[0];if("string"===t)r="string",s=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",s=Uint8Array.from(e)}}else{const t=c.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,s=e}if(void 0===a)a=[s.length];else if(!Array.isArray(a))throw new TypeError("A tensor's dims must be a number array");const i=(e=>{let t=1;for(let n=0;n<e.length;n++){const r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t})(a);if(i!==s.length)throw new Error(`Tensor's size(${i}) does not match data length(${s.length}).`);this.dims=a,this.type=r,this.data=s,this.size=i}static bufferToTensor(e,t){if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");const{height:n,width:r}=t,s=t.norm;let a,i;a=void 0===s||void 0===s.mean?255:s.mean,i=void 0===s||void 0===s.bias?0:s.bias;const o=void 0!==t.bitmapFormat?t.bitmapFormat:"RGBA",u=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",l=n*r,c="RGBA"===u?new Float32Array(4*l):new Float32Array(3*l);let d=4,p=0,f=1,m=2,g=3,b=0,y=l,x=2*l,w=-1;"RGB"===o&&(d=3,p=0,f=1,m=2,g=-1),"RGBA"===u?w=3*l:"RBG"===u?(b=0,x=l,y=2*l):"BGR"===u&&(x=0,y=l,b=2*l);for(let t=0;t<l;t++,p+=d,m+=d,f+=d,g+=d)c[b++]=(e[p]+i)/a,c[y++]=(e[f]+i)/a,c[x++]=(e[m]+i)/a,-1!==w&&-1!==g&&(c[w++]=(e[g]+i)/a);return new h("float32",c,"RGBA"===u?[1,4,n,r]:[1,3,n,r])}static async fromImage(e,t){const n="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,r="undefined"!=typeof ImageData&&e instanceof ImageData,s="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,a="undefined"!=typeof String&&(e instanceof String||"string"==typeof e);let i,o={};if(n){const n=document.createElement("canvas"),r=n.getContext("2d");if(null==r)throw new Error("Can not access image data");{let s=e.naturalHeight,a=e.naturalWidth;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(s=t.resizedHeight,a=t.resizedWidth),void 0!==t){if(o=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(o.tensorFormat="RGBA",void 0!==t.height&&t.height!==s)throw new Error("Image input config height doesn't match HTMLImageElement height");if(o.height=s,void 0!==t.width&&t.width!==a)throw new Error("Image input config width doesn't match HTMLImageElement width");o.width=a}else o.tensorFormat="RGBA",o.height=s,o.width=a;n.width=a,n.height=s,r.drawImage(e,0,0,a,s),i=r.getImageData(0,0,a,s).data}}else{if(!r){if(s){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");if(void 0!==t.bitmapFormat)throw new Error("Image input config format must be defined for ImageBitmap");const n=document.createElement("canvas").getContext("2d");if(null!=n){const r=e.height,s=e.width;if(n.drawImage(e,0,0,s,r),i=n.getImageData(0,0,s,r).data,void 0!==t){if(void 0!==t.height&&t.height!==r)throw new Error("Image input config height doesn't match ImageBitmap height");if(o.height=r,void 0!==t.width&&t.width!==s)throw new Error("Image input config width doesn't match ImageBitmap width");o.width=s}else o.height=r,o.width=s;return h.bufferToTensor(i,o)}throw new Error("Can not access image data")}if(a)return new Promise((n,r)=>{const s=document.createElement("canvas"),a=s.getContext("2d");if(!e||!a)return r();const i=new Image;i.crossOrigin="Anonymous",i.src=e,i.onload=()=>{s.width=i.width,s.height=i.height,a.drawImage(i,0,0,s.width,s.height);const e=a.getImageData(0,0,s.width,s.height);if(void 0!==t){if(void 0!==t.height&&t.height!==s.height)throw new Error("Image input config height doesn't match ImageBitmap height");if(o.height=s.height,void 0!==t.width&&t.width!==s.width)throw new Error("Image input config width doesn't match ImageBitmap width");o.width=s.width}else o.height=s.height,o.width=s.width;n(h.bufferToTensor(e.data,o))}});throw new Error("Input data provided is not supported - aborted tensor creation")}{const n="RGBA";let r,s;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,s=t.resizedWidth):(r=e.height,s=e.width),void 0!==t){if(o=t,void 0!==t.bitmapFormat&&t.bitmapFormat!==n)throw new Error("Image input config format must be RGBA for ImageData");o.bitmapFormat="RGBA"}else o.bitmapFormat="RGBA";if(o.height=r,o.width=s,void 0!==t){const t=document.createElement("canvas");t.width=s,t.height=r;const n=t.getContext("2d");if(null==n)throw new Error("Can not access image data");n.putImageData(e,0,0),i=n.getImageData(0,0,s,r).data}else i=e.data}}if(void 0!==i)return h.bufferToTensor(i,o);throw new Error("Input data provided is not supported - aborted tensor creation")}toImageData(e){var t,n;const r=document.createElement("canvas").getContext("2d");let s;if(null==r)throw new Error("Can not access image data");{const a=this.dims[3],i=this.dims[2],o=this.dims[1],u=void 0!==e&&void 0!==e.format?e.format:"RGB",l=void 0!==e&&void 0!==(null===(t=e.norm)||void 0===t?void 0:t.mean)?e.norm.mean:255,c=void 0!==e&&void 0!==(null===(n=e.norm)||void 0===n?void 0:n.bias)?e.norm.bias:0,h=i*a;if(void 0!==e){if(void 0!==e.height&&e.height!==i)throw new Error("Image output config height doesn't match tensor height");if(void 0!==e.width&&e.width!==a)throw new Error("Image output config width doesn't match tensor width");if(void 0!==e.format&&4===o&&"RGBA"!==e.format||3===o&&"RGB"!==e.format&&"BGR"!==e.format)throw new Error("Tensor format doesn't match input tensor dims")}const d=4;let p=0,f=1,m=2,g=3,b=0,y=h,x=2*h,w=-1;"RGBA"===u?(b=0,y=h,x=2*h,w=3*h):"RGB"===u?(b=0,y=h,x=2*h):"RBG"===u&&(b=0,x=h,y=2*h),s=r.createImageData(a,i);for(let e=0;e<i*a;p+=d,f+=d,m+=d,g+=d,e++)s.data[p]=(this.data[b++]-c)*l,s.data[f]=(this.data[y++]-c)*l,s.data[m]=(this.data[x++]-c)*l,s.data[g]=-1===w?255:(this.data[w++]-c)*l}return s}reshape(e){return new h(this.type,this.data,e)}}const d=h;class p{constructor(e){this.handler=e}async run(e,t,n){const r={};let s={};if("object"!=typeof e||null===e||e instanceof d||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof d)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(const e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)s=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else{let e=!1;const i=Object.getOwnPropertyNames(t);for(const n of this.outputNames)if(-1!==i.indexOf(n)){const s=t[n];(null===s||s instanceof d)&&(e=!0,a=!1,r[n]=s)}if(e){if("object"==typeof n&&null!==n)s=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else s=t}}else if(void 0!==t)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const t of this.inputNames)if(void 0===e[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(a)for(const e of this.outputNames)r[e]=null;const i=await this.handler.run(e,r,s),o={};for(const e in i)Object.hasOwnProperty.call(i,e)&&(o[e]=new d(i[e].type,i[e].data,i[e].dims));return o}static async create(e,t,n,a){let i,o={};if("string"==typeof e){if(i=e,"object"==typeof t&&null!==t)o=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(i=e,"object"==typeof t&&null!==t)o=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else{if(!(e instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const r=e;let s=0,u=e.byteLength;if("object"==typeof t&&null!==t)o=t;else if("number"==typeof t){if(s=t,!Number.isSafeInteger(s))throw new RangeError("'byteOffset' must be an integer.");if(s<0||s>=r.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${r.byteLength}).`);if(u=e.byteLength-s,"number"==typeof n){if(u=n,!Number.isSafeInteger(u))throw new RangeError("'byteLength' must be an integer.");if(u<=0||s+u>r.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${r.byteLength-s}].`);if("object"==typeof a&&null!==a)o=a;else if(void 0!==a)throw new TypeError("'options' must be an object.")}else if(void 0!==n)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==t)throw new TypeError("'options' must be an object.");i=new Uint8Array(r,s,u)}}const u=(o.executionProviders||[]).map(e=>"string"==typeof e?e:e.name),l=await(async e=>{const t=0===e.length?s:e,n=[];for(const e of t){const t=r[e];if(t){if(t.initialized)return t.backend;if(t.aborted)continue;const r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init()),await t.initPromise,t.initialized=!0,t.backend}catch(s){r||n.push({name:e,err:s}),t.aborted=!0}finally{delete t.initPromise}}}throw new Error(`no available backend found. ERR: ${n.map(e=>`[${e.name}] ${e.err}`).join(", ")}`)})(u),c=await l.createSessionHandler(i,o);return new p(c)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}const f=p},499:()=>{},530:()=>{},551:()=>{},570:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var s={},a={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=a[e])?r:(n=u(e,(0|e)<0?-1:0,!0),i&&(a[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=u(e,e<0?-1:0,!1),i&&(s[e]=n),n)}function o(e,t){if(isNaN(e))return t?b:g;if(t){if(e<0)return b;if(e>=p)return _}else{if(e<=-f)return k;if(e+1>=f)return v}return e<0?o(-e,t).neg():u(e%d|0,e/d|0,t)}function u(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=o,n.fromBits=u;var l=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var s=o(l(n,8)),a=g,i=0;i<e.length;i+=8){var u=Math.min(8,e.length-i),h=parseInt(e.substring(i,i+u),n);if(u<8){var d=o(l(n,u));a=a.mul(d).add(o(h))}else a=(a=a.mul(s)).add(o(h))}return a.unsigned=t,a}function h(e,t){return"number"==typeof e?o(e,t):"string"==typeof e?c(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var b=i(0,!0);n.UZERO=b;var y=i(1);n.ONE=y;var x=i(1,!0);n.UONE=x;var w=i(-1);n.NEG_ONE=w;var v=u(-1,2147483647,!1);n.MAX_VALUE=v;var _=u(-1,-1,!0);n.MAX_UNSIGNED_VALUE=_;var k=u(0,-2147483648,!1);n.MIN_VALUE=k;var T=n.prototype;T.toInt=function(){return this.unsigned?this.low>>>0:this.low},T.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},T.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(k)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=o(l(e,6),this.unsigned),a=this,i="";;){var u=a.div(s),c=(a.sub(u.mul(s)).toInt()>>>0).toString(e);if((a=u).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},T.getHighBits=function(){return this.high},T.getHighBitsUnsigned=function(){return this.high>>>0},T.getLowBits=function(){return this.low},T.getLowBitsUnsigned=function(){return this.low>>>0},T.getNumBitsAbs=function(){if(this.isNegative())return this.eq(k)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},T.isZero=function(){return 0===this.high&&0===this.low},T.eqz=T.isZero,T.isNegative=function(){return!this.unsigned&&this.high<0},T.isPositive=function(){return this.unsigned||this.high>=0},T.isOdd=function(){return!(1&~this.low)},T.isEven=function(){return!(1&this.low)},T.equals=function(e){return r(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},T.eq=T.equals,T.notEquals=function(e){return!this.eq(e)},T.neq=T.notEquals,T.ne=T.notEquals,T.lessThan=function(e){return this.comp(e)<0},T.lt=T.lessThan,T.lessThanOrEqual=function(e){return this.comp(e)<=0},T.lte=T.lessThanOrEqual,T.le=T.lessThanOrEqual,T.greaterThan=function(e){return this.comp(e)>0},T.gt=T.greaterThan,T.greaterThanOrEqual=function(e){return this.comp(e)>=0},T.gte=T.greaterThanOrEqual,T.ge=T.greaterThanOrEqual,T.compare=function(e){if(r(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},T.comp=T.compare,T.negate=function(){return!this.unsigned&&this.eq(k)?k:this.not().add(y)},T.neg=T.negate,T.add=function(e){r(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,s=this.low>>>16,a=65535&this.low,i=e.high>>>16,o=65535&e.high,l=e.low>>>16,c=0,d=0,p=0,f=0;return p+=(f+=a+(65535&e.low))>>>16,d+=(p+=s+l)>>>16,c+=(d+=n+o)>>>16,c+=t+i,u((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},T.subtract=function(e){return r(e)||(e=h(e)),this.add(e.neg())},T.sub=T.subtract,T.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=h(e)),t)return u(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(k))return e.isOdd()?k:g;if(e.eq(k))return this.isOdd()?k:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,s=65535&this.high,a=this.low>>>16,i=65535&this.low,l=e.high>>>16,c=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,b=0,y=0,x=0;return y+=(x+=i*p)>>>16,b+=(y+=a*p)>>>16,y&=65535,b+=(y+=i*d)>>>16,f+=(b+=s*p)>>>16,b&=65535,f+=(b+=a*d)>>>16,b&=65535,f+=(b+=i*c)>>>16,f+=n*p+s*d+a*c+i*l,u((y&=65535)<<16|(x&=65535),(f&=65535)<<16|(b&=65535),this.unsigned)},T.mul=T.multiply,T.divide=function(e){if(r(e)||(e=h(e)),e.isZero())throw Error("division by zero");var n,s,a;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return x;a=b}else{if(this.eq(k))return e.eq(y)||e.eq(w)?k:e.eq(k)?y:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?y:w:(s=this.sub(e.mul(n)),a=n.add(s.div(e)));if(e.eq(k))return this.unsigned?b:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=g}for(s=this;s.gte(e);){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:l(2,i-48),d=o(n),p=d.mul(e);p.isNegative()||p.gt(s);)p=(d=o(n-=c,this.unsigned)).mul(e);d.isZero()&&(d=y),a=a.add(d),s=s.sub(p)}return a},T.div=T.divide,T.modulo=function(e){return r(e)||(e=h(e)),t?u((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},T.mod=T.modulo,T.rem=T.modulo,T.not=function(){return u(~this.low,~this.high,this.unsigned)},T.and=function(e){return r(e)||(e=h(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},T.or=function(e){return r(e)||(e=h(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},T.xor=function(e){return r(e)||(e=h(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},T.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},T.shl=T.shiftLeft,T.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},T.shr=T.shiftRight,T.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},T.shru=T.shiftRightUnsigned,T.shr_u=T.shiftRightUnsigned,T.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},T.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},T.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},T.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},T.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},590:()=>{},603:()=>{},717:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.tychei=o}(0,e=n.nmd(e),n.amdD)},801:function(e,t,n){var r;!function(s,a,i){var o,u=256,l=i.pow(u,6),c=i.pow(2,52),h=2*c,d=255;function p(e,t,n){var r=[],d=b(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,y(a)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(u):(e=new Uint8Array(u),(s.crypto||s.msCrypto).getRandomValues(e)),y(e)}catch(e){var t=s.navigator,n=t&&t.plugins;return[+new Date,s,n,s.screen,y(a)]}}():e,3),r),p=new f(r),x=function(){for(var e=p.g(6),t=l,n=0;e<c;)e=(e+n)*u,t*=u,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|p.g(4)},x.quick=function(){return p.g(4)/4294967296},x.double=x,b(y(p.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(x,d,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,r=this,s=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);s<u;)i[s]=s++;for(s=0;s<u;s++)i[s]=i[a=d&a+e[s%n]+(t=i[s])],i[a]=t;(r.g=function(e){for(var t,n=0,s=r.i,a=r.j,i=r.S;e--;)t=i[s=d&s+1],n=n*u+i[d&(i[s]=i[a=d&a+t])+(i[a]=t)];return r.i=s,r.j=a,n})(u)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(g(e[n],t-1))}catch(e){}return r.length?r:"string"==s?e:e+"\0"}function b(e,t){for(var n,r=e+"",s=0;s<r.length;)t[d&s]=d&(n^=19*t[d&s])+r.charCodeAt(s++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(b(i.random(),a),e.exports){e.exports=p;try{o=n(234)}catch(e){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},806:()=>{},817:()=>{},833:function(e,t,n){var r;!function(e,s){function a(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,a=t.i;return t.w=r=r+1640531527|0,n=s[a+34&127],e=s[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=s[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,s,a,i,o=[],u=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,u=Math.max(u,t.length)),s=0,a=-32;a<u;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,s=0==(n=o[127&a]^=r+i)?s+1:0);for(s>=128&&(o[127&(t&&t.length||0)]=-1),s=127,a=512;a>0;--a)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[s]=r^n;e.w=i,e.X=o,e.i=s}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.X&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xor4096=o}(0,e=n.nmd(e),n.amdD)},837:()=>{},853:()=>{}},__webpack_module_cache__={},leafPrototypes,getProto;function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={id:e,loaded:!1,exports:{}};return __webpack_modules__[e].call(n.exports,n,n.exports,__webpack_require__),n.loaded=!0,n.exports}__webpack_require__.amdD=function(){throw new Error("define cannot be used indirect")},__webpack_require__.amdO={},__webpack_require__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(t,{a:t}),t},getProto=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,__webpack_require__.t=function(e,t){if(1&t&&(e=this(e)),8&t)return e;if("object"==typeof e&&e){if(4&t&&e.__esModule)return e;if(16&t&&"function"==typeof e.then)return e}var n=Object.create(null);__webpack_require__.r(n);var r={};leafPrototypes=leafPrototypes||[null,getProto({}),getProto([]),getProto(getProto)];for(var s=2&t&&e;("object"==typeof s||"function"==typeof s)&&!~leafPrototypes.indexOf(s);s=getProto(s))Object.getOwnPropertyNames(s).forEach(t=>r[t]=()=>e[t]);return r.default=()=>e,__webpack_require__.d(n,r),n},__webpack_require__.d=(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},__webpack_require__.nmd=e=>(e.paths=[],e.children||(e.children=[]),e);var __webpack_exports__={};(()=>{"use strict";var e={};__webpack_require__.r(e),__webpack_require__.d(e,{CompositeArrayBuffer:()=>ta,browserFiles:()=>Ki,browserHTTPRequest:()=>ro,concatenateArrayBuffers:()=>va,copyModel:()=>ii,decodeWeights:()=>da,decodeWeightsStream:()=>ba,encodeWeights:()=>ha,fromMemory:()=>oo,fromMemorySync:()=>uo,getLoadHandlers:()=>Oa,getModelArtifactsForJSON:()=>Sa,getModelArtifactsForJSONSync:()=>Ta,getModelArtifactsInfoForJSON:()=>Ia,getSaveHandlers:()=>Ca,getWeightSpecs:()=>Na,http:()=>no,isHTTPScheme:()=>eo,listModels:()=>si,loadWeights:()=>Zi,moveModel:()=>oi,registerLoadRouter:()=>Aa,registerSaveRouter:()=>$a,removeModel:()=>ai,weightsLoaderFactory:()=>Ji,withSaveHandler:()=>lo,withSaveHandlerSync:()=>co});var t={};__webpack_require__.r(t),__webpack_require__.d(t,{assertParamsValid:()=>mo,computeFlatOffset:()=>Eo,computeOutShape:()=>bo,getNormalizedAxes:()=>vo,isSliceContinous:()=>No,maskToAxes:()=>go,parseSliceParams:()=>$o,sliceInfo:()=>Ao,startForAxis:()=>So,startIndicesWithElidedDims:()=>_o,stopForAxis:()=>Io,stopIndicesWithElidedDims:()=>ko,stridesForAxis:()=>To,stridesWithElidedDims:()=>yo});var n={};__webpack_require__.r(n),__webpack_require__.d(n,{conv2d:()=>Wh,depthwiseConv2d:()=>Hh,matMul:()=>qh});var r={};__webpack_require__.r(r),__webpack_require__.d(r,{collectGatherOpShapeInfo:()=>Jp,computeOutShape:()=>Zp,segOpComputeOptimalWindowSize:()=>Yp});var s={};__webpack_require__.r(s),__webpack_require__.d(s,{ERF_A1:()=>fp,ERF_A2:()=>mp,ERF_A3:()=>gp,ERF_A4:()=>bp,ERF_A5:()=>yp,ERF_P:()=>pp,PARALLELIZE_THRESHOLD:()=>np,RowPartitionType:()=>Zd,SELU_SCALE:()=>dp,SELU_SCALEALPHA:()=>hp,applyActivation:()=>Uh,assertAndGetBroadcastShape:()=>Li,assertAxesAreInnerMostDims:()=>rl,assertParamsConsistent:()=>Xd,assignToTypedArray:()=>Tp,axesAreInnerMostDims:()=>Qu,calculateShapes:()=>bh,checkEinsumDimSizes:()=>Rp,checkPadOnDimRoundingMode:()=>su,combineLocations:()=>el,combineRaggedTensorToTensorShapes:()=>Jd,complexWithEvenIndex:()=>vp,complexWithOddIndex:()=>_p,computeConv2DInfo:()=>qo,computeConv3DInfo:()=>Ko,computeDefaultPad:()=>Xo,computeDilation2DInfo:()=>jo,computeOptimalWindowSize:()=>rp,computeOutAndReduceShapes:()=>tl,computeOutShape:()=>Yd,computePool2DInfo:()=>Go,computePool3DInfo:()=>Ho,convertConv2DDataFormat:()=>ru,decodeEinsumEquation:()=>Cp,eitherStridesOrDilationsAreOne:()=>tu,expandShapeToKeepDim:()=>nl,exponent:()=>Ip,exponents:()=>Sp,fromStringArrayToUint8:()=>ef,fromUint8ToStringArray:()=>Qp,getAxesPermutation:()=>sl,getBroadcastDims:()=>Pi,getComplexWithIndex:()=>kp,getEinsumComputePath:()=>Dp,getEinsumPermutation:()=>Op,getFusedBiasGradient:()=>Bh,getFusedDyActivation:()=>zh,getImageCenter:()=>sp,getInnerMostAxes:()=>il,getPermuted:()=>ip,getRaggedRank:()=>ep,getReductionAxes:()=>Mi,getReshaped:()=>ap,getReshapedPermuted:()=>op,getRowPartitionTypesHelper:()=>Qd,getSliceBeginCoords:()=>up,getSliceSize:()=>lp,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Lp,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>zp,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Bp,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Wp,getSparseReshapeInputOutputMismatchErrorMessage:()=>Gp,getSparseReshapeInputOutputMultipleErrorMessage:()=>jp,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Up,getSparseReshapeNegativeOutputDimErrorMessage:()=>Vp,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Xp,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Hp,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>qp,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Kp,getUndoAxesPermutation:()=>al,isIdentityPermutation:()=>Fp,log:()=>$r,mergeRealAndImagArrays:()=>xp,prepareAndValidate:()=>cp,prepareSplitSize:()=>Mp,segment_util:()=>r,shouldFuse:()=>Vh,slice_util:()=>t,splitRealAndImagArrays:()=>wp,stridesOrDilationsArePositive:()=>nu,tupleValuesAreOne:()=>eu,upcastType:()=>Ns,validateDefaultValueShape:()=>tp,validateInput:()=>gh,validateUpdateShape:()=>mh,warn:()=>Er});var a={};__webpack_require__.r(a),__webpack_require__.d(a,{json:()=>cv});var i={};__webpack_require__.r(i),__webpack_require__.d(i,{json:()=>hv});var o={};__webpack_require__.r(o),__webpack_require__.d(o,{json:()=>dv});var u={};__webpack_require__.r(u),__webpack_require__.d(u,{json:()=>pv});var l={};__webpack_require__.r(l),__webpack_require__.d(l,{json:()=>fv});var c={};__webpack_require__.r(c),__webpack_require__.d(c,{json:()=>mv});var h={};__webpack_require__.r(h),__webpack_require__.d(h,{json:()=>gv});var d={};__webpack_require__.r(d),__webpack_require__.d(d,{json:()=>bv});var p={};__webpack_require__.r(p),__webpack_require__.d(p,{json:()=>yv});var f={};__webpack_require__.r(f),__webpack_require__.d(f,{json:()=>xv});var m={};__webpack_require__.r(m),__webpack_require__.d(m,{json:()=>wv});var g={};__webpack_require__.r(g),__webpack_require__.d(g,{json:()=>vv});var b={};__webpack_require__.r(b),__webpack_require__.d(b,{json:()=>_v});var y={};__webpack_require__.r(y),__webpack_require__.d(y,{json:()=>kv});var x={};__webpack_require__.r(x),__webpack_require__.d(x,{json:()=>Tv});var w={};__webpack_require__.r(w),__webpack_require__.d(w,{json:()=>Sv});var v={};__webpack_require__.r(v),__webpack_require__.d(v,{json:()=>Iv});var _={};__webpack_require__.r(_),__webpack_require__.d(_,{json:()=>Nv});var k={};__webpack_require__.r(k),__webpack_require__.d(k,{json:()=>Ev});var T={};__webpack_require__.r(T),__webpack_require__.d(T,{OP_SCOPE_SUFFIX:()=>Xs,abs:()=>Fi,acos:()=>Oo,acosh:()=>Ro,add:()=>fi,addN:()=>Do,all:()=>Fo,any:()=>Po,argMax:()=>Mo,argMin:()=>Lo,asin:()=>zo,asinh:()=>Bo,atan:()=>Uo,atan2:()=>Vo,atanh:()=>Wo,avgPool:()=>iu,avgPool3d:()=>ou,basicLSTMCell:()=>pu,batchNorm:()=>mu,batchNorm2d:()=>gu,batchNorm3d:()=>bu,batchNorm4d:()=>yu,batchToSpaceND:()=>fu,bincount:()=>xu,bitwiseAnd:()=>wu,booleanMaskAsync:()=>Eh,broadcastArgs:()=>vu,broadcastTo:()=>_u,buffer:()=>ci,cast:()=>hi,ceil:()=>ku,clipByValue:()=>Tu,clone:()=>di,complex:()=>Zs,concat:()=>uu,concat1d:()=>Su,concat2d:()=>Iu,concat3d:()=>Nu,concat4d:()=>Eu,conv1d:()=>Au,conv2d:()=>$u,conv2dTranspose:()=>Ou,conv3d:()=>Ru,conv3dTranspose:()=>Fu,cos:()=>Pu,cosh:()=>Mu,cosineWindow:()=>Ph,cumprod:()=>Lu,cumsum:()=>zu,denseBincount:()=>Bu,depthToSpace:()=>Uu,depthwiseConv2d:()=>Vu,diag:()=>Wu,dilation2d:()=>ju,div:()=>gi,divNoNan:()=>qu,dot:()=>Ku,dropout:()=>Dh,einsum:()=>Xu,elu:()=>Yu,enclosingPowerOfTwo:()=>Fh,ensureShape:()=>Zu,equal:()=>Gu,erf:()=>Ju,euclideanNorm:()=>dl,exp:()=>pl,expandDims:()=>fl,expm1:()=>ml,eye:()=>bl,fft:()=>Qc,fill:()=>Ai,floor:()=>yl,floorDiv:()=>mi,fused:()=>n,gather:()=>xl,gatherND:()=>Rh,greater:()=>wl,greaterEqual:()=>vl,ifft:()=>eh,imag:()=>_l,image:()=>Ud,inTopKAsync:()=>Mh,irfft:()=>th,isFinite:()=>kl,isInf:()=>Tl,isNaN:()=>Sl,leakyRelu:()=>Il,less:()=>Nl,lessEqual:()=>El,linalg:()=>Vd,linspace:()=>$l,localResponseNormalization:()=>Al,log:()=>Cl,log1p:()=>Ol,logSigmoid:()=>Fl,logSoftmax:()=>Pl,logSumExp:()=>Ml,logicalAnd:()=>Ll,logicalNot:()=>zl,logicalOr:()=>Bl,logicalXor:()=>Ul,losses:()=>Wd,lowerBound:()=>jl,matMul:()=>lu,max:()=>ol,maxPool:()=>Gl,maxPool3d:()=>Hl,maxPoolWithArgmax:()=>ql,maximum:()=>zi,mean:()=>Kl,meshgrid:()=>Zl,min:()=>ul,minimum:()=>Jl,mirrorPad:()=>Ql,mod:()=>ec,moments:()=>tc,movingAverage:()=>Ah,mul:()=>bi,multiRNNCell:()=>nc,multinomial:()=>rc,neg:()=>Rl,norm:()=>hl,notEqual:()=>sc,oneHot:()=>ac,ones:()=>Yl,onesLike:()=>ic,op:()=>Ys,outerProduct:()=>oc,pad:()=>uc,pad1d:()=>lc,pad2d:()=>cc,pad3d:()=>hc,pad4d:()=>dc,pool:()=>fc,pow:()=>Oi,prelu:()=>mc,print:()=>pi,prod:()=>gc,raggedGather:()=>bc,raggedRange:()=>yc,raggedTensorToTensor:()=>xc,rand:()=>wc,randomGamma:()=>Sc,randomNormal:()=>Ic,randomStandardNormal:()=>Nc,randomUniform:()=>Ec,randomUniformInt:()=>$c,range:()=>Ac,real:()=>Cc,reciprocal:()=>Oc,relu:()=>Rc,relu6:()=>Dc,reshape:()=>au,reverse:()=>Fc,reverse1d:()=>Pc,reverse2d:()=>Mc,reverse3d:()=>Lc,reverse4d:()=>zc,rfft:()=>rh,round:()=>Bc,rsqrt:()=>Uc,scalar:()=>_i,scatterND:()=>Ch,searchSorted:()=>Wl,selu:()=>Vc,separableConv2d:()=>Wc,setdiff1dAsync:()=>jc,sigmoid:()=>cu,sign:()=>Gc,signal:()=>Bd,sin:()=>Hc,sinh:()=>qc,slice:()=>hu,slice1d:()=>Kc,slice2d:()=>Xc,slice3d:()=>Yc,slice4d:()=>Zc,softmax:()=>Jc,softplus:()=>Dl,spaceToBatchND:()=>pc,sparse:()=>jd,sparseToDense:()=>Oh,spectral:()=>zd,split:()=>nh,sqrt:()=>yi,square:()=>xi,squaredDifference:()=>sh,squeeze:()=>ah,stack:()=>ih,step:()=>oh,stridedSlice:()=>uh,string:()=>Gd,sub:()=>Ri,sum:()=>ll,tan:()=>lh,tanh:()=>du,tensor:()=>Qs,tensor1d:()=>ch,tensor2d:()=>hh,tensor3d:()=>ho,tensor4d:()=>dh,tensor5d:()=>ph,tensor6d:()=>fh,tensorScatterUpdate:()=>yh,tile:()=>gl,topk:()=>xh,transpose:()=>$h,truncatedNormal:()=>wh,unique:()=>vh,unsortedSegmentSum:()=>_h,unstack:()=>kh,upperBound:()=>Th,variable:()=>Sh,where:()=>Hu,whereAsync:()=>Nh,zeros:()=>Xl,zerosLike:()=>wi});var S={};__webpack_require__.r(S),__webpack_require__.d(S,{mx:()=>kk,XI:()=>mT,Nk:()=>gT,f6:()=>yT,ct:()=>yk,YG:()=>_T,hH:()=>ET,z3:()=>dS,sG:()=>kS,uM:()=>ES,vS:()=>GS,qB:()=>QS,GG:()=>tI,lg:()=>iI,rq:()=>rI,cu:()=>xI,WR:()=>gI,GE:()=>_I,px:()=>TI,jC:()=>zI,He:()=>VI,hE:()=>JI,BF:()=>sS,Dk:()=>uN,cl:()=>gN,_B:()=>$N,ub:()=>ON,_f:()=>FN,Ku:()=>UN,qy:()=>WN,Zy:()=>tE,bu:()=>sE,zv:()=>lk,dH:()=>Ok,HS:()=>hT,yH:()=>TE,l3:()=>IE,z9:()=>EE,x6:()=>RE,_m:()=>BE,eW:()=>GE,GK:()=>KE,SP:()=>ZE,yr:()=>QE,dl:()=>DS,Dw:()=>a$,xT:()=>l$,_X:()=>zk,wz:()=>g$});class I{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class N{refCount(e){return E("refCount")}incRef(e){return E("incRef")}timerAvailable(){return!0}time(e){return E("time")}read(e){return E("read")}readSync(e){return E("readSync")}readToGPU(e,t){return E("readToGPU")}numDataIds(){return E("numDataIds")}disposeData(e,t){return E("disposeData")}write(e,t,n){return E("write")}move(e,t,n,r,s){return E("move")}createTensorFromGPUData(e,t,n){return E("createTensorFromGPUData")}memory(){return E("memory")}floatPrecision(){return E("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return E("dispose")}}function E(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function $(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,O(e,t,n)}function A(e,t,n){return Math.max(e,Math.min(t,n))}function C(e){return e%2==0?e:e+1}function O(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function R(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function D(e,t,n=""){R(M(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function F(e){R(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function P(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function M(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function L(e){return e%1==0}function z(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function B(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function U(e,t=e=>0,n,r){return new Promise((s,a)=>{let i=0;const o=()=>{if(e())return void s();i++;const u=t(i);null!=n&&i>=n?a():null!=r?r(o,u):setTimeout(o,u)};o()})}function V(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function W(e,t){const n=t.length;return R((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-n&&e<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),R(e.every(e=>L(e)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(e=>e<0?n+e:e)}function j(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:W(t,e).sort();let i=0;for(let t=0;t<e.length;++t){if(null!=a){if(a[i]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==a[i]||a[i]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),a[i]<=t&&i++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function G(e,t){return H(e,t)}function H(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function q(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function K(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function X(e){return"string"==typeof e||e instanceof String}function Y(e){return"number"==typeof e}function Z(e){return Array.isArray(e)?Z(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Y(e)?"float32":X(e)?"string":"boolean"==typeof e?"bool":"float32"}function J(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Q(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function ee(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function te(e,t,n,r=!1){const s=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)s[t]=n[e+t]}else{const a=t[0],i=t.slice(1),o=i.reduce((e,t)=>e*t)*(r?2:1);for(let t=0;t<a;t++)s[t]=te(e+t*o,i,n,r)}return s}function ne(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce((e,t)=>e*t)*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return te(0,e,t,n)}function re(e,t){const n=se(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function se(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function ae(e,t){const n=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return ne(e,new Float32Array(n));if("int32"===t)return ne(e,new Int32Array(n));if("bool"===t)return ne(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function ie(e){e.forEach(t=>{R(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function oe(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function ue(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function le(e){return e&&e.then&&"function"==typeof e.then}const ce="tfjsflags";class he{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=de,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(pe().getBool("IS_TEST")||pe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];pe().getBool("IS_TEST")||pe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(le(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);ce in e&&e[ce].split(",").forEach(e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)})}}function de(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("="))),t}function pe(){return me}let fe,me=null;function ge(){if(null==fe){let e;if("undefined"!=typeof window)e=window;else if(void 0!==__webpack_require__.g)e=__webpack_require__.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}fe=e}return fe}function be(e,t){const n=function(){const e=ge();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const ye="Abs",xe="Acos",we="Acosh",ve="Add",_e="AddN",ke="All",Te="Any",Se="ArgMax",Ie="ArgMin",Ne="Asin",Ee="Asinh",$e="Atan",Ae="Atanh",Ce="Atan2",Oe="AvgPool",Re="AvgPoolGrad",De="AvgPool3D",Fe="AvgPool3DGrad",Pe="BatchMatMul",Me="BatchToSpaceND",Le="Bincount",ze="BitwiseAnd",Be="BroadcastArgs",Ue="Cast",Ve="Ceil",We="ClipByValue",je="Complex",Ge="ComplexAbs",He="Concat",qe="Conv2D",Ke="Conv2DBackpropFilter",Xe="Conv2DBackpropInput",Ye="Conv3D",Ze="Conv3DBackpropFilterV2",Je="Conv3DBackpropInputV2",Qe="Cos",et="Cosh",tt="Cumprod",nt="Cumsum",rt="CropAndResize",st="DenseBincount",at="DepthToSpace",it="DepthwiseConv2dNative",ot="DepthwiseConv2dNativeBackpropFilter",ut="DepthwiseConv2dNativeBackpropInput",lt="Diag",ct="Dilation2D",ht="Dilation2DBackpropInput",dt="Dilation2DBackpropFilter",pt="RealDiv",ft="Einsum",mt="Elu",gt="EluGrad",bt="Erf",yt="Equal",xt="Exp",wt="ExpandDims",vt="Expm1",_t="FFT",kt="Fill",Tt="FlipLeftRight",St="Floor",It="FloorDiv",Nt="FusedBatchNorm",Et="GatherV2",$t="GatherNd",At="Greater",Ct="GreaterEqual",Ot="Identity",Rt="IFFT",Dt="Imag",Ft="IsFinite",Pt="IsInf",Mt="IsNan",Lt="LeakyRelu",zt="Less",Bt="LessEqual",Ut="LinSpace",Vt="Log",Wt="Log1p",jt="LogicalAnd",Gt="LogicalNot",Ht="LogicalOr",qt="LRN",Kt="LRNGrad",Xt="Max",Yt="Maximum",Zt="MaxPool",Jt="MaxPoolGrad",Qt="MaxPool3D",en="MaxPool3DGrad",tn="MaxPoolWithArgmax",nn="Mean",rn="Min",sn="Minimum",an="MirrorPad",on="Mod",un="Multinomial",ln="Multiply",cn="Neg",hn="NotEqual",dn="NonMaxSuppressionV3",pn="NonMaxSuppressionV4",fn="NonMaxSuppressionV5",mn="OnesLike",gn="OneHot",bn="Pack",yn="PadV2",xn="Pow",wn="Prelu",vn="Prod",_n="RaggedGather",kn="RaggedRange",Tn="RaggedTensorToTensor",Sn="Range",In="Real",Nn="Reciprocal",En="Relu",$n="Reshape",An="ResizeNearestNeighbor",Cn="ResizeNearestNeighborGrad",On="ResizeBilinear",Rn="ResizeBilinearGrad",Dn="Relu6",Fn="Reverse",Pn="Round",Mn="Rsqrt",Ln="ScatterNd",zn="TensorScatterUpdate",Bn="SearchSorted",Un="Select",Vn="Selu",Wn="Slice",jn="Sin",Gn="Sinh",Hn="Sign",qn="Sigmoid",Kn="Softplus",Xn="Sqrt",Yn="Sum",Zn="SpaceToBatchND",Jn="SplitV",Qn="Softmax",er="SparseFillEmptyRows",tr="SparseReshape",nr="SparseSegmentMean",rr="SparseSegmentSum",sr="SparseToDense",ar="SquaredDifference",ir="Square",or="StaticRegexReplace",ur="StridedSlice",lr="StringNGrams",cr="StringSplit",hr="StringToHashBucketFast",dr="Sub",pr="Tan",fr="Tanh",mr="Tile",gr="TopK",br="Transform",yr="Transpose",xr="Unique",wr="Unpack",vr="UnsortedSegmentSum",_r="ZerosLike",kr="Step",Tr="RotateWithOffset",Sr="_FusedMatMul",Ir="FusedConv2D",Nr="FusedDepthwiseConv2D";function Er(...e){pe().getBool("IS_TEST")||pe().getBool("PROD")||console.warn(...e)}function $r(...e){pe().getBool("IS_TEST")||pe().getBool("PROD")||console.log(...e)}const Ar=be("kernelRegistry",()=>new Map),Cr=be("gradRegistry",()=>new Map);function Or(e,t){const n=Mr(e,t);return Ar.get(n)}function Rr(e){return Cr.get(e)}function Dr(e){const t=Ar.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function Fr(e){const{kernelName:t,backendName:n}=e,r=Mr(t,n);Ar.has(r)&&Er(`The kernel '${t}' for backend '${n}' is already registered`),Ar.set(r,e)}function Pr(e){const{kernelName:t}=e;Cr.has(t)&&pe().getBool("DEBUG")&&Er(`Overriding the gradient for '${t}'`),Cr.set(t,e)}function Mr(e,t){return`${t}_${e}`}function Lr(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var zr=__webpack_require__(570);const Br=__webpack_require__.n(zr)()||zr;function Ur(e){return Br.fromString(e,!0,16)}const Vr=Ur("c3a5c85c97cb3127"),Wr=Ur("b492b66fbe98f273"),jr=Ur("9ae16a3b2f90404f");function Gr(e){return e.xor(e.shru(47))}function Hr(e,t,n){const r=e.slice(t,t+n);return Br.fromBytes(Array.from(r),!0,!0)}function qr(e,t){return Hr(e,t,8)}function Kr(e,t){return Hr(e,t,4)}function Xr(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Yr(e,t,n=Ur("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function Zr(e,t,n,r){return function(e,t,n,r,s,a){s=s.add(e),a=Xr(a.add(s).add(r),21);const i=s;return s=(s=s.add(t)).add(n),a=a.add(Xr(s,44)),[s.add(r),a.add(i)]}(qr(e,t),qr(e,t+8),qr(e,t+16),qr(e,t+24),n,r)}function Jr(e,t=e.length){const n=Br.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){const n=jr.add(2*t),r=qr(e,0).add(jr),s=qr(e,t-8);return Yr(Xr(s,37).mul(n).add(r),Xr(r,25).add(s).mul(n),n)}if(t>=4){const n=jr.add(2*t);return Yr(Kr(e,0).shl(3).add(t),Kr(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return Gr(jr.mul(n).xor(Vr.mul(r))).mul(jr)}return jr}(e,t):function(e,t=e.length){const n=jr.add(2*t),r=qr(e,0).mul(Wr),s=qr(e,8),a=qr(e,t-8).mul(n),i=qr(e,t-16).mul(jr);return Yr(Xr(r.add(s),43).add(Xr(a,30)).add(i),r.add(Xr(s.add(jr),18)).add(a),n)}(e,t);if(t<=64)return function(e,t=e.length){const n=jr.add(2*t),r=qr(e,0).mul(jr),s=qr(e,8),a=qr(e,t-8).mul(n),i=qr(e,t-16).mul(jr),o=Xr(r.add(s),43).add(Xr(a,30)).add(i),u=Yr(o,r.add(Xr(s.add(jr),18)).add(a),n),l=qr(e,16).mul(n),c=qr(e,24),h=o.add(qr(e,t-32)).mul(n),d=u.add(qr(e,t-24)).mul(n);return Yr(Xr(l.add(c),43).add(Xr(h,30)).add(d),l.add(Xr(c.add(r),18)).add(h),n)}(e,t);let r=n,s=n.mul(Wr).add(113),a=Gr(s.mul(jr).add(113)).mul(jr),i=[Br.UZERO,Br.UZERO],o=[Br.UZERO,Br.UZERO];r=r.mul(jr).add(qr(e,0));let u=0;const l=64*(t-1>>6),c=l+(t-1&63)-63;do{r=Xr(r.add(s).add(i[0]).add(qr(e,u+8)),37).mul(Wr),s=Xr(s.add(i[1]).add(qr(e,u+48)),42).mul(Wr),r=r.xor(o[1]),s=s.add(i[0]).add(qr(e,u+40)),a=Xr(a.add(o[0]),33).mul(Wr),i=Zr(e,u,i[1].mul(Wr),r.add(o[0])),o=Zr(e,u+32,a.add(o[1]),s.add(qr(e,u+16))),[a,r]=[r,a],u+=64}while(u!==l);const h=Wr.add(a.and(255).shl(1));return u=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Xr(r.add(s).add(i[0]).add(qr(e,u+8)),37).mul(h),s=Xr(s.add(i[1]).add(qr(e,u+48)),42).mul(h),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(qr(e,u+40))),a=Xr(a.add(o[0]),33).mul(h),i=Zr(e,u,i[1].mul(h),r.add(o[0])),o=Zr(e,u+32,a.add(o[1]),s.add(qr(e,u+16))),[a,r]=[r,a],Yr(Yr(i[0],o[0],h).add(Gr(s).mul(Vr)).add(a),Yr(i[1],o[1],h).add(r),h)}function Qr(e,t){return"string"===t?ns(e):es([e],t)}function es(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=as(e)),pe().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function ts(){return pe().platform.now()}function ns(e,t="utf-8"){return t=t||"utf-8",pe().platform.encode(e,t)}function rs(e,t="utf-8"){return t=t||"utf-8",pe().platform.decode(e,t)}function ss(e){return null!=pe().platform.isTypedArray?pe().platform.isTypedArray(e):Lr(e)}function as(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||le(e)||null==e||ss(e)&&n)t.push(e);else if(Array.isArray(e)||ss(e))for(let r=0;r<e.length;++r)as(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let s=0;s<=r;s++)as(e[s],t,n)}return t}class is{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new us)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let a;const i=ts();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();a=Promise.resolve({kernelMs:ts()-i})}if(pe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<r.length;t++){const n=r[t];n.data().then(t=>{os(t,n.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(e=>e.kernelMs),extraInfo:a.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach(e=>{Promise.all([e.data(),r,a]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])})})}}function os(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class us{logKernelProfile(e,t,n,r,s,a){const i="number"==typeof r?B(`${r}ms`,9):r.error,o=B(e,25),u=t.rank,l=t.size,c=B(t.shape.toString(),14);let h="";for(const e in s){const n=s[e];if(null!=n){const r=n.shape||t.shape,s=r.length;h+=`${e}: ${s}D ${s>0?r:""} `}}console.log(`%c${o}\t%c${i}\t%c${u}D ${c}\t%c${l}\t%c${h}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function ls(e,t,n,r){const s=ee(t),a=function(e,t,n,r){const s=P(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,u="complex64"===n?ps(e):e;if(o>1)for(let e=0;e<s/a;e++){const t=e*a;for(let e=0;e<a;e++)i[e]=Math.max(i[e],cs(u[t+e],0,n).length)}return i}(e,t,n,s),i=t.length,o=ds(e,t,n,s,a),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(o.map(e=>"    "+e).join("\n")),u.join("\n")}function cs(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:X(e)?`'${e}'`:"bool"===n?hs(e):parseFloat(e.toFixed(7)).toString(),B(r,t)}function hs(e){return 0===e?"false":"true"}function ds(e,t,n,r,s,a=!0){const i="complex64"===n?2:1,o=t[0],u=t.length;if(0===u)return"complex64"===n?[cs(ps(e)[0],0,n)]:"bool"===n?[hs(e[0])]:[e[0].toString()];if(1===u){if(o>20){const t=3*i;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((o-3)*i,o*i));return"complex64"===n&&(r=ps(r),a=ps(a)),["["+r.map((e,t)=>cs(e,s[t],n)).join(", ")+", ..., "+a.map((e,t)=>cs(e,s[o-3+t],n)).join(", ")+"]"]}return["["+("complex64"===n?ps(e):Array.from(e)).map((e,t)=>cs(e,s[t],n)).join(", ")+"]"]}const l=t.slice(1),c=r.slice(1),h=r[0]*i,d=[];if(o>20){for(let t=0;t<3;t++){const r=t*h,a=r+h;d.push(...ds(e.slice(r,a),l,n,c,s,!1))}d.push("...");for(let t=o-3;t<o;t++){const r=t*h,a=r+h;d.push(...ds(e.slice(r,a),l,n,c,s,t===o-1))}}else for(let t=0;t<o;t++){const r=t*h,a=r+h;d.push(...ds(e.slice(r,a),l,n,c,s,t===o-1))}const p=2===u?",":"";d[0]="["+(o>0?d[0]+p:"");for(let e=1;e<d.length-1;e++)d[e]=" "+d[e]+p;let f=",\n";for(let e=2;e<u;e++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(a?"":f),d}function ps(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class fs{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=P(e),null!=n){const e=n.length;R(e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||H(t,this.size),this.strides=ee(e)}set(e,...t){0===t.length&&(t=[0]),R(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ms().makeTensor(this.values,this.shape,this.dtype)}}let ms=null,gs=null,bs=null;class ys{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=P(e),this.strides=ee(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return gs.buffer(this.shape,this.dtype,e)}bufferSync(){return gs.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return ne(this.shape,e,"complex64"===this.dtype)}arraySync(){return ne(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=ms().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map(e=>rs(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),ms().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=ms().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>rs(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await ms().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),ms().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return gs.print(this,e)}clone(){return this.throwIfDisposed(),gs.clone(this)}toString(e=!1){return ls(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),gs.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),ms().makeVariable(this,e,t,n)}}function xs(){return be("Tensor",()=>ys)}Object.defineProperty(ys,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),xs();class ws extends ys{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!M(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);ms().disposeTensor(this),this.dataId=e.dataId,ms().incRef(this,null)}dispose(){ms().disposeVariable(this),this.isDisposedInternal=!0}}var vs,_s,ks,Ts,Ss;Object.defineProperty(ws,Symbol.hasInstance,{value:e=>e instanceof ys&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(vs||(vs={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(_s||(_s={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(ks||(ks={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(Ts||(Ts={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Ss||(Ss={}));const Is={float32:Ts,int32:_s,bool:ks,complex64:Ss};function Ns(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return Is[e][t]}function Es(e){return Ns(e,"int32")}function $s(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function As(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Cs(e,t){if(e.dtype===t.dtype)return[e,t];const n=Ns(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Os(e,t){return t.some(t=>t.id===e.id)}function Rs(e){const t=[];return Ds(e,t,new Set),t}function Ds(e,t,n){if(null==e)return;if(e instanceof ys)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!=typeof r)return;var r;const s=e;for(const e in s){const r=s[e];n.has(r)||(n.add(r),Ds(r,t,n))}}function Fs(e){return null!=e.kernelName}class Ps{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Ms{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ps}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(Er(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new is(this.backendInstance),!0}setupRegisteredKernels(){Dr(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Dr(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof N||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then(n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0))).catch(n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,Er(`Initialization of backend ${e} failed`),Er(n.stack||n.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(t){return Er(`Initialization of backend ${e} failed`),Er(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(n),()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return Ms.nextTensorId++}nextVariableId(){return Ms.nextVariableId++}clone(e){const t=zs.runKernel(Ot,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],e=>({x:()=>{const t={x:e};return zs.runKernel(Ue,t,{dtype:"float32"})}}),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==Or(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach(e=>{s+="complex64"===e.dtype?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const u=Fs(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Fs(e)){const{kernelName:t,inputs:s,attrs:a}=e;null==this.backendName&&this.backend;const u=Or(t,this.backendName);R(null!=u,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),i=()=>{const e=this.backend.numDataIds();o=u.kernelFunc({inputs:s,attrs:a,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const l=i.map(e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e));if(r){const e=this.getTensorsForGradient(t,s,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map(e=>this.keep(this.clone(e))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy(()=>t(this.backend,s));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}const{inputs:l,attrs:c}=e,h=Fs(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(u,l,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=i()}),r&&this.addTapeNode(u,l,t,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(e=>null!=l[e]?l[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map(e=>this.keep(this.clone(e)));return t}getTensorsForGradient(e,t,n){const r=Rr(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let a;r.saveAllInputs?(R(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(e=>t[e])):a=e.map(e=>t[e]);const i=n.filter((e,t)=>s[t]);return a.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;"string"===n&&X(e[0])&&(s=e.map(e=>ns(e)));const a=r.write(s,t,n),i=new ys(t,n,a,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(a),t=function(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const s={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:s}=e,a=new ys(r,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new ws(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*K(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof ws||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*K(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=Rr(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map((e,t)=>{if(null==e){const e=n[t],r=se(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e}),r(e.length>1?e:e[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Rs(e),n=new Set(t.map(e=>e.id));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==r.id||this.track(e)})}gradients(e,t,n,r=!1){if(R(t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));R(s instanceof ys,()=>"The result y returned by f() must be a tensor.");const a=function(e,t,n){const r={},s={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){const a=e[n],i=a.inputs;for(const e in i){const n=i[e];let o=!1;for(let e=0;e<t.length;e++)if(r[n.id]){a.outputs.forEach(e=>r[e.id]=!0),o=!0,s[a.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let t=e.length-1;t>=0;t--){const n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(a[n.outputs[e].id]){for(const e in r)a[r[e].id]=!0,i[n.id]=!0;break}}const o=[];for(let t=0;t<e.length;t++){const n=e[t];if(s[n.id]&&i[n.id]){const e={};for(const t in n.inputs){const s=n.inputs[t];r[s.id]&&(e[t]=s)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,o.push(t)}}return o}(this.state.activeTape,t,s);if(!r&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const e={};e[s.id]=null==n?function(e){const t=re(P(e),"float32");return zs.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach(t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)}),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const t in a.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const s=n(()=>o[t]());if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const i=a.inputs[t];if(!M(s.shape,i.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=r(t,s),t.dispose()}}}}(e,a,e=>this.tidy(e),Bs);const r=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(const t of e.saved)t.dispose()}),this.state.activeTape=null),{value:s,grads:r}})}customGrad(e){return R(J(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let n;R(t.every(e=>e instanceof ys),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const r={};return t.forEach((e,t)=>{r[t]=e}),this.runKernelFunc({forwardFunc:(r,s)=>(n=e(...t,s),R(n.value instanceof ys,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),R(J(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(e,r)=>{const s=n.gradFunc(e,r),a=Array.isArray(s)?s:[s];R(a.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),R(a.every(e=>e instanceof ys),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const i={};return a.forEach((e,t)=>{i[t]=()=>e}),i},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=ts(),n=await this.backend.time(e);return n.wallMs=ts()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ps;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Ls(){const e=ge();if(null==e._tfengine){const t=new he(e);e._tfengine=new Ms(t)}var t;return t=e._tfengine.ENV,me=t,ms=()=>e._tfengine,e._tfengine}Ms.nextTensorId=0,Ms.nextVariableId=0;const zs=Ls();function Bs(e,t){const n={a:e,b:t};return zs.runKernel(ve,n)}function Us(e){if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Vs(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const Ws=pe();function js(e,t){let n=e;if(ss(e))return"string"===t?[]:[e.length];if($s(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(As(e))return[e.buffer.size/(null==t?4:K(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||ss(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&pe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Gs(e,r,[]),r}function Gs(e,t,n){if(n=n||[],!Array.isArray(e)&&!ss(e))return void R(0===t.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);R(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),R(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const r=t.slice(1);for(let t=0;t<e.length;++t)Gs(e[t],r,n.concat(t))}function Hs(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function qs(e,t,n,r="numeric"){if(e instanceof xs())return Hs(r,e.dtype,t,n),e;let s=Z(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Hs(r,s,t,n),null==e||!ss(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=js(e,s);ss(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?es(e,s):as(e,[],!0);return zs.makeTensor(i,a,s)}function Ks(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((e,s)=>qs(e,`${t}[${s}]`,n,r))}Ws.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Ws.registerFlag("IS_BROWSER",()=>Vs()),Ws.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),Ws.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Ws.registerFlag("IS_SAFARI",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),Ws.registerFlag("PROD",()=>!1),Ws.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ws.getBool("DEBUG")),Ws.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Ws.registerFlag("IS_TEST",()=>!1),Ws.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Ws.getBool("DEBUG")),Ws.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),Ws.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),Ws.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const Xs="__op";function Ys(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=Xs;const s=(...e)=>{zs.startScope(n);try{const t=r(...e);return le(t)&&console.error("Cannot return a Promise inside of tidy."),zs.endScope(t),t}catch(e){throw zs.endScope(null),e}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}const Zs=Ys({complex_:function(e,t){const n=qs(e,"real","complex"),r=qs(t,"imag","complex");D(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return zs.runKernel(je,s)}});function Js(e,t,n,r){if(null==r)r=Z(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(As(e)||$s(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return zs.backend.createTensorFromGPUData(e,t||n,r)}if(!ss(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){ie(t);const e=P(t),r=P(n);R(e===r,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`);for(let e=0;e<n.length;++e){const r=n[e],s=e!==n.length-1||r!==P(t.slice(e));R(n[e]===t[e]||!s,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return ss(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?es(e,r):as(e,[],!0),zs.makeTensor(e,t,r)}function Qs(e,t,n){return Js(e,t,js(e,n),n)}const ea={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class ta{static join(e){return new ta(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map(e=>ss(e)?e.buffer:e)).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+r.byteLength;this.shards.push({buffer:r,start:t,end:s}),t=s}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),(t=Math.min(this.byteLength,t))<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),s=new Uint8Array(r);let a=0;for(let r=n;r<this.shards.length;r++){const n=this.shards[r],i=e+a-n.start,o=a,u=Math.min(t,n.end)-n.start,l=new Uint8Array(n.buffer,i,u-i);if(s.set(l,o),a+=l.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,a=t(e[s]);if(0===a)return s;a<0?r=s:n=s+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function na(){return zs}function ra(){return zs.memory()}function sa(e,t){return zs.tidy(e,t)}function aa(e){Rs(e).forEach(e=>e.dispose())}function ia(e){return zs.keep(e)}function oa(){return zs.backendName}function ua(e,t,n=1){return zs.registerBackend(e,t,n)}function la(){return zs.backend}bs=function(e){pe().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};const ca=4;async function ha(e,t){const n=[],r=[],s=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let a=0;a<s.length;++a){const i=s[a],o=Array.isArray(e)?e[a].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const u={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise(async e=>{const t=await o.bytes(),n=t.reduce((e,t)=>e+t.length,0)+ca*t.length,r=new Uint8Array(n);let s=0;for(let e=0;e<t.length;e++){const n=t[e],a=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(a,s),s+=ca,r.set(n,s),s+=n.length}e(r)});r.push(e)}else r.push(o.data());null!=t&&(u.group=t),n.push(u)}return{data:ya(await Promise.all(r)),specs:n}}function da(e,t){const n=new ta(e),r={};let s=0;for(const e of t){const t=pa(e,(e,t)=>n.slice(s+e,s+t));r[e.name]=ma(e,n.slice(s,s+t)),s+=t}return r}function pa(e,t){const n=P(e.shape);let r;if("quantization"in e){const t=e.quantization;r=ea[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=ca+new Uint32Array(t(e,e+ca))[0];return e}r=ea[e.dtype]}return n*r}async function fa(e,t){const n=P(e.shape);let r;if("quantization"in e){const t=e.quantization;r=ea[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=ca+new Uint32Array(await t(e,e+ca))[0];return e}r=ea[e.dtype]}return n*r}function ma(e,t){const n=e.name,r=e.dtype,s=e.shape,a=P(s);let i,o=0;if("quantization"in e){const s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s)||!("scale"in s))throw new Error(`Weight ${e.name} with quantization ${s.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==s.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${s.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==r)throw new Error(`Weight ${e.name} is quantized with ${s.dtype} which only supports weights of type float32 not ${r}.`)}const u=ea[s.dtype],l="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===r)if("uint8"===s.dtype||"uint16"===s.dtype){i=new Float32Array(l.length);for(let e=0;e<l.length;e++){const t=l[e];i[e]=t*s.scale+s.min}}else{if("float16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type float32.`);{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;!(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let s=0;s<r.length;s++){const i=r[s],o=e[n[i>>10]+(1023&i)]+t[i>>10];a[s]=o}return new Float32Array(s)}}();i=e(l)}}else{if("int32"!==r)throw new Error(`Unsupported dtype in weight '${n}': ${r}`);if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type int32.`);i=new Int32Array(l.length);for(let e=0;e<l.length;e++){const t=l[e];i[e]=Math.round(t*s.scale+s.min)}}o+=a*u}else if("string"===r){const n=P(e.shape);i=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(o,o+ca))[0];o+=ca;const n=new Uint8Array(t.slice(o,o+e));i.push(n),o+=e}}else{const e=ea[r];if("float32"===r)i=new Float32Array(t);else if("int32"===r)i=new Int32Array(t);else{if("bool"!==r){if("complex64"===r){i=new Float32Array(t);const e=new Float32Array(i.length/2),n=new Float32Array(i.length/2);for(let t=0;t<e.length;t++)e[t]=i[2*t],n[t]=i[2*t+1];const r=Qs(e,s,"float32"),a=Qs(n,s,"float32"),o=Zs(r,a);return r.dispose(),a.dispose(),o}throw new Error(`Unsupported dtype in weight '${n}': ${r}`)}i=new Uint8Array(t)}o+=a*e}return Qs(i,s,r)}async function ga(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){const{done:t,value:s}=await e.read();if(t&&null==s){const e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}const a=new Uint8Array(r.length+s.byteLength);a.set(r,0),a.set(new Uint8Array(s),r.length),r=a}return r.buffer}async function ba(e,t){const n={},r=e.getReader();let s=new ArrayBuffer(0);for(const e of t){const t=await fa(e,async(e,t)=>(s=await ga(r,s,t),s.slice(e,t)));s=await ga(r,s,t);const a=s.slice(0,t);s=s.slice(t);const i=ma(e,a);if(n[e.name]=i,"webgpu"===oa()){const e=la();"uploadToGPU"in e&&P(i.shape)>=pe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}function ya(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)});const r=new Uint8Array(t);let s=0;return n.forEach(e=>{r.set(new Uint8Array(e.buffer),s),s+=e.byteLength}),r.buffer}const xa="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function wa(e){return xa?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function va(e){return ta.join(e)}function _a(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function ka(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function Ta(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function Sa(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),Ta(e,n,r)}function Ia(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:wa(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:wa(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new ta(e.weightData).byteLength}}function Na(e){const t=[];for(const n of e)t.push(...n.weights);return t}class Ea{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Ea.instance&&(Ea.instance=new Ea),Ea.instance}static registerSaveRouter(e){Ea.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Ea.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Ea.getHandlers(e,"save")}static getLoadHandlers(e,t){return Ea.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?Ea.getInstance().loadRouters:Ea.getInstance().saveRouters).forEach(t=>{const s=t(e,n);null!==s&&r.push(s)}),r}}const $a=e=>Ea.registerSaveRouter(e),Aa=e=>Ea.registerLoadRouter(e),Ca=e=>Ea.getSaveHandlers(e),Oa=(e,t)=>Ea.getLoadHandlers(e,t),Ra="tensorflowjs",Da="models_store",Fa="model_info_store";function Pa(){if(!pe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Ma(e){const t=e.result;t.createObjectStore(Da,{keyPath:"modelPath"}),t.createObjectStore(Fa,{keyPath:"modelPath"})}class La{constructor(e){if(this.indexedDB=Pa(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((e,n)=>{const r=this.indexedDB.open(Ra,1);r.onupgradeneeded=()=>Ma(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(Da,"readonly"),r=t.objectStore(Da).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{t.weightData=ta.join(t.weightData);const r=Ia(t),a=s.transaction(Fa,"readwrite");let i,o,u=a.objectStore(Fa);try{i=u.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(e){return n(e)}i.onsuccess=()=>{o=s.transaction(Da,"readwrite");const i=o.objectStore(Da);let l;try{l=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(e){return n(e)}l.onsuccess=()=>e({modelArtifactsInfo:r}),l.onerror=e=>{u=a.objectStore(Fa);const t=u.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(l.error)),t.onerror=e=>(s.close(),n(l.error))}},i.onerror=e=>(s.close(),n(i.error)),a.oncomplete=()=>{null==o?s.close():o.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)})}}La.URL_SCHEME="indexeddb://";const za=e=>{return pe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(La.URL_SCHEME)?(t=e.slice(La.URL_SCHEME.length),new La(t)):null;var t};Ea.registerSaveRouter(za),Ea.registerLoadRouter(za);class Ba{constructor(){this.indexedDB=Pa()}async listModels(){return new Promise((e,t)=>{const n=this.indexedDB.open(Ra,1);n.onupgradeneeded=()=>Ma(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(Fa,"readonly"),a=s.objectStore(Fa).getAll();a.onsuccess=()=>{const t={};for(const e of a.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},a.onerror=e=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)})}async removeModel(e){var t;return e=(t=e).startsWith(La.URL_SCHEME)?t.slice(La.URL_SCHEME.length):t,new Promise((t,n)=>{const r=this.indexedDB.open(Ra,1);r.onupgradeneeded=()=>Ma(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(Fa,"readwrite"),i=a.objectStore(Fa),o=i.get(e);let u;o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),a=()=>{u=s.transaction(Da,"readwrite");const r=u.objectStore(Da).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=a,r.onerror=e=>(a(),s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),a.oncomplete=()=>{null==u?s.close():u.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)})}}const Ua="/",Va="tensorflowjs_models",Wa="info",ja="model_topology",Ga="weight_specs",Ha="weight_data",qa="model_metadata";function Ka(e){return{info:[Va,e,Wa].join(Ua),topology:[Va,e,ja].join(Ua),weightSpecs:[Va,e,Ga].join(Ua),weightData:[Va,e,Ha].join(Ua),modelMetadata:[Va,e,qa].join(Ua)}}function Xa(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Ya(e){const t=e.split(Ua);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Ua)}class Za{constructor(e){if(!pe().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Ka(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=Ia(e),s=ta.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(xa)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}(s));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch(e){throw Xa(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(xa){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}(a),t}}Za.URL_SCHEME="localstorage://";const Ja=e=>{return pe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Za.URL_SCHEME)?(t=e.slice(Za.URL_SCHEME.length),new Za(t)):null;var t};Ea.registerSaveRouter(Ja),Ea.registerLoadRouter(Ja);class Qa{constructor(){R(pe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),R("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Va+Ua,n=Ua+Wa;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);s.startsWith(t)&&s.endsWith(n)&&(e[Ya(s)]=JSON.parse(this.LS.getItem(s)))}return e}async removeModel(e){var t;const n=Ka(e=(t=e).startsWith(Za.URL_SCHEME)?t.slice(Za.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return Xa(n),r}}const ei="://";class ti{constructor(){this.managers={}}static getInstance(){return null==ti.instance&&(ti.instance=new ti),ti.instance}static registerManager(e,t){R(null!=e,()=>"scheme must not be undefined or null."),e.endsWith(ei)&&(e=e.slice(0,e.indexOf(ei))),R(e.length>0,()=>"scheme must not be an empty string.");const n=ti.getInstance();R(null==n.managers[e],()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){const t=ti.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(ti.getInstance().managers)}}function ni(e){if(-1===e.indexOf(ei))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ti.getSchemes().join(",")}`);return{scheme:e.split(ei)[0],path:e.split(ei)[1]}}async function ri(e,t,n=!1){R(e!==t,()=>`Old path and new path are the same: '${e}'`);const r=Ea.getLoadHandlers(e);R(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),R(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);const s=r[0],a=Ea.getSaveHandlers(t);R(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),R(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);const i=a[0],o=ni(e).scheme,u=ni(e).path,l=o===ni(e).scheme,c=await s.load();n&&l&&await ti.getManager(o).removeModel(u);const h=await i.save(c);return n&&!l&&await ti.getManager(o).removeModel(u),h.modelArtifactsInfo}async function si(){const e=ti.getSchemes(),t={};for(const n of e){const e=await ti.getManager(n).listModels();for(const r in e)t[n+ei+r]=e[r]}return t}async function ai(e){const t=ni(e);return ti.getManager(t.scheme).removeModel(t.path)}async function ii(e,t){return ri(e,t,!1)}async function oi(e,t){return ri(e,t,!0)}class ui{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&pe().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0))):setTimeout(e,t)}isTypedArray(e){return Lr(e)}}if(pe().get("IS_BROWSER")){pe().setPlatform("browser",new ui);try{ti.registerManager(Za.URL_SCHEME,new Qa)}catch(e){}try{ti.registerManager(La.URL_SCHEME,new Ba)}catch(e){}}let li;function ci(e,t="float32",n){return t=t||"float32",ie(e),new fs(e,t,n)}pe().get("IS_NODE")&&!pe().get("IS_BROWSER")&&pe().setPlatform("node",new class{constructor(){this.util=__webpack_require__(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=pe().global.fetch?pe().global.fetch(e,t):(null==li&&(li=__webpack_require__(817)),li(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});const hi=Ys({cast_:function(e,t){const n=qs(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return zs.runKernel(Ue,r,s)}}),di=Ys({clone_:function(e){const t={x:qs(e,"x","clone","string_or_numeric")};return zs.runKernel(Ot,t)}});function pi(e,t=!1){console.log(e.toString(t))}Ls(),gs={buffer:ci,cast:hi,clone:di,print:pi};const fi=Ys({add_:function(e,t){let n=qs(e,"a","add"),r=qs(t,"b","add");[n,r]=Cs(n,r);const s={a:n,b:r};return zs.runKernel(ve,s)}}),mi=Ys({floorDiv_:function(e,t){let n=qs(e,"a","floorDiv"),r=qs(t,"b","floorDiv");[n,r]=Cs(n,r);const s={a:n,b:r};return zs.runKernel(It,s)}}),gi=Ys({div_:function(e,t){let n=qs(e,"a","div"),r=qs(t,"b","div");if([n,r]=Cs(n,r),"int32"===n.dtype&&"int32"===r.dtype)return mi(n,r);const s={a:n,b:r};return zs.runKernel(pt,s,{})}}),bi=Ys({mul_:function(e,t){let n=qs(e,"a","mul"),r=qs(t,"b","mul");[n,r]=Cs(n,r);const s={a:n,b:r};return zs.runKernel(ln,s)}}),yi=Ys({sqrt_:function(e){const t={x:qs(e,"x","sqrt","float32")};return zs.runKernel(Xn,t)}}),xi=Ys({square_:function(e){const t=qs(e,"x","square");return zs.runKernel("Square",{x:t},{})}}),wi=Ys({zerosLike_:function(e){const t={x:qs(e,"x","zerosLike")};return zs.runKernel(_r,t)}});function vi(e){return zs.customGrad(e)}function _i(e,t){if((ss(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&ss(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Js(e,[],[],t)}const ki=new Map,Ti=new Map;class Si{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Ii{constructor(){this.classNameMap={}}static getMap(){return null==Ii.instance&&(Ii.instance=new Ii),Ii.instance}static register(e){Ii.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Ni(e,t,n){R(null!=e.className,()=>"Class being registered does not have the static className property defined."),R("string"==typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),R(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),void 0===t&&(t="Custom"),void 0===n&&(n=e.className);const r=t+">"+n;return Ii.register(e),ki.set(r,e),Ti.set(e,r),e}class Ei extends Si{minimize(e,t=!1,n){const{value:r,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map(e=>({name:e.name,tensor:s[e.name]}));this.applyGradients(e)}else this.applyGradients(s);return aa(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){R(J(e),()=>"The f passed in variableGrads(f) must be a function"),R(null==t||Array.isArray(t)&&t.every(e=>e instanceof ws),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=t;if(!n){t=[];for(const e in zs.registeredVariables)t.push(zs.registeredVariables[e])}const r=n?t.filter(e=>!e.trainable):null,s=t.length;t=t.filter(e=>e.trainable),R(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:a,grads:i}=zs.gradients(e,t,null,!0);R(i.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),R(0===a.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const o={};return t.forEach((e,t)=>{null!=i[t]&&(o[e.name]=i[t])}),null!=r&&r.forEach(e=>o[e.name]=null),{value:a,grads:o}}(e,t)}dispose(){null!=this.iterations_&&aa(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:_i(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Ei,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class $i extends Ei{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=zs.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=zs.registeredVariables[t],s=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:sa(()=>wi(r).variable(s))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:sa(()=>wi(r).variable(s))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;sa(()=>{const e=fi(bi(i,this.rho),bi(xi(a),1-this.rho)),t=bi(gi(yi(fi(o,this.epsilon)),yi(fi(i,this.epsilon))),a),n=fi(bi(o,this.rho),bi(xi(t),1-this.rho));i.assign(e),o.assign(n);const s=fi(bi(t,-this.learningRate),r);r.assign(s)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(aa(this.accumulatedGrads.map(e=>e.variable)),aa(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function Ai(e,t,n){ie(e);const r={shape:e,value:t,dtype:n=n||Z(t)};return zs.runKernel(kt,{},r)}class Ci extends Ei{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=zs.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:sa(()=>Ai(r.shape,this.initialAccumulatorValue).variable(e))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable;sa(()=>{const e=fi(a,xi(s));a.assign(e);const t=fi(bi(gi(s,yi(fi(e,zs.backend.epsilon()))),-this.learningRate),r);r.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&aa(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const Oi=Ys({pow_:function(e,t){let n=qs(e,"base","pow"),r=qs(t,"exp","pow");[n,r]=Cs(n,r);const s={a:n,b:r};return zs.runKernel(xn,s)}}),Ri=Ys({sub_:function(e,t){let n=qs(e,"a","sub"),r=qs(t,"b","sub");[n,r]=Cs(n,r);const s={a:n,b:r};return zs.runKernel(dr,s)}});class Di extends Ei{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],sa(()=>{this.accBeta1=_i(t).variable(),this.accBeta2=_i(n).variable()}),null==r&&(this.epsilon=zs.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);sa(()=>{const n=Ri(1,this.accBeta1),r=Ri(1,this.accBeta2);t.forEach((t,s)=>{const a=zs.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:sa(()=>wi(a).variable(i))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:sa(()=>wi(a).variable(i))});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const u=this.accumulatedFirstMoment[s].variable,l=this.accumulatedSecondMoment[s].variable,c=fi(bi(u,this.beta1),bi(o,1-this.beta1)),h=fi(bi(l,this.beta2),bi(xi(o),1-this.beta2)),d=gi(c,n),p=gi(h,r);u.assign(c),l.assign(h);const f=fi(bi(gi(d,fi(yi(p),this.epsilon)),-this.learningRate),a);a.assign(f)}),this.accBeta1.assign(bi(this.accBeta1,this.beta1)),this.accBeta2.assign(bi(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&aa(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&aa(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),sa(()=>{this.accBeta1.assign(Oi(this.beta1,this.iterations_+1)),this.accBeta2.assign(Oi(this.beta2,this.iterations_+1))});const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const Fi=Ys({abs_:function(e){const t=qs(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return zs.runKernel(Ge,e)}{const e={x:t};return zs.runKernel(ye,e)}}});function Pi(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(a)}return r}function Mi(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(null==s||1===s&&i>1)&&n.unshift(a)}return n}function Li(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];null==a&&(a=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===a)r[n-s-1]=i;else if(1===i)r[n-s-1]=a;else{if(a!==i)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);r[n-s-1]=a}}return r}const zi=Ys({maximum_:function(e,t){let n=qs(e,"a","maximum"),r=qs(t,"b","maximum");[n,r]=Cs(n,r),"bool"===n.dtype&&(n=hi(n,"int32"),r=hi(r,"int32")),Li(n.shape,r.shape);const s={a:n,b:r};return zs.runKernel(Yt,s)}});class Bi extends Ei{static get className(){return"Adamax"}constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],sa(()=>{this.iteration=_i(0).variable(),this.accBeta1=_i(t).variable()}),null==r&&(this.epsilon=zs.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);sa(()=>{const n=Ri(1,this.accBeta1),r=gi(-this.learningRate,fi(bi(this.iteration,this.decay),1));t.forEach((t,s)=>{const a=zs.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:wi(a).variable(i)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:wi(a).variable(i)});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const u=this.accumulatedFirstMoment[s].variable,l=this.accumulatedWeightedInfNorm[s].variable,c=fi(bi(u,this.beta1),bi(o,1-this.beta1)),h=bi(l,this.beta2),d=Fi(o),p=zi(h,d);u.assign(c),l.assign(p);const f=fi(bi(gi(r,n),gi(c,fi(p,this.epsilon))),a);a.assign(f)}),this.iteration.assign(fi(this.iteration,1)),this.accBeta1.assign(bi(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&aa(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&aa(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class Ui extends Ei{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=zs.registeredVariables[t];sa(()=>{const e=fi(bi(this.c,r),s);s.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=ia(_i(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class Vi extends Ui{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=_i(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=zs.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:sa(()=>wi(r).variable(e))}}const s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&sa(()=>{let e;const t=fi(bi(this.m,s),a);e=this.useNesterov?fi(bi(this.c,fi(a,bi(t,this.m))),r):fi(bi(this.c,t),r),s.assign(t),r.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&aa(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class Wi extends Ei{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=zs.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=zs.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:sa(()=>wi(r).variable(s))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:sa(()=>wi(r).variable(s))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:sa(()=>wi(r).variable(s))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;sa(()=>{const e=fi(bi(i,this.decay),bi(xi(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=fi(bi(t,this.decay),bi(a,1-this.decay)),u=gi(bi(a,this.learningRate),yi(Ri(e,fi(xi(s),this.epsilon)))),l=fi(bi(o,this.momentum),u);i.assign(e),t.assign(s),o.assign(l);const c=Ri(r,l);r.assign(c)}else{const e=fi(bi(i,this.decay),bi(xi(a),1-this.decay)),t=fi(bi(o,this.momentum),gi(bi(a,this.learningRate),yi(fi(e,this.epsilon))));i.assign(e),o.assign(t);const n=Ri(r,t);r.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&aa(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&aa(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&aa(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const ji=[$i,Ci,Di,Bi,Vi,Wi,Ui];function Gi(e){return new Promise(e=>setTimeout(e)).then(e)}class Hi{constructor(e){if(!pe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Hi.URL_SCHEME)&&(e=e.slice(Hi.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=ta.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=ka(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=r,await Gi(()=>s.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Gi(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Ia(e)}}}}Hi.URL_SCHEME="downloads://";class qi{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),s=r.modelTopology;if(null==s)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:s});const a=Sa(r,e=>this.loadWeights(e));e(a)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){const t=[],n=[];for(const r of e)t.push(...r.weights),n.push(...r.paths);const r=this.checkManifestAndWeightFiles(e),s=n.map(e=>this.loadWeightsFile(e,r[e]));return Promise.all(s).then(e=>[t,e])}loadWeightsFile(e,t){return new Promise((n,r)=>{const s=new FileReader;s.onload=e=>{const t=e.target.result;n(t)},s.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map(e=>_a(e.name)),r={};for(const s of e)s.paths.forEach(e=>{const s=_a(e);if(-1!==t.indexOf(s))throw new Error(`Duplicate file basename found in weights manifest: '${s}'`);if(t.push(s),-1===n.indexOf(s))throw new Error(`Weight file with basename '${s}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(s)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function Ki(e){return new qi(e)}function Xi(e,t,n,r){!function(e){R(null!=e&&Array.isArray(e)&&e.length>0,()=>"promises must be a none empty array")}(e),function(e,t){R(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`),R(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`),R(t>=e,()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`)}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map(a=>(a.then(a=>{const i=n+ ++s/e.length*(r-n);return t(i),a}),a)))}async function Yi(e,t){null==t&&(t={});const n=null==t.fetchFunc?pe().platform.fetch:t.fetchFunc,r=e.map(e=>n(e,t.requestInit,{isBinary:!0})),s=(null==t.onProgress?await Promise.all(r):await Xi(r,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==t.onProgress?await Promise.all(s):await Xi(s,t.onProgress,.5,1)}async function Zi(e,t="",n,r){return Ji(e=>Yi(e,{requestInit:r}))(e,t,n)}function Ji(e){return async(t,n="",r)=>{const s=t.map(()=>!1),a={},i=null!=r?r.map(()=>!1):[],o=[];if(t.forEach((e,t)=>{let n=0;e.weights.forEach(e=>{const u="quantization"in e?e.quantization.dtype:e.dtype,l=ea[u]*P(e.shape),c=()=>{s[t]=!0,null==a[t]&&(a[t]=[]),a[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=r?r.forEach((t,n)=>{t===e.name&&(c(),i[n]=!0)}):c(),o.push(e.name),n+=l})}),!i.every(e=>e)){const e=r.filter((e,t)=>!i[t]);throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const u=s.reduce((e,t,n)=>(t&&e.push(n),e),[]),l=[];u.forEach(e=>{t[e].paths.forEach(e=>{const t=n+(n.endsWith("/")?"":"/")+e;l.push(t)})});const c=await e(l),h={};let d=0;return u.forEach(e=>{const n=t[e].paths.length,r=new ta(c.slice(d,d+n));a[e].forEach(e=>{const t=da(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const e in t)h[e]=t[e]}),d+=n}),h}}Ea.registerSaveRouter(e=>pe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Hi.URL_SCHEME)?function(e="model"){return new Hi(e)}(e.slice(Hi.URL_SCHEME.length)):null);class Qi{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(R("function"==typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=pe().platform.fetch,R(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&R(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=ka(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=ta.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:Ia(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){return this.loadOptions.streamWeights?this.loadStream():Sa(await this.loadModelJSON(),e=>this.loadWeights(e))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=Na(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?pe().platform.fetch:t.fetchFunc;let s,a=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;a<e.length;){if(!s){const n=(await r(e[a],t.requestInit,{isBinary:!0})).body;s=n.getReader()}const{done:o,value:u}=await s.read();if(!o)return void n.enqueue(u);a++,s=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,a/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(t),s=this.weightPathPrefix||n,a=[],i=[];for(const t of e)for(const e of t.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):a.push(s+e+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),a}async loadWeights(e){const t=await this.getWeightUrls(e);return[Na(e),await Yi(t,this.loadOptions)]}}function eo(e){return null!=e.match(Qi.URL_SCHEME_REGEX)}Qi.URL_SCHEME_REGEX=/^https?:\/\//;const to=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every(e=>eo(e)):eo(e),n)return no(e,t)}return null};function no(e,t){return new Qi(e,t)}function ro(e,t){return no(e,t)}Ea.registerSaveRouter(to),Ea.registerLoadRouter(to);class so{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class ao{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class io{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function oo(e,t,n,r){return new io(uo(...arguments))}function uo(e,t,n,r){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new so(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new so({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new so({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function lo(e){return new ao(e)}function co(e){return new ao(e)}function ho(e,t,n){if(F(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=js(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Js(e,t,r,n)}const po=-2,fo=-1;function mo(e,t,n){const r=e.shape.length;R(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),R(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)R(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function go(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function bo(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function yo(e,t,n,r){const s=[...e];for(let e=s.length;e<r.length;e++)s.push(1);for(let e=0;e<n;e++)0===e?s[t]=1:(s.splice(t,0,1),s.pop());return s}function xo(e,t,n){return n<=e?n:n-(t-1)}function wo(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function vo(e,t,n,r,s,a,i,o,u){const l=e.length;let c=new Array(l),h=new Array(l),d=new Array(l);if(t.length&&n>0){const u=t[0],l=n+1;c=_o(i,u,l,r,e),h=ko(o,u,l,s,e),d=yo(a,u,l,e)}else for(let t=0;t<l;t++)c[t]=So(i,r,a,e,t,u),h[t]=Io(o,s,a,e,t,u),d[t]=To(a,t,u);return{begin:c,end:h,strides:d}}function _o(e,t,n,r,s){const a=[...s],i=wo(n,t);for(let s=0;s<a.length;s++)if(i.indexOf(s)>-1)a[s]=0;else{const i=xo(t,n,s);let o=r[i];e&1<<i&&(o=0),a[s]=o}return a}function ko(e,t,n,r,s){const a=[...s],i=wo(n,t);for(let s=0;s<a.length;s++)if(i.indexOf(s)>-1)a[s]=Number.MAX_SAFE_INTEGER;else{const i=xo(t,n,s);let o=r[i];e&1<<i&&(o=Number.MAX_SAFE_INTEGER),a[s]=o}for(let e=0;e<a.length;e++){const t=s[e];a[e]<0&&(a[e]+=t),a[e]=A(0,a[e],s[e])}return a}function To(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function So(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=r[s];return i<0&&(i+=u),i=A(0,i,u-1),i}function Io(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=r[s];return i<0&&(i+=u),i=o>0?A(0,i,u):A(-1,i,u-1),i}function No(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function Eo(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function $o(e,t,n){let r;const s=e.shape.length;let a;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(e=>{R(-1!==e,()=>"slice() does not support negative begin indexing.")}),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map((t,n)=>t>=0?t:(R(-1===t,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`),e.shape[n]-r[n])),[r,a]}function Ao(e,t,n,r,s,a,i,o,u){let l;if(null==r?(l=new Array(t.length),l.fill(1)):l=r,null!=i&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};for(let e=0;e<h.dims;e++)c&&1<<e&o&&h.numAddAxisAfterEllipsis++,1<<e&i&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(po),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(fo),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(h,d);let p=!0,f=!0,m=!0;const g=[],b=[];for(let t=0;t<e.length;++t){if(0===d.strides[t])throw Error(`strides[${t}] must be non-zero`);const n=!!(d.shrinkAxisMask&1<<t),r=e[t];if(-1===r){g.push(n?1:-1);continue}const s=[d.beginMask&1<<t,d.endMask&1<<t],a=[d.strides[t]>0?0:-1,d.strides[t]>0?r:r-1];if(n&&d.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[t];const i=!!(d.beginMask&1<<t&&d.endMask&1<<t);if(d.beginValid&&d.endValid){if(n){const e=d.begin[t]<0?r+d.begin[t]:d.begin[t];if(d.begin[t]=e,d.end[t]=d.begin[t]+1,e<0||e>=r)throw Error(`slice index ${d.begin[t]} of dimension ${t} out of bounds.`)}else d.begin[t]=Co(d.begin[t],0,d.strides[t],r,s,a),d.end[t]=Co(d.end[t],1,d.strides[t],r,s,a);const e=1===d.strides[t]&&0===d.begin[t]&&d.end[t]===r;p=p&&e,f=f&&(0===t&&1===d.strides[t]||e)}else p=p&&1===d.strides[t]&&i,f=f&&(0===t&&1===d.strides[t]||i);let o,u=!1;if(d.beginValid&&d.endValid?(o=d.end[t]-d.begin[t],u=!0):n?(o=1,u=!0):i&&r>=0&&(o=d.strides[t]<0?-r:r,u=!0),u){let e;e=0===o||o<0!=d.strides[t]<0?0:Math.trunc(o/d.strides[t])+(o%d.strides[t]!==0?1:0),g.push(e)}else g.push(-1)}for(let e=0;e<d.finalShapeGatherIndices.length;++e){const t=d.finalShapeGatherIndices[e];t>=0?b.push(g[t]):t===po&&b.push(1)}return{finalShapeSparse:b.filter((e,t)=>d.finalShapeGatherIndices[t]!==po),finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function Co(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const t=e<0?r+e:e;return t<a[0]?a[0]:t>a[1]?a[1]:t}}const Oo=Ys({acos_:function(e){const t={x:qs(e,"x","acos")};return zs.runKernel(xe,t)}}),Ro=Ys({acosh_:function(e){const t={x:qs(e,"x","acosh")};return zs.runKernel(we,t)}}),Do=Ys({addN_:function(e){R(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),R(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);const t=e.map((e,t)=>qs(e,`tensors${t}`,"addN")),n=t[0];t.forEach(e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(e=>{if(!M(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=t;return zs.runKernel(_e,r)}}),Fo=Ys({all_:function(e,t=null,n=!1){const r={x:qs(e,"x","all","bool")},s={axis:t,keepDims:n};return zs.runKernel(ke,r,s)}}),Po=Ys({any_:function(e,t=null,n=!1){const r={x:qs(e,"x","any","bool")},s={axis:t,keepDims:n};return zs.runKernel(Te,r,s)}}),Mo=Ys({argMax_:function(e,t=0){const n={x:qs(e,"x","argMax")},r={axis:t};return zs.runKernel(Se,n,r)}}),Lo=Ys({argMin_:function(e,t=0){const n={x:qs(e,"x","argMin")},r={axis:t};return zs.runKernel(Ie,n,r)}}),zo=Ys({asin_:function(e){const t={x:qs(e,"x","asin")};return zs.runKernel(Ne,t)}}),Bo=Ys({asinh_:function(e){const t={x:qs(e,"x","asinh")};return zs.runKernel(Ee,t)}}),Uo=Ys({atan_:function(e){const t={x:qs(e,"x","atan")};return zs.runKernel($e,t)}}),Vo=Ys({atan2_:function(e,t){let n=qs(e,"a","atan2"),r=qs(t,"b","atan2");[n,r]=Cs(n,r);const s={a:n,b:r};return zs.runKernel(Ce,s)}}),Wo=Ys({atanh_:function(e){const t={x:qs(e,"x","atanh")};return zs.runKernel(Ae,t)}});function jo(e,t,n,r,s="NHWC",a){return qo(e,[...t,e[3]],n,a,r,null,null,ru(s))}function Go(e,t,n,r,s,a,i="channelsLast"){const[o,u]=Yo(t);let l;if("channelsLast"===i)l=[o,u,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);l=[o,u,e[1],e[1]]}return qo(e,l,n,r,s,a,!1,i)}function Ho(e,t,n,r,s,a,i="NDHWC"){const[o,u,l]=Zo(t);let c,h;if("NDHWC"===i)h="channelsLast",c=[o,u,l,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);h="channelsFirst",c=[o,u,l,e[1],e[1]]}return Ko(e,c,n,r,s,!1,h,a)}function qo(e,t,n,r,s,a,i=!1,o="channelsLast"){let[u,l,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[u,l,c,h]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[u,h,l,c]=e}const[d,p,,f]=t,[m,g]=Yo(n),[b,y]=Yo(r),x=Jo(d,b),w=Jo(p,y),{padInfo:v,outHeight:_,outWidth:k}=function(e,t,n,r,s,a,i,o,u){let l,c,h;if("number"==typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,s){null==r&&(r=Xo(e,t,n));const a=e[1];return[Qo((e[0]-t+2*r)/n+1,s),Qo((a-t+2*r)/n+1,s)]}([t,n],a,r,e,o);c=s[0],h=s[1]}else if("same"===e){c=Math.ceil(t/r),h=Math.ceil(n/s);const e=Math.max(0,(c-1)*r+a-t),o=Math.max(0,(h-1)*s+i-n),u=Math.floor(e/2),d=e-u,p=Math.floor(o/2);l={top:u,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),h=Math.ceil((n-i+1)/s);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const d="channelsLast"===u?e[1][0]:e[2][0],p="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1];l={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=Qo((t-a+d+p)/r+1,o),h=Qo((n-i+f+m)/s+1,o)}}return{padInfo:l,outHeight:c,outWidth:h}}(s,l,c,m,g,x,w,a,o),T=i?f*h:f;let S;return"channelsFirst"===o?S=[u,T,_,k]:"channelsLast"===o&&(S=[u,_,k,T]),{batchSize:u,dataFormat:o,inHeight:l,inWidth:c,inChannels:h,outHeight:_,outWidth:k,outChannels:T,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:y,inShape:e,outShape:S,filterShape:t}}function Ko(e,t,n,r,s,a=!1,i="channelsLast",o){let[u,l,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[u,l,c,h,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[u,d,l,c,h]=e}const[p,f,m,,g]=t,[b,y,x]=Zo(n),[w,v,_]=Zo(r),k=Jo(p,w),T=Jo(f,v),S=Jo(m,_),{padInfo:I,outDepth:N,outHeight:E,outWidth:$}=function(e,t,n,r,s,a,i,o,u,l,c){let h,d,p,f;if("valid"===e&&(e=0),"number"==typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,r,s,a){null==s&&(s=Xo(e,t[0],r[0]));const i=[0,0,0,1];for(let n=0;n<3;n++)e[n]+2*s>=t[n]&&(i[n]=Qo((e[n]-t[n]+2*s)/r[n]+1,a));return i}([t,n,r,1],[o,u,l],0,[s,a,i],e,c);d=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{d=Math.ceil(t/s),p=Math.ceil(n/a),f=Math.ceil(r/i);const e=(d-1)*s+o-t,c=(p-1)*a+u-n,m=(f-1)*i+l-r,g=Math.floor(e/2),b=e-g,y=Math.floor(c/2),x=c-y,w=Math.floor(m/2);h={top:y,bottom:x,left:w,right:m-w,front:g,back:b,type:"SAME"}}}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(s,l,c,h,b,y,x,k,T,S,o),A=a?g*d:g;let C;return"channelsFirst"===i?C=[u,A,N,E,$]:"channelsLast"===i&&(C=[u,N,E,$,A]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:h,inChannels:d,outDepth:N,outHeight:E,outWidth:$,outChannels:A,padInfo:I,strideDepth:b,strideHeight:y,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:T,effectiveFilterWidth:S,dilationDepth:w,dilationHeight:v,dilationWidth:_,inShape:e,outShape:C,filterShape:t}}function Xo(e,t,n,r=1){const s=Jo(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function Yo(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Zo(e){return"number"==typeof e?[e,e,e]:e}function Jo(e,t){return t<=1?e:e+(e-1)*(t-1)}function Qo(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function eu(e){const[t,n,r]=Yo(e);return 1===t&&1===n&&1===r}function tu(e,t){return eu(e)||eu(t)}function nu(e){return Yo(e).every(e=>e>0)}function ru(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function su(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)R(L(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach(t=>{t.forEach(t=>{R(L(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`)})})}}}const au=Ys({reshape_:function(e,t){const n={x:qs(e,"x","reshape","string_or_numeric")},r={shape:t};return zs.runKernel($n,n,r)}}),iu=Ys({avgPool_:function(e,t,n,r,s){const a=qs(e,"x","avgPool","float32");R(tu(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let i=a,o=!1;3===a.rank&&(o=!0,i=au(a,[1,a.shape[0],a.shape[1],a.shape[2]])),R(4===i.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),su("avgPool",r,s);const u={x:i},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s};let c=zs.runKernel(Oe,u,l);return c=hi(c,a.dtype),o?au(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),ou=Ys({avgPool3d_:function(e,t,n,r,s,a="NDHWC"){const i=qs(e,"x","avgPool3d","float32");let o=i,u=!1;4===i.rank&&(u=!0,o=au(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),R(5===o.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),R("NDHWC"===a,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),R("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),su("avgPool3d",r,s);const l={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let h=zs.runKernel(De,l,c);return h=hi(h,o.dtype),u?au(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),uu=Ys({concat_:function(e,t=0){R(e.length>=1,()=>"Pass at least one tensor to concat");const n=Ks(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)}),1===n.length)return di(n[0]);const r=n,s={axis:t};return zs.runKernel(He,r,s)}}),lu=Ys({matMul_:function(e,t,n=!1,r=!1){let s=qs(e,"a","matMul"),a=qs(t,"b","matMul");[s,a]=Cs(s,a);const i={a:s,b:a},o={transposeA:n,transposeB:r};return zs.runKernel(Pe,i,o)}}),cu=Ys({sigmoid_:function(e){const t={x:qs(e,"x","sigmoid","float32")};return zs.runKernel(qn,t)}}),hu=Ys({slice_:function(e,t,n){const r=qs(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return zs.runKernel(Wn,s,a)}}),du=Ys({tanh_:function(e){const t={x:qs(e,"x","tanh","float32")};return zs.runKernel(fr,t)}}),pu=Ys({basicLSTMCell_:function(e,t,n,r,s,a){const i=qs(e,"forgetBias","basicLSTMCell"),o=qs(t,"lstmKernel","basicLSTMCell"),u=qs(n,"lstmBias","basicLSTMCell"),l=qs(r,"data","basicLSTMCell"),c=qs(s,"c","basicLSTMCell"),h=qs(a,"h","basicLSTMCell"),d=uu([l,h],1),p=lu(d,o),f=fi(p,u),m=f.shape[0],g=f.shape[1]/4,b=[m,g],y=hu(f,[0,0],b),x=hu(f,[0,g],b),w=hu(f,[0,2*g],b),v=hu(f,[0,3*g],b),_=fi(bi(cu(y),du(x)),bi(c,cu(fi(i,w))));return[_,bi(du(_),cu(v))]}}),fu=Ys({batchToSpaceND_:function(e,t,n){const r=qs(e,"x","batchToSpaceND"),s=t.reduce((e,t)=>e*t);R(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),R(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),R(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);const a={x:r},i={blockShape:t,crops:n};return zs.runKernel(Me,a,i)}}),mu=Ys({batchNorm_:function(e,t,n,r,s,a){null==a&&(a=.001);const i=qs(e,"x","batchNorm"),o=qs(t,"mean","batchNorm"),u=qs(n,"variance","batchNorm");let l,c;null!=s&&(l=qs(s,"scale","batchNorm")),null!=r&&(c=qs(r,"offset","batchNorm")),R(o.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(null==c||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(null==l||o.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:function(e){let t;return t=0===e.rank||1===e.rank?au(e,[1,1,1,e.size]):2===e.rank?au(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?au(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),scale:l,offset:c,mean:o,variance:u},d={varianceEpsilon:a},p=zs.runKernel(Nt,h,d);return au(p,i.shape)}}),gu=Ys({batchNorm2d_:function(e,t,n,r,s,a){const i=qs(e,"x","batchNorm"),o=qs(t,"mean","batchNorm"),u=qs(n,"variance","batchNorm");let l,c;return null!=s&&(l=qs(s,"scale","batchNorm")),null!=r&&(c=qs(r,"offset","batchNorm")),R(2===i.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),R(2===o.rank||1===o.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),R(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=l&&R(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=c&&R(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),mu(i,o,u,c,l,a)}}),bu=Ys({batchNorm3d_:function(e,t,n,r,s,a){const i=qs(e,"x","batchNorm"),o=qs(t,"mean","batchNorm"),u=qs(n,"variance","batchNorm");let l,c;return null!=s&&(l=qs(s,"scale","batchNorm")),null!=r&&(c=qs(r,"offset","batchNorm")),R(3===i.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),R(3===o.rank||1===o.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),R(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=l&&R(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=c&&R(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),mu(i,o,u,c,l,a)}}),yu=Ys({batchNorm4d_:function(e,t,n,r,s,a){const i=qs(e,"x","batchNorm"),o=qs(t,"mean","batchNorm"),u=qs(n,"variance","batchNorm");let l,c;return null!=s&&(l=qs(s,"scale","batchNorm")),null!=r&&(c=qs(r,"offset","batchNorm")),R(4===i.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),R(4===o.rank||1===o.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),R(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=l&&R(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=c&&R(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),mu(i,o,u,c,l,a)}}),xu=Ys({bincount_:function(e,t,n){const r=qs(e,"x","bincount"),s=qs(t,"weights","bincount");R("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),R(n>=0,()=>`size must be non-negative, but got ${n}.`),R(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const a={x:r,weights:s},i={size:n};return zs.runKernel(Le,a,i)}}),wu=Ys({bitwiseAnd_:function(e,t){const n=qs(e,"x","bitwiseAnd"),r=qs(t,"y","bitwiseAnd");if(!M(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const s={a:n,b:r};return zs.runKernel(ze,s)}}),vu=Ys({broadcastArgs_:function(e,t){const n=qs(e,"s0","broadcastArgs","int32"),r=qs(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return zs.runKernel(Be,s)}}),_u=Ys({broadcastTo_:function(e,t){let n=qs(e,"broadcastTo","x");const r=n.shape;if(ie(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=au(n,e)}const s=n.shape,a=Array.from(t);for(let e=t.length-1;e>=0;e--)if(s[e]===t[e])a[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===a.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length)return di(n);const i={x:n},o={reps:a};return zs.runKernel(mr,i,o)}}),ku=Ys({ceil_:function(e){const t={x:qs(e,"x","ceil","float32")};return zs.runKernel(Ve,t)}}),Tu=Ys({clipByValue_:function(e,t,n){const r=qs(e,"x","clipByValue");if(R(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Ai(r.shape,t,r.dtype);const s={x:r},a={clipValueMin:t,clipValueMax:n};return zs.runKernel(We,s,a)}}),Su=Ys({concat1d_:function(e){return uu(e,0)}}),Iu=Ys({concat2d_:function(e,t){return uu(e,t)}}),Nu=Ys({concat3d_:function(e,t){return uu(e,t)}}),Eu=Ys({concat4d_:function(e,t){return uu(e,t)}}),$u=Ys({conv2d_:function(e,t,n,r,s="NHWC",a=[1,1],i){const o=qs(e,"x","conv2d","float32"),u=qs(t,"filter","conv2d","float32");let l=o,c=!1;3===o.rank&&(c=!0,l=au(o,[1,o.shape[0],o.shape[1],o.shape[2]])),R(4===l.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),R(4===u.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),su("conv2d",r,i);const h="NHWC"===s?l.shape[3]:l.shape[1];R(h===u.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`),R(tu(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),R(nu(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),R(nu(n),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:l,filter:u},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=zs.runKernel(qe,d,p);return c?au(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Au=Ys({conv1d_:function(e,t,n,r,s="NWC",a=1,i){const o=qs(e,"x","conv1d"),u=qs(t,"filter","conv1d");let l=o,c=!1;2===o.rank&&(c=!0,l=au(o,[1,o.shape[0],o.shape[1]])),R(3===l.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),R(3===u.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),su("conv1d",r,i),R(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),R(tu(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),R(nu(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),R(nu(n),()=>"Error in conv1D: Stride should be larger than 0."),R("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=au(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=au(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=$u(d,h,[1,n],r,"NHWC",[1,a],i);return au(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),Cu=Ys({conv2DBackpropInput_:function(e,t,n,r,s,a="NHWC",i){R(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,u=t,l=!1;3===t.rank&&(l=!0,u=au(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),R(4===o.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),R(4===u.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),R(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c="NHWC"===a?o[3]:o[1],h="NHWC"===a?u.shape[3]:u.shape[1];R(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),R(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),su("conv2dDerInput",s,i);const d={dy:u,filter:n},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=zs.runKernel(Xe,d,p);return l?au(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Ou=Ys({conv2dTranspose_:function(e,t,n,r,s,a){const i=qs(e,"x","conv2dTranspose"),o=qs(t,"filter","conv2dTranspose");return Cu(n,i,o,r,s,"NHWC",a)}}),Ru=Ys({conv3d_:function(e,t,n,r,s="NDHWC",a=[1,1,1]){const i=qs(e,"x","conv3d"),o=qs(t,"filter","conv3d");let u=i,l=!1;4===i.rank&&(l=!0,u=au(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),R(5===u.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),R(5===o.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),R(u.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`),R(tu(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),R("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),R(nu(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),R(nu(n),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:u,filter:o},h={strides:n,pad:r,dataFormat:s,dilations:a},d=zs.runKernel(Ye,c,h);return l?au(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Du=Ys({conv3DBackpropInput_:function(e,t,n,r,s){R(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,i=t,o=!1;4===t.rank&&(o=!0,i=au(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const u=a[4],l=i.shape[4];R(5===a.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),R(5===i.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),R(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),R(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),R(l===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`);const c={dy:i,filter:n},h={pad:s,strides:r,inputShape:a},d=zs.runKernel(Je,c,h);return o?au(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Fu=Ys({conv3dTranspose_:function(e,t,n,r,s){const a=qs(e,"x","conv3dTranspose"),i=qs(t,"filter","conv3dTranspose");return Du(n,a,i,r,s)}}),Pu=Ys({cos_:function(e){const t={x:qs(e,"x","cos","float32")};return zs.runKernel(Qe,t)}}),Mu=Ys({cosh_:function(e){const t={x:qs(e,"x","cosh","float32")};return zs.runKernel(et,t)}}),Lu=Ys({cumprod_:function(e,t=0,n=!1,r=!1){const s={x:qs(e,"x","cumprod")},a={axis:t,exclusive:n,reverse:r};return zs.runKernel(tt,s,a)}}),zu=Ys({cumsum_:function(e,t=0,n=!1,r=!1){const s={x:qs(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return zs.runKernel(nt,s,a)}}),Bu=Ys({denseBincount_:function(e,t,n,r=!1){const s=qs(e,"x","denseBincount"),a=qs(t,"weights","denseBincount");R("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),R(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),R(n>=0,()=>`size must be non-negative, but got ${n}.`),R(a.size===s.size||0===a.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);const i={x:s,weights:a},o={size:n,binaryOutput:r};return zs.runKernel(st,i,o)}}),Uu=Ys({depthToSpace_:function(e,t,n="NHWC"){const r=qs(e,"x","depthToSpace","float32"),s="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];R(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),R(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),R(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${r.shape}`),R(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);const o={x:r},u={blockSize:t,dataFormat:n};return zs.runKernel(at,o,u)}}),Vu=Ys({depthwiseConv2d_:function(e,t,n,r,s="NHWC",a=[1,1],i){const o=qs(e,"x","depthwiseConv2d","float32"),u=qs(t,"filter","depthwiseConv2d","float32");let l=o,c=!1;3===o.rank&&(c=!0,l=au(o,[1,o.shape[0],o.shape[1],o.shape[2]])),R(4===l.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),R(4===u.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const h="NHWC"===s?l.shape[3]:l.shape[1];R(h===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${u.shape[2]}.`),su("depthwiseConv2d",r,i);const d={x:l,filter:u},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=zs.runKernel(it,d,p);return c?au(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Wu=Ys({diag_:function(e){const t={x:qs(e,"x","diag")};return zs.runKernel(lt,t)}}),ju=Ys({dilation2d_:function(e,t,n,r,s=[1,1],a="NHWC"){const i=qs(e,"x","dilation2d"),o=qs(t,"filter","dilation2d");R(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),R(3===o.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),R("NHWC"===a,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=i,l=!1;3===i.rank&&(u=au(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0),R(u.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${o.shape[2]}`);const c={x:u,filter:o},h={strides:n,pad:r,dilations:s},d=zs.runKernel(ct,c,h);return l?au(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Gu=Ys({equal_:function(e,t){let n=qs(e,"a","equal","string_or_numeric"),r=qs(t,"b","equal","string_or_numeric");[n,r]=Cs(n,r),Li(n.shape,r.shape);const s={a:n,b:r};return zs.runKernel(yt,s)}}),Hu=Ys({where_:function(e,t,n){const r=qs(t,"a","where"),s=qs(n,"b","where"),a=qs(e,"condition","where","bool"),i=Li(Li(a.shape,r.shape),s.shape),o={condition:_u(a,i),t:_u(r,i),e:_u(s,i)};return zs.runKernel(Un,o)}}),qu=Ys({divNoNan_:function(e,t){let n=qs(e,"a","div"),r=qs(t,"b","div");[n,r]=Cs(n,r);const s=gi(n,r),a=wi(s),i=Gu(r,a);return Hu(i,a,s)}}),Ku=Ys({dot_:function(e,t){const n=qs(e,"t1","dot"),r=qs(t,"t2","dot");R(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];if(R(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),1===n.rank&&1===r.rank){const e=au(n,[1,-1]),t=au(r,[-1,1]),s=lu(e,t);return au(s,[])}if(1===n.rank&&2===r.rank){const e=au(n,[1,-1]),t=au(r,[r.shape[0],r.shape[1]]),s=lu(e,t);return au(s,[s.size])}if(2===n.rank&&1===r.rank){const e=au(r,[-1,1]),t=lu(n,e);return au(t,[t.size])}{const e=au(r,[r.shape[0],r.shape[1]]);return lu(n,e)}}}),Xu=Ys({einsum_:function(e,...t){const n=t.map((e,t)=>qs(e,`tensors${t}`,"einsum")),r={equation:e};return zs.runKernel(ft,n,r)}}),Yu=Ys({elu_:function(e){const t={x:qs(e,"x","elu","float32")};return zs.runKernel(mt,t)}}),Zu=Ys({ensureShape_:function(e,t){const n=qs(e,"x","ensureShape","string_or_numeric");if(!function(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}}),Ju=Ys({erf_:function(e){let t=qs(e,"x","erf");R("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=hi(t,"float32"));const n={x:t};return zs.runKernel(bt,n)}});function Qu(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function el(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?s.push(e[a++]):s.push(t[i++]);return s}function tl(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map(t=>e[t])]}function nl(e,t){return el(e,t.map(e=>1),t)}function rl(e,t,n){R(Qu(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function sl(e,t){if(Qu(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach(e=>n.push(e)),n}function al(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function il(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const ol=Ys({max_:function(e,t=null,n=!1){const r={x:qs(e,"x","max")},s={reductionIndices:t,keepDims:n};return zs.runKernel(Xt,r,s)}}),ul=Ys({min_:function(e,t=null,n=!1){const r={x:qs(e,"x","min")},s={axis:t,keepDims:n};return zs.runKernel(rn,r,s)}}),ll=Ys({sum_:function(e,t=null,n=!1){let r=qs(e,"x","sum");"bool"===r.dtype&&(r=hi(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return zs.runKernel(Yn,s,a)}});function cl(e,t,n=null){if(0===e.rank)return Fi(e);if(1!==e.rank&&null===n)return cl(au(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return ll(Fi(e),n);if(t===1/0)return ol(Fi(e),n);if(t===-1/0)return ul(Fi(e),n);if("euclidean"===t||2===t)return yi(ll(Oi(Fi(e),_i(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return ol(ll(Fi(e),n[0]),n[1]-1);if(t===1/0)return ol(ll(Fi(e),n[1]),n[0]);if(t===-1/0)return ul(ll(Fi(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return yi(ll(xi(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const hl=Ys({norm_:function(e,t="euclidean",n=null,r=!1){const s=cl(e=qs(e,"x","norm"),t,n);let a=s.shape;if(r){const t=W(n,e.shape);a=nl(s.shape,t)}return au(s,a)}}),dl=Ys({euclideanNorm_:function(e,t=null,n=!1){return hl(e,"euclidean",t,n)}}),pl=Ys({exp_:function(e){const t={x:qs(e,"x","exp")};return zs.runKernel(xt,t)}}),fl=Ys({expandDims_:function(e,t=0){const n=qs(e,"x","expandDims","string_or_numeric");R(t<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:t};return zs.runKernel(wt,r,s)}}),ml=Ys({expm1_:function(e){const t={x:qs(e,"x","expm1")};return zs.runKernel(vt,t)}}),gl=Ys({tile_:function(e,t){const n=qs(e,"x","tile","string_or_numeric");R(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);const r={x:n},s={reps:t};return zs.runKernel(mr,r,s)}}),bl=Ys({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const s=ci([e,t],r),a=e<=t?e:t;for(let e=0;e<a;++e)s.set(1,e,e);const i=au(s.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return gl(fl(i,0),[n[0],1,1]);if(2===n.length)return gl(fl(fl(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return gl(fl(fl(fl(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}),yl=Ys({floor_:function(e){const t={x:qs(e,"x","floor","float32")};return zs.runKernel(St,t)}}),xl=Ys({gather_:function(e,t,n=0,r=0){const s={x:qs(e,"x","gather"),indices:qs(t,"indices","gather","int32")},a={axis:n,batchDims:r};return zs.runKernel(Et,s,a)}}),wl=Ys({greater_:function(e,t){let n=qs(e,"a","greater","string_or_numeric"),r=qs(t,"b","greater","string_or_numeric");[n,r]=Cs(n,r),Li(n.shape,r.shape);const s={a:n,b:r};return zs.runKernel(At,s)}}),vl=Ys({greaterEqual_:function(e,t){let n=qs(e,"a","greaterEqual","string_or_numeric"),r=qs(t,"b","greaterEqual","string_or_numeric");[n,r]=Cs(n,r),Li(n.shape,r.shape);const s={a:n,b:r};return zs.runKernel(Ct,s)}}),_l=Ys({imag_:function(e){const t={input:qs(e,"input","imag")};return zs.runKernel(Dt,t)}}),kl=Ys({isFinite_:function(e){const t={x:qs(e,"x","isFinite")};return zs.runKernel(Ft,t)}}),Tl=Ys({isInf_:function(e){const t={x:qs(e,"x","isInf")};return zs.runKernel(Pt,t)}}),Sl=Ys({isNaN_:function(e){const t={x:qs(e,"x","isNaN")};return zs.runKernel(Mt,t)}}),Il=Ys({leakyRelu_:function(e,t=.2){const n={x:qs(e,"x","leakyRelu")},r={alpha:t};return zs.runKernel(Lt,n,r)}}),Nl=Ys({less_:function(e,t){let n=qs(e,"a","less","string_or_numeric"),r=qs(t,"b","less","string_or_numeric");[n,r]=Cs(n,r),Li(n.shape,r.shape);const s={a:n,b:r};return zs.runKernel(zt,s)}}),El=Ys({lessEqual_:function(e,t){let n=qs(e,"a","lessEqual","string_or_numeric"),r=qs(t,"b","lessEqual","string_or_numeric");[n,r]=Cs(n,r),Li(n.shape,r.shape);const s={a:n,b:r};return zs.runKernel(Bt,s)}});function $l(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return zs.runKernel(Ut,{},r)}const Al=Ys({localResponseNormalization_:function(e,t=5,n=1,r=1,s=.5){const a=qs(e,"x","localResponseNormalization");R(4===a.rank||3===a.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`),R(L(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=a,o=!1;3===a.rank&&(o=!0,i=au(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u={x:i},l={depthRadius:t,bias:n,alpha:r,beta:s},c=zs.runKernel(qt,u,l);return o?au(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),Cl=Ys({log_:function(e){const t={x:qs(e,"x","log","float32")};return zs.runKernel(Vt,t)}}),Ol=Ys({log1p_:function(e){const t={x:qs(e,"x","log1p")};return zs.runKernel(Wt,t)}}),Rl=Ys({neg_:function(e){const t={x:qs(e,"x","neg")};return zs.runKernel(cn,t)}}),Dl=Ys({softplus_:function(e){const t={x:qs(e,"x","softplus")};return zs.runKernel(Kn,t)}}),Fl=Ys({logSigmoid_:function(e){const t=qs(e,"x","logSigmoid");return vi(e=>({value:Rl(Dl(Rl(e))),gradFunc:t=>bi(t,cu(Rl(e)))}))(t)}}),Pl=Ys({logSoftmax_:function(e,t=-1){const n=qs(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const r=vi((e,n)=>{const r=ol(e,t,!0),s=Ri(e,r),a=Ri(hi(s,"float32"),Cl(ll(pl(s),t,!0)));return n([a]),{value:a,gradFunc:(e,n)=>{const[r]=n,s=pl(r);return Ri(e,bi(ll(e,t,!0),s))}}});return r(n)}}),Ml=Ys({logSumExp_:function(e,t=null,n=!1){const r=qs(e,"x","logSumExp"),s=W(t,r.shape),a=ol(r,s,!0),i=Ri(r,a),o=pl(i),u=ll(o,s),l=Cl(u),c=fi(au(a,l.shape),l);if(n){const e=nl(c.shape,s);return au(c,e)}return c}}),Ll=Ys({logicalAnd_:function(e,t){const n=qs(e,"a","logicalAnd","bool"),r=qs(t,"b","logicalAnd","bool");Li(n.shape,r.shape);const s={a:n,b:r};return zs.runKernel(jt,s)}}),zl=Ys({logicalNot_:function(e){const t={x:qs(e,"x","logicalNot","bool")};return zs.runKernel(Gt,t)}}),Bl=Ys({logicalOr_:function(e,t){const n=qs(e,"a","logicalOr","bool"),r=qs(t,"b","logicalOr","bool");Li(n.shape,r.shape);const s={a:n,b:r};return zs.runKernel(Ht,s)}}),Ul=Ys({logicalXor_:function(e,t){const n=qs(e,"a","logicalXor","bool"),r=qs(t,"b","logicalXor","bool");return Li(n.shape,r.shape),Ll(Bl(e,t),zl(Ll(e,t)))}}),Vl=2147483648,Wl=Ys({searchSorted_:function(e,t,n="left"){const r=qs(e,"sortedSequence","searchSorted"),s=qs(t,"values","searchSorted"),a=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],o=au(r,[-1,a]),u=au(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(P(u.shape)>=Vl)throw new Error("values tensor size must less than 2147483648");if(o.shape[1]>=Vl)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${o.shape[1]}`);const l={sortedSequence:o,values:u},c={side:n};return zs.runKernel(Bn,l,c)}});function jl(e,t){return Wl(e,t,"left")}const Gl=Ys({maxPool_:function(e,t,n,r,s){const a=qs(e,"x","maxPool");let i=a,o=!1;3===a.rank&&(o=!0,i=au(a,[1,a.shape[0],a.shape[1],a.shape[2]])),R(4===i.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),R(tu(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),su("maxPool",r,s);const u={x:i},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s},c=zs.runKernel(Zt,u,l);return o?au(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),Hl=Ys({maxPool3d_:function(e,t=[1,1,1],n,r,s,a="NDHWC"){const i=qs(e,"x","maxPool3d");let o=i,u=!1;4===i.rank&&(u=!0,o=au(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),R(5===o.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),R("NDHWC"===a,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),su("maxPool3d",r,s);const l={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},h=zs.runKernel(Qt,l,c);return u?au(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),ql=Ys({maxPoolWithArgmax_:function(e,t,n,r,s=!1){const a={x:qs(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},o=zs.runKernel(tn,a,i);return{result:o[0],indexes:o[1]}}}),Kl=Ys({mean_:function(e,t=null,n=!1){const r={x:qs(e,"x","mean")},s={axis:t,keepDims:n};return zs.runKernel(nn,r,s)}});function Xl(e,t="float32"){if(ie(e),"complex64"===t){const t=Xl(e,"float32"),n=Xl(e,"float32");return Zs(t,n)}const n=se(P(e),t);return zs.makeTensor(n,e,t)}function Yl(e,t="float32"){if(ie(e),"complex64"===t){const t=Yl(e,"float32"),n=Xl(e,"float32");return Zs(t,n)}const n=re(P(e),t);return zs.makeTensor(n,e,t)}function Zl(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=qs(e,"x","meshgrid",e instanceof ys?e.dtype:"float32");if(void 0===t)return[r];let s=qs(t,"y","meshgrid",t instanceof ys?t.dtype:"float32");const a=P(r.shape),i=P(s.shape);return"xy"===n?(r=au(r,[1,-1]),s=au(s,[-1,1]),[lu(Yl([i,1],r.dtype),r),lu(s,Yl([1,a],s.dtype))]):(r=au(r,[-1,1]),s=au(s,[1,-1]),[lu(r,Yl([1,i],r.dtype)),lu(Yl([a,1],s.dtype),s)])}const Jl=Ys({minimum_:function(e,t){let n=qs(e,"a","minimum"),r=qs(t,"b","minimum");[n,r]=Cs(n,r),"bool"===n.dtype&&(n=hi(n,"int32"),r=hi(r,"int32")),Li(n.shape,r.shape);const s={a:n,b:r};return zs.runKernel(sn,s)}}),Ql=Ys({mirrorPad_:function(e,t,n){R("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=qs(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");R(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s="reflect"===n?1:0;for(let e=0;e<r.rank;e++)R(2===t[e].length,()=>"Invalid number of paddings. Must be length of 2 each."),R(t[e][0]>=0&&t[e][0]<=r.shape[e]-s&&t[e][1]>=0&&t[e][1]<=r.shape[e]-s,()=>`Padding in dimension ${e} cannot be greater than or equal to ${r.shape[e]-s} or less than 0 for input of shape ${r.shape}`);const a={paddings:t,mode:n},i={x:r};return zs.runKernel(an,i,a)}}),ec=Ys({mod_:function(e,t){let n=qs(e,"a","mod"),r=qs(t,"b","mod");[n,r]=Cs(n,r);const s={a:n,b:r};return zs.runKernel(on,s)}}),tc=Ys({moments_:function(e,t=null,n=!1){const r=W(t,(e=qs(e,"x","moments")).shape),s=Kl(e,r,n);let a=s.shape;n||(a=nl(s.shape,r));const i=xi(Ri(hi(e,"float32"),au(s,a)));return{mean:s,variance:Kl(i,r,n)}}}),nc=Ys({multiRNNCell_:function(e,t,n,r){const s=qs(t,"data","multiRNNCell"),a=Ks(n,"c","multiRNNCell"),i=Ks(r,"h","multiRNNCell");let o=s;const u=[];for(let t=0;t<e.length;t++){const n=e[t](o,a[t],i[t]);u.push(n[0]),u.push(n[1]),o=n[1]}const l=[],c=[];for(let e=0;e<u.length;e+=2)l.push(u[e]),c.push(u[e+1]);return[l,c]}}),rc=Ys({multinomial_:function(e,t,n,r=!1){const s=qs(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const o={logits:1===i?au(s,[1,-1]):s},u={numSamples:t,seed:n,normalized:r},l=zs.runKernel(un,o,u);return 1===i?au(l,[l.size]):l}}),sc=Ys({notEqual_:function(e,t){let n=qs(e,"a","notEqual","string_or_numeric"),r=qs(t,"b","notEqual","string_or_numeric");[n,r]=Cs(n,r),Li(n.shape,r.shape);const s={a:n,b:r};return zs.runKernel(hn,s)}}),ac=Ys({oneHot_:function(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:qs(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return zs.runKernel(gn,a,i)}}),ic=Ys({onesLike_:function(e){const t={x:qs(e,"x","onesLike")};return zs.runKernel(mn,t)}}),oc=Ys({outerProduct_:function(e,t){const n=qs(e,"v1","outerProduct"),r=qs(t,"v2","outerProduct");R(1===n.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=au(n,[-1,1]),a=au(r,[1,-1]);return lu(s,a)}}),uc=Ys({pad_:function(e,t,n=0){const r=qs(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return zs.runKernel(yn,a,s)}}),lc=Ys({pad1d_:function(e,t,n=0){return R(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),uc(e,[t],n)}}),cc=Ys({pad2d_:function(e,t,n=0){return R(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),uc(e,t,n)}}),hc=Ys({pad3d_:function(e,t,n=0){return R(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),uc(e,t,n)}}),dc=Ys({pad4d_:function(e,t,n=0){return R(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),uc(e,t,n)}}),pc=Ys({spaceToBatchND_:function(e,t,n){const r=qs(e,"x","spaceToBatchND");R(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),R(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),R(r.shape.reduce((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]===0:e,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);const s={x:r},a={blockShape:t,paddings:n};return zs.runKernel(Zn,s,a)}}),fc=Ys({pool_:function(e,t,n,r,s,a,i){null==s&&(s=[1,1]),null==a&&(a=1),0===r&&(r="valid");const o=qs(e,"x","maxPool");let u=o,l=!1;3===o.rank&&(l=!0,u=au(o,[1,o.shape[0],o.shape[1],o.shape[2]])),R(tu(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);const c=Go(u.shape,t,a,s,r),h=[c.dilationHeight,c.dilationWidth];let d;d="same"===r?function(e,t){const n=e.map((e,n)=>e+(e-1)*(t[n]-1)).map(e=>e-1),r=n.map(e=>Math.floor(e/2)),s=n.map((e,t)=>e-r[t]);return n.map((e,t)=>[r[t],s[t]])}([c.filterHeight,c.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,m]=function(e,t,n){const r=n.map(e=>e[0]),s=n.map(e=>e[1]),a=e.concat(r,s),i=t.map((e,t)=>(e-a[t]%e)%e),o=s.map((e,t)=>e+i[t]);return[t.map((e,t)=>[r[t],o[t]]),t.map((e,t)=>[0,i[t]])]}([c.inHeight,c.inWidth],h,d),g=p?r:"valid",b=p?u:pc(u,h,f),y=("avg"===n?()=>iu(b,t,a,g,i):()=>Gl(b,t,a,g,i))(),x=p?y:fu(y,h,m);return l?au(x,[x.shape[1],x.shape[2],x.shape[3]]):x}}),mc=Ys({prelu_:function(e,t){const n={x:qs(e,"x","prelu"),alpha:qs(t,"alpha","prelu")};return zs.runKernel(wn,n)}}),gc=Ys({prod_:function(e,t=null,n=!1){let r=qs(e,"x","prod");"bool"===r.dtype&&(r=hi(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return zs.runKernel(vn,s,a)}}),bc=Ys({raggedGather_:function(e,t,n,r){const s={paramsNestedSplits:e.map((e,t)=>qs(e,`tensors${t}`,"raggedGather","int32")),paramsDenseValues:qs(t,"paramsDenseValues","raggedGather"),indices:qs(n,"indices","raggedGather","int32")},a={outputRaggedRank:r},i=zs.runKernel(_n,s,a);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}}),yc=Ys({raggedRange_:function(e,t,n){const r=qs(e,"starts","raggedRange"),s={starts:r,limits:qs(t,"limits","raggedRange",r.dtype),deltas:qs(n,"deltas","raggedRange",r.dtype)},a=zs.runKernel(kn,s);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}}),xc=Ys({raggedTensorToTensor_:function(e,t,n,r,s){const a=qs(e,"shape","raggedTensorToTensor","int32"),i=qs(t,"values","raggedTensorToTensor"),o={shape:a,values:i,defaultValue:qs(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map((e,t)=>qs(e,`tensors${t}`,"raggedTensorToTensor","int32"))},u={rowPartitionTypes:s};return zs.runKernel(Tn,o,u)}}),wc=Ys({rand_:function(e,t,n){ie(e);const r=P(e);let s=null;if(null==n||"float32"===n)s=new Float32Array(r);else if("int32"===n)s=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);s=new Uint8Array(r)}for(let e=0;e<r;e++)s[e]=t();return zs.makeTensor(s,e,n)}});var vc=__webpack_require__(391);class _c{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=vc.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class kc{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const s=r||Math.random();this.randu=vc.alea(s.toString()),this.randn=new _c(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do{r=this.randn.nextValue(),a=1+this.c*r}while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class Tc{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=vc.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Sc=Ys({randomGamma_:function(e,t,n=1,r="float32",s){if(ie(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const a=new kc(t,n,r,s),i=ci(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}}),Ic=Ys({randomNormal_:function(e,t=0,n=1,r,s){if(ie(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const a=new _c(t,n,r,!1,s),i=ci(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}}),Nc=Ys({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return Ic(e,0,1,t,n)}}),Ec=Ys({randomUniform_:function(e,t=0,n=1,r="float32",s){ie(e);const a=ci(e,r),i=new Tc(t,n,null,s);for(let e=0;e<a.values.length;e++)a.values[e]=i.nextValue();return a.toTensor()}}),$c=Ys({randomUniformInt_:function(e,t,n,r){return Ec(e,t,n,"int32",r)}});function Ac(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return zs.runKernel(Sn,{},s)}const Cc=Ys({real_:function(e){const t={input:qs(e,"input","real")};return zs.runKernel(In,t)}}),Oc=Ys({reciprocal_:function(e){const t={x:qs(e,"x","reciprocal")};return zs.runKernel(Nn,t)}}),Rc=Ys({relu_:function(e){const t={x:qs(e,"x","relu")};return zs.runKernel(En,t)}}),Dc=Ys({relu6_:function(e){const t={x:qs(e,"x","relu6")};return zs.runKernel(Dn,t)}}),Fc=Ys({reverse_:function(e,t){const n={x:qs(e,"x","reverse")},r={dims:t};return zs.runKernel(Fn,n,r)}}),Pc=Ys({reverse1d_:function(e){const t=qs(e,"x","reverse");return R(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Fc(t,0)}}),Mc=Ys({reverse2d_:function(e,t){const n=qs(e,"x","reverse");return R(2===n.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Fc(n,t)}}),Lc=Ys({reverse3d_:function(e,t){const n=qs(e,"x","reverse");return R(3===n.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Fc(n,t)}}),zc=Ys({reverse4d_:function(e,t){const n=qs(e,"x","reverse");return R(4===n.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Fc(n,t)}}),Bc=Ys({round_:function(e){const t={x:qs(e,"x","round")};return zs.runKernel(Pn,t)}}),Uc=Ys({rsqrt_:function(e){const t={x:qs(e,"x","rsqrt","float32")};return zs.runKernel(Mn,t)}}),Vc=Ys({selu_:function(e){const t={x:qs(e,"x","selu")};return zs.runKernel(Vn,t)}}),Wc=Ys({separableConv2d_:function(e,t,n,r,s,a=[1,1],i="NHWC"){const o=qs(e,"x","separableConv2d"),u=qs(t,"depthwiseFilter","separableConv2d"),l=qs(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=au(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");R(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),R(4===u.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),R(4===l.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),R(1===l.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),R(1===l.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const d=u.shape[2],p=u.shape[3];R(l.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${l.shape[2]}.`);const f=Vu(c,u,r,s,i,a),m=$u(f,l,1,"valid",i);return h?au(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),jc=async function(e,t){const n=qs(e,"x","setdiff1d"),r=qs(t,"y","setdiff1d");R(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),R(1===n.rank,()=>`x should be 1D tensor, but got x (${n.shape}).`),R(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await n.data(),a=await r.data(),i=new Set(a);let o=0;for(let e=0;e<s.length;e++)i.has(s[e])||o++;const u=new fs([o],n.dtype),l=new fs([o],"int32");for(let e=0,t=0;e<s.length;e++)i.has(s[e])||(u.values[t]=s[e],l.values[t]=e,t++);return[u.toTensor(),l.toTensor()]},Gc=Ys({sign_:function(e){const t={x:qs(e,"x","sign")};return zs.runKernel(Hn,t)}}),Hc=Ys({sin_:function(e){const t={x:qs(e,"x","sin","float32")};return zs.runKernel(jn,t)}}),qc=Ys({sinh_:function(e){const t={x:qs(e,"x","sinh")};return zs.runKernel(Gn,t)}}),Kc=Ys({slice1d_:function(e,t,n){const r=qs(e,"x","slice1d");return R(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),hu(r,[t],[n])}}),Xc=Ys({slice2d_:function(e,t,n){const r=qs(e,"x","slice2d");return R(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),hu(r,t,n)}}),Yc=Ys({slice3d_:function(e,t,n){const r=qs(e,"x","slice3d");return R(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),hu(r,t,n)}}),Zc=Ys({slice4d_:function(e,t,n){const r=qs(e,"x","slice4d");return R(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),hu(r,t,n)}}),Jc=Ys({softmax_:function(e,t=-1){const n=qs(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return zs.runKernel(Qn,r,s)}}),Qc=Ys({fft_:function(e){R("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);const t={input:e};return zs.runKernel(_t,t)}}),eh=Ys({ifft_:function(e){R("complex64"===e.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);const t={input:e};return zs.runKernel(Rt,t)}}),th=Ys({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=au(e,[n,t]);r=eh(s)}else{const s=[n,2*(t-1)],a=au(Cc(e),[n,t]),i=au(_l(e),[n,t]),o=Fc(hu(a,[0,1],[n,t-2]),1),u=bi(Fc(hu(i,[0,1],[n,t-2]),1),_i(-1)),l=uu([a,o],1),c=uu([i,u],1),h=au(Zs(l,c),[s[0],s[1]]);r=eh(h)}if(r=Cc(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=au(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}}),nh=Ys({split_:function(e,t,n=0){const r={x:qs(e,"x","split")},s={numOrSizeSplits:t,axis:n};return zs.runKernel(Jn,r,s)}}),rh=Ys({rfft_:function(e,t){R("float32"===e.dtype,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map(e=>0),a=e.shape.map(e=>e);a[e.shape.length-1]=t,s=hu(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map(e=>e);r[e.shape.length-1]=t-n,s=uu([e,Xl(r)],e.shape.length-1),n=t}else s=e;const a=wi(s),i=au(Zs(s,a),[r,n]),o=Qc(i),u=Math.floor(n/2)+1,l=Cc(o),c=_l(o),h=nh(l,[u,n-u],l.shape.length-1),d=nh(c,[u,n-u],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=u,au(Zs(h[0],d[0]),p)}}),sh=Ys({squaredDifference_:function(e,t){let n=qs(e,"a","squaredDifference"),r=qs(t,"b","squaredDifference");[n,r]=Cs(n,r),Li(n.shape,r.shape);const s={a:n,b:r};return zs.runKernel(ar,s,{})}}),ah=Ys({squeeze_:function(e,t){const n=qs(e,"x","squeeze","string_or_numeric");return au(n,j(n.shape,t).newShape)}}),ih=Ys({stack_:function(e,t=0){const n=Ks(e,"tensors","stack","string_or_numeric");R(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&R(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:t};return zs.runKernel(bn,r,s)}}),oh=Ys({step_:function(e,t=0){const n={x:qs(e,"x","step")},r={alpha:t};return zs.runKernel(kr,n,r)}}),uh=Ys({stridedSlice_:function(e,t,n,r,s=0,a=0,i=0,o=0,u=0){const l={x:qs(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};return zs.runKernel(ur,l,c)}}),lh=Ys({tan_:function(e){const t={x:qs(e,"x","tan","float32")};return zs.runKernel(pr,t)}});function ch(e,t){F(e);const n=js(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Js(e,null,n,t)}function hh(e,t,n){if(F(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=js(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Js(e,t,r,n)}function dh(e,t,n){if(F(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=js(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Js(e,t,r,n)}function ph(e,t,n){if(F(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=js(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Js(e,t,r,n)}function fh(e,t,n){if(F(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=js(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Js(e,t=t||r,r,n)}function mh(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+" update.rank != "+(s+e.length-r));for(let e=0;e<s;++e)if(n.shape[e]!==t.shape[e])throw new Error(a+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-s;++t)if(n.shape[t+s]!==e[t+r])throw new Error(a+` updates.shape[${t+s}] (${n.shape[t+s]}) != shape[${t+s}] (${e[t+s]})`)}function gh(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}mh(n,t,e)}function bh(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let e=s;e<a;++e)i*=n[e];const o=s<1?1:s;return{sliceRank:s,numUpdates:P(t.shape)/o,sliceSize:i,strides:[...ee(n.slice(0,s)),1],outputSize:P(n)}}const yh=Ys({tensorScatterUpdate_:function(e,t,n){const r=qs(e,"tensor","tensorScatterupdate"),s=qs(t,"indices","tensorScatterupdate","int32"),a=qs(n,"updates","tensorScatterupdate");if(gh(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);const i={tensor:r,indices:s,updates:a};return zs.runKernel(zn,i,{})}}),xh=Ys({topk_:function(e,t=1,n=!0){const r=qs(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,u]=zs.runKernel(gr,a,i);return{values:o,indices:u}}}),wh=Ys({truncatedNormal_:function(e,t=0,n=1,r,s){if(ie(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const a=new _c(t,n,r,!0,s),i=ci(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}}),vh=Ys({unique_:function(e,t=0){const n=qs(e,"x","unique","string_or_numeric");R(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:t},[a,i]=zs.runKernel(xr,r,s);return{values:a,indices:i}}}),_h=Ys({unsortedSegmentSum_:function(e,t,n){const r=qs(e,"x","unsortedSegmentSum"),s=qs(t,"segmentIds","unsortedSegmentSum","int32");R(L(n),()=>"numSegments must be of dtype int");const a={x:r,segmentIds:s},i={numSegments:n};return zs.runKernel(vr,a,i)}}),kh=Ys({unstack_:function(e,t=0){const n=qs(e,"x","unstack","string_or_numeric");R(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:t};return zs.runKernel(wr,r,s)}});function Th(e,t){return Wl(e,t,"right")}function Sh(e,t=!0,n,r){return zs.makeVariable(e,t,n,r)}function Ih(e,t){const n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);const r=ci(e,"int32"),s=ci([n.length,e.length],"int32");for(let t=0;t<n.length;t++){const a=r.indexToLoc(n[t]),i=t*e.length;s.values.set(a,i)}return s.toTensor()}const Nh=async function(e){const t=qs(e,"condition","whereAsync","bool"),n=await t.data(),r=Ih(t.shape,n);return e!==t&&t.dispose(),r},Eh=async function(e,t,n){const r=qs(e,"tensor","boolMask"),s=qs(t,"mask","boolMask","bool"),a=null==n?0:n,i=s.rank,o=r.shape;R(i>0,()=>"mask cannot be scalar"),D(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let e=a;e<a+i;e++)u*=o[e];const l=o.slice(0,a).concat([u],o.slice(a+i)),c=au(r,l),h=au(s,[-1]),d=await Nh(h),p=ah(d,[1]),f=xl(c,p,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),p.dispose(),c.dispose(),h.dispose(),d.dispose(),f},$h=Ys({transpose_:function(e,t,n){const r=qs(e,"x","transpose");if(null==t&&(t=r.shape.map((e,t)=>t).reverse()),R(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(e=>{R(e>=0&&e<r.rank,()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${t}`)}),r.rank<=1)return r.clone();const s={x:r},a={perm:t};return"complex64"===r.dtype?sa(()=>{let e=Cc(r),t=_l(r);return e=zs.runKernel(yr,{x:e},a),t=zs.runKernel(yr,{x:t},a),n&&(t=Rl(t)),Zs(e,t)}):zs.runKernel(yr,s,a)}}),Ah=Ys({movingAverage_:function(e,t,n,r,s=!0){const a=qs(e,"v","movingAverage"),i=qs(t,"x","movingAverage"),o=qs(n,"decay","movingAverage");var u,l;l=i,R((u=a).dtype===l.dtype,()=>`The dtypes of the first(${u.dtype}) and second(${l.dtype}) input must match`),R(M(a.shape,i.shape),()=>"Shape mismatch in v and x");const c=_i(1),h=Ri(c,o);let d=bi(Ri(i,a),h);if(s){R(null!=r,()=>"When using zeroDebias: true, step is required.");const e=qs(r,"step","movingAverage");d=gi(d,Ri(c,Oi(o,e)))}return fi(a,d)}}),Ch=Ys({scatterND_:function(e,t,n){ie(n);const r=qs(e,"indices","scatterND","int32"),s=qs(t,"updates","scatterND");gh(s,r,n);const a={indices:r,updates:s},i={shape:n};return zs.runKernel(Ln,a,i)}}),Oh=Ys({sparseToDense_:function(e,t,n,r=0){ie(n);const s=qs(e,"sparseIndices","sparseToDense","int32"),a=qs(t,"sparseValues","sparseToDense","string_or_numeric"),i=qs(r,"defaultValue","sparseToDense",a.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,a,n,i);const o={sparseIndices:s,sparseValues:a,defaultValue:i},u={outputShape:n};return zs.runKernel(sr,o,u)}}),Rh=Ys({gatherND_:function(e,t){const n=qs(t,"indices","gatherND","int32"),r={params:qs(e,"x","gatherND","string_or_numeric"),indices:n};return zs.runKernel($t,r)}}),Dh=Ys({dropout_:function(e,t,n,r){const s=qs(e,"x","dropout");if(R("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),R(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return e instanceof ys?s.clone():s;const a=function(e,t){if(null==t)return e.shape.slice();if(M(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(s,n),i=1-t,o=gi(yl(fi(Ec(a,0,1,"float32",r),i)),i);return bi(s,o)}});function Fh(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Ph(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){const i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return ch(s,"float32")}const Mh=async function(e,t,n=1){const r=qs(e,"predictions","inTopK"),s=qs(t,"targets","inTopK");R(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),R(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),D(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];R(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);const i=await r.data(),o=await s.data(),[u,l]=[i.length/a,a],c=G("bool",u);for(let e=0;e<u;e++){const t=e*l,r=i.subarray(t,t+l),s=[];for(let e=0;e<r.length;e++)s.push({value:r[e],index:e});s.sort((e,t)=>t.value-e.value),c[e]=0;for(let t=0;t<n;t++)if(s[t].index===o[e]){c[e]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),Qs(c,s.shape,"bool")},Lh=Ys({conv2DBackpropFilter_:function(e,t,n,r,s,a="NHWC",i){let o=e;3===e.rank&&(o=au(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=au(t,[1,t.shape[0],t.shape[1],t.shape[2]])),R(4===o.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),R(4===u.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),R(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const l="NHWC"===a?o.shape[3]:o.shape[1],c="NHWC"===a?u.shape[3]:u.shape[1];R(l===n[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`),R(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),su("conv2dDerFilter",s,i);const h={x:o,dy:u},d={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return zs.runKernel(Ke,h,d)}});function zh(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return bi(e,oh(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Bh(e,t){let n=t;const r=Mi(e.shape,t.shape);return r.length>0&&(n=ll(n,r)),au(n,e.shape)}function Uh(e,t,n,r){if("linear"===t)return e;if("relu"===t)return Rc(e);if("elu"===t)return Yu(e);if("relu6"===t)return Dc(e);if("prelu"===t)return mc(e,n);if("leakyrelu"===t)return Il(e,r);if("sigmoid"===t)return cu(e);throw new Error(`Unknown fused activation ${t}.`)}const Vh=(e,t)=>!(e>0)||"linear"===t,Wh=Ys({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",!1===Vh(zs.state.gradientDepth,u)){R("NHWC"===s,()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let h=$u(e,t,n,r,s,a,i);return null!=o&&(h=fi(h,o)),Uh(h,u,l,c)}const h=qs(e,"x","conv2d","float32"),d=qs(t,"filter","conv2d","float32");let p=h,f=!1;3===h.rank&&(f=!0,p=au(h,[1,h.shape[0],h.shape[1],h.shape[2]])),R(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),R(4===d.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),su("fused conv2d",r,i);const m="NHWC"===s?p.shape[3]:p.shape[1];R(d.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`),R(tu(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const g=qo(p.shape,d.shape,n,a,r,i);let b,y;if(null!=o&&(b=qs(o,"bias","fused conv2d"),[b]=Cs(b,h),"NHWC"===s?Li(g.outShape,b.shape):(R(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),R(0===b.shape.length||b.shape[0]===g.outChannels||1===b.shape[0],()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${g.outChannels})`))),null!=l){const e=l.shape;if(R(e.length<=1||3===e.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`),1===e.length)R(1===e[0]||e[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${g.outChannels}).`);else if(3===e.length)try{Li(e,g.outShape)}catch(t){const n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(n)}y=qs(l,"prelu weights","fused conv2d")}const x=(e,t)=>{R("NHWC"===s,()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[i,o,l,c]=t,h=zh(e,l,u);R(eu(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const d=[Cu(o.shape,h,i,n,r),Lh(o,h,i.shape,n,r)];if(null!=c){const e=Bh(c,h);d.push(e)}return d},w={x:p,filter:d,bias:b,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:u,leakyreluAlpha:c};if(null==o){const e=vi((e,t,n)=>{let r=zs.runKernel(Ir,w,v);return n([t,e,r]),f&&(r=au(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}});return e(p,d)}{const e=vi((e,t,n,r)=>{let s=zs.runKernel(Ir,w,v);return r([t,e,s,n]),f&&(s=au(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:x}});return e(p,d,b)}}}),jh=Ys({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,s,a=[1,1],i){let o=e;3===e.rank&&(o=au(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=au(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:o,dy:u},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return zs.runKernel(ot,l,c)}}),Gh=Ys({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,s,a=[1,1],i){let o=t,u=!1;3===t.rank&&(u=!0,o=au(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},h=zs.runKernel(ut,l,c);return u?au(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Hh=Ys({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(!1===Vh(zs.state.gradientDepth,u)){let h=Vu(e,t,n,r,s,a,i);return null!=o&&(h=fi(h,o)),Uh(h,u,l,c)}const h=qs(e,"x","depthwiseConv2d","float32"),d=qs(t,"filter","depthwiseConv2d","float32");let p=h,f=!1;3===h.rank&&(f=!0,p=au(h,[1,h.shape[0],h.shape[1],h.shape[2]])),R(4===p.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),R(4===d.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),R(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),null==a&&(a=[1,1]),R(tu(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),su("fused depthwiseConv2d",r,i);const m=qo(p.shape,d.shape,n,a,r,i,!0);let g,b;null!=o&&(g=qs(o,"bias","fused conv2d"),[g]=Cs(g,h),Li(m.outShape,g.shape)),null!=l&&(b=qs(l,"prelu weights","fused depthwiseConv2d"));const y=(e,t)=>{R(eu(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[s,o,l,c]=t,h=zh(e,l,u),d=Gh(o.shape,h,s,n,r,a,i),p=jh(o,h,s.shape,n,r,a,i);return null!=c?[d,p,Bh(g,h)]:[d,p]},x={x:p,filter:d,bias:g,preluActivationWeights:b},w={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:u,leakyreluAlpha:c};if(null==o){const e=vi((e,t,n)=>{let r=zs.runKernel(Nr,x,w);return n([t,e,r]),f&&(r=au(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}});return e(p,d)}{const e=vi((e,t,n,r)=>{let s=zs.runKernel(Nr,x,w);return r([t,e,s,n]),f&&(s=au(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:y}});return e(p,d,g)}}}),qh=Ys({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(!1===Vh(zs.state.gradientDepth,a)){let u=lu(e,t,n,r);return null!=s&&(u=fi(u,s)),Uh(u,a,i,o)}let u=qs(e,"a","fused matMul"),l=qs(t,"b","fused matMul");[u,l]=Cs(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1],h=r?l.shape[l.rank-1]:l.shape[l.rank-2],d=n?u.shape[u.rank-1]:u.shape[u.rank-2],p=r?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),m=l.shape.slice(0,-2),g=P(f),b=P(m);R(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`);const y=Li(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([d,p]),x=au(u,n?[g,c,d]:[g,d,c]),w=au(l,r?[b,p,h]:[b,h,p]);let v,_;null!=s&&(v=qs(s,"bias","fused matMul"),[v]=Cs(v,u),Li(y,v.shape)),null!=i&&(_=qs(i,"prelu weights","fused matMul"));const k=(e,t)=>{const[i,o,u,l]=t,c=zh(au(e,u.shape),u,a);let h,d;return n||r?!n&&r?(h=lu(c,o,!1,!1),d=lu(c,i,!0,!1)):n&&!r?(h=lu(o,c,!1,!0),d=lu(i,c,!1,!1)):(h=lu(o,c,!0,!0),d=lu(c,i,!0,!0)):(h=lu(c,o,!1,!0),d=lu(i,c,!0,!1)),null!=s?[h,d,Bh(l,c)]:[h,d]},T={a:x,b:w,bias:v,preluActivationWeights:_},S={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};if(null==s){const e=vi((e,t,n)=>{const r=zs.runKernel(Sr,T,S);return n([e,t,r]),{value:au(r,y),gradFunc:k}});return e(x,w)}{const e=vi((e,t,n,r)=>{const s=zs.runKernel(Sr,T,S);return r([e,t,s,n]),{value:au(s,y),gradFunc:k}});return e(x,w,v)}}}),Kh=Ys({hammingWindow_:function(e){return Ph(e,.54,.46)}}),Xh=Ys({hannWindow_:function(e){return Ph(e,.5,.5)}}),Yh=Ys({frame_:function(e,t,n,r=!1,s=0){let a=0;const i=[];for(;a+t<=e.size;)i.push(hu(e,a,t)),a+=n;if(r)for(;a<e.size;){const r=a+t-e.size,o=uu([hu(e,a,t-r),Ai([r],s)]);i.push(o),a+=n}return 0===i.length?hh([],[0,t]):au(uu(i),[i.length,t])}}),Zh=Ys({stft_:function(e,t,n,r,s=Xh){null==r&&(r=Fh(t));const a=Yh(e,t,n),i=bi(a,s(t));return rh(i,r)}}),Jh=Ys({cropAndResize_:function(e,t,n,r,s="bilinear",a=0){const i=qs(e,"image","cropAndResize"),o=qs(t,"boxes","cropAndResize","float32"),u=qs(n,"boxInd","cropAndResize","int32"),l=o.shape[0];R(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),R(2===o.rank&&4===o.shape[1],()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${o.shape}.`),R(1===u.rank&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${o.shape}.`),R(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),R(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),R("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`);const c={image:i,boxes:o,boxInd:u},h={method:s,extrapolationValue:a,cropSize:r};return zs.runKernel(rt,c,h)}}),Qh=Ys({flipLeftRight_:function(e){const t=qs(e,"image","flipLeftRight","float32");R(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const n={image:t};return zs.runKernel(Tt,n,{})}}),ed=Ys({grayscaleToRGB_:function(e){const t=qs(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];R(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),R(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,gl(t,s)}}),td=Ys({rgbToGrayscale_:function(e){const t=qs(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];R(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),R(3===r,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=t.dtype,a=hi(t,"float32"),i=ch([.2989,.587,.114]);let o;switch(t.rank){case 2:o=Xu("ij,j->i",a,i);break;case 3:o=Xu("ijk,k->ij",a,i);break;case 4:o=Xu("ijkl,l->ijk",a,i);break;case 5:o=Xu("ijklm,m->ijkl",a,i);break;case 6:o=Xu("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=fl(o,-1),hi(o,s)}}),nd=Ys({rotateWithOffset_:function(e,t,n=0,r=.5){const s=qs(e,"image","rotateWithOffset","float32");R(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const a={image:s},i={radians:t,fillValue:n,center:r};return zs.runKernel(Tr,a,i)}});function rd(e,t,n,r,s,a){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==a&&(a=0);const i=e.shape[0];return n=Math.min(n,i),R(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),R(2===e.rank,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),R(4===e.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),R(1===t.rank,()=>"scores must be a 1D tensor"),R(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),R(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}const sd=Ys({nonMaxSuppression_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=qs(e,"boxes","nonMaxSuppression","float32"),i=qs(t,"scores","nonMaxSuppression","float32"),o=rd(a,i,n,r,s),u={maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:s=o.scoreThreshold};return zs.runKernel(dn,{boxes:a,scores:i},u)}});function ad(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}(e,t,n||id)}(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function id(e,t){return e>t?1:e<t?-1:0}function od(e,t,n,r,s){return cd(e,t,n,r,s,0)}function ud(e,t,n,r,s,a){return cd(e,t,n,r,s,0,!1,a,!0)}function ld(e,t,n,r,s,a){return cd(e,t,n,r,s,a,!0)}function cd(e,t,n,r,s,a,i=!1,o=!1,u=!1){const l=[];for(let e=0;e<t.length;e++)t[e]>s&&l.push({score:t[e],boxIndex:e,suppressBeginIndex:0});l.sort(pd);const c=a>0?-.5/a:0,h=[],d=[];for(;h.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:a,suppressBeginIndex:i}=t;if(n<s)break;let o=!1;for(let n=h.length-1;n>=i;--n){const i=hd(e,a,h[n]);if(i>=r){o=!0;break}if(t.score=t.score*dd(r,c,i),t.score<=s)break}t.suppressBeginIndex=h.length,o||(t.score===n?(h.push(a),d.push(t.score)):t.score>s&&ad(l,t,pd))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return i&&(m.selectedScores=d),u&&(m.validOutputs=p),m}function hd(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(o-a)*(u-i),f=(h-l)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(a,l),g=Math.max(i,c),b=Math.min(o,h),y=Math.min(u,d),x=Math.max(b-m,0)*Math.max(y-g,0);return x/(p+f-x)}function dd(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function pd(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const fd=Ys({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=qs(e,"boxes","nonMaxSuppression"),o=qs(t,"scores","nonMaxSuppression"),u=rd(i,o,n,r,s,a),l={boxes:i,scores:o},c={maxOutputSize:n=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:s=u.scoreThreshold,softNmsSigma:a=u.softNmsSigma},h=zs.runKernel(fn,l,c);return{selectedIndices:h[0],selectedScores:h[1]}}}),md=Ys({nonMaxSuppressionPadded_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=qs(e,"boxes","nonMaxSuppression"),o=qs(t,"scores","nonMaxSuppression"),u=rd(i,o,n,r,s,null),l={boxes:i,scores:o},c={maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:a},h=zs.runKernel(pn,l,c);return{selectedIndices:h[0],validOutputs:h[1]}}}),gd=Ys({resizeBilinear_:function(e,t,n=!1,r=!1){const s=qs(e,"images","resizeBilinear");R(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),R(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),R(!1===r||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;3===s.rank&&(i=!0,a=au(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},l=zs.runKernel(On,o,u);return i?au(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),bd=Ys({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){const s=qs(e,"images","resizeNearestNeighbor");R(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),R(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),R("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),R(!1===r||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;3===s.rank&&(i=!0,a=au(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},l=zs.runKernel(An,o,u);return i?au(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),yd=Ys({threshold_:function(e,t="binary",n=!1,r=.5){const s=qs(e,"image","threshold"),a=s.shape[0]*s.shape[1];let i,o,u,l,c=bi(ch([r]),255);if(R(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),R(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),R("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),R("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===s.shape[2]){[i,o,u]=nh(s,[1,1,1],-1);const e=bi(i,.2989),t=bi(o,.587),n=bi(u,.114);l=fi(fi(e,t),n)}else l=e;"otsu"===t&&(c=function(e,t){let n,r,s,a,i,o,u=ch([-1]),l=ch([0]),c=ch([0]);for(let h=0;h<e.size-1;h++){n=hu(e,0,h+1),r=hu(e,h+1),i=gi(ll(n),t),o=gi(ll(r),t);const d=ll(bi(n,Ac(0,n.size)));s=gi(d,ll(n));const p=Ai(r.shape,n.size),f=fi(Ac(0,r.size),p),m=bi(r,f);a=gi(ll(m),ll(r));const g=Ri(s,a),b=Ri(s,a),y=bi(i,o);c=bi(bi(y,g),b);const x=wl(c,l);l=Hu(x,c,l),u=Hu(x,ch([h]),u)}return u}(xu(hi(Bc(l),"int32"),Qs([]),256),a));const h=n?El(l,c):wl(l,c);return hi(bi(h,255),"int32")}}),xd=Ys({transform_:function(e,t,n="nearest",r="constant",s=0,a){const i=qs(e,"image","transform","float32"),o=qs(t,"transforms","transform","float32");R(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),R(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),R(null==a||2===a.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const u={image:i,transforms:o},l={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return zs.runKernel(br,u,l)}}),wd=Ys({bandPart_:function(e,t,n){const r=qs(e,"a","bandPart");R(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[a,i]=r.shape.slice(-2);let o,u;"number"==typeof t?(R(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),R(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),o=qs(t<0?a:t,"numLower","bandPart")):(R("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),o=Hu(Nl(t,0),a,Jl(t,a))),"number"==typeof n?(R(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),R(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),u=qs(n<0?i:n,"numUpper","bandPart")):(R("int32"===n.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),u=Hu(Nl(n,0),i,Jl(n,i)));const l=au(Ac(0,a,1,"int32"),[-1,1]),c=Ac(0,i,1,"int32"),h=Ri(l,c),d=Ll(El(h,o),vl(h,Rl(u))),p=Xl([a,i],r.dtype);return au(ih(kh(au(r,[-1,a,i])).map(e=>Hu(d,e,p))),s)}}),vd=Ys({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,R(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=e[0].shape[0];for(let t=1;t<e.length;++t)R(e[t].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`)}else t=!0,e=nh(e,e.shape[0],0).map(e=>ah(e,[0]));R(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],r=e;for(let t=0;t<e.length;++t)n.push(zs.tidy(()=>{let e=r[t];if(t>0)for(let r=0;r<t;++r){const t=bi(ll(bi(n[r],e)),n[r]);e=Ri(e,t)}return gi(e,hl(e,"euclidean"))}));return t?ih(n,0):n}});function _d(e,t=!1){return zs.tidy(()=>{R(2===e.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],r=e.shape[1];let s=bl(n),a=di(e);const i=hh([[1]],[1,1]);let o=di(i);const u=n>=r?r:n;for(let e=0;e<u;++e){const t=a,u=o,l=s;[o,a,s]=zs.tidy(()=>{const t=hu(a,[e,e],[n-e,1]),u=hl(t),l=hu(a,[e,e],[1,1]),c=Hu(wl(l,0),hh([[-1]]),hh([[1]])),h=Ri(l,bi(c,u)),d=gi(t,h);o=1===d.shape[0]?di(i):uu([i,hu(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=Rl(gi(lu(c,h),u)),f=hu(a,[e,0],[n-e,r]),m=bi(p,o),g=$h(o);if(0===e)a=Ri(f,lu(m,lu(g,f)));else{const t=Ri(f,lu(m,lu(g,f)));a=uu([hu(a,[0,0],[e,r]),t],0)}const b=$h(m),y=hu(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=Ri(y,lu(lu(y,o),b));else{const t=Ri(y,lu(lu(y,o),b));s=uu([hu(s,[0,0],[n,e]),t],1)}return[o,a,s]}),aa([t,u,l])}return!t&&n>r&&(s=hu(s,[0,0],[n,r]),a=hu(a,[0,0],[r,r])),[s,a]})}const kd=Ys({qr_:function(e,t=!1){if(R(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),2===e.rank)return _d(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),r=kh(au(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];return r.forEach(e=>{const[n,r]=_d(e,t);s.push(n),a.push(r)}),[au(ih(s,0),e.shape),au(ih(a,0),e.shape)]}}});var Td;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Td||(Td={}));const Sd=Ys({computeWeightedLoss_:function(e,t,n=Td.SUM_BY_NONZERO_WEIGHTS){const r=qs(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=qs(t,"weights","computeWeightedLoss"));const a=null==s?r:bi(r,s);if(n===Td.NONE)return a;if(n===Td.SUM)return ll(a);if(n===Td.MEAN){if(null==s)return Kl(a);{const e=r.size/s.size,t=gi(ll(a),ll(s));return e>1?gi(t,_i(e)):t}}if(n===Td.SUM_BY_NONZERO_WEIGHTS){if(null==s)return gi(ll(a),_i(r.size));{const e=bi(s,Yl(r.shape)),t=hi(ll(sc(e,_i(0))),"float32");return gi(ll(a),t)}}throw Error(`Unknown reduction: ${n}`)}}),Id=Ys({absoluteDifference_:function(e,t,n,r=Td.SUM_BY_NONZERO_WEIGHTS){const s=qs(e,"labels","absoluteDifference"),a=qs(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=qs(n,"weights","absoluteDifference")),D(s.shape,a.shape,"Error in absoluteDifference: ");const o=Fi(Ri(s,a));return Sd(o,i,r)}}),Nd=Ys({cosineDistance_:function(e,t,n,r,s=Td.SUM_BY_NONZERO_WEIGHTS){const a=qs(e,"labels","cosineDistance"),i=qs(t,"predictions","cosineDistance");let o=null;null!=r&&(o=qs(r,"weights","cosineDistance")),D(a.shape,i.shape,"Error in cosineDistance: ");const u=_i(1),l=Ri(u,ll(bi(a,i),n,!0));return Sd(l,o,s)}}),Ed=Ys({hingeLoss_:function(e,t,n,r=Td.SUM_BY_NONZERO_WEIGHTS){let s=qs(e,"labels","hingeLoss");const a=qs(t,"predictions","hingeLoss");let i=null;null!=n&&(i=qs(n,"weights","hingeLoss")),D(s.shape,a.shape,"Error in hingeLoss: ");const o=_i(1);s=Ri(bi(_i(2),s),o);const u=Rc(Ri(o,bi(s,a)));return Sd(u,i,r)}}),$d=Ys({huberLoss_:function(e,t,n,r=1,s=Td.SUM_BY_NONZERO_WEIGHTS){const a=qs(e,"labels","huberLoss"),i=qs(t,"predictions","huberLoss");let o=null;null!=n&&(o=qs(n,"weights","huberLoss")),D(a.shape,i.shape,"Error in huberLoss: ");const u=_i(r),l=Fi(Ri(i,a)),c=Jl(l,u),h=Ri(l,c),d=fi(bi(_i(.5),xi(c)),bi(u,h));return Sd(d,o,s)}}),Ad=Ys({logLoss_:function(e,t,n,r=1e-7,s=Td.SUM_BY_NONZERO_WEIGHTS){const a=qs(e,"labels","logLoss"),i=qs(t,"predictions","logLoss");let o=null;null!=n&&(o=qs(n,"weights","logLoss")),D(a.shape,i.shape,"Error in logLoss: ");const u=_i(1),l=_i(r),c=Rl(bi(a,Cl(fi(i,l)))),h=bi(Ri(u,a),Cl(fi(Ri(u,i),l))),d=Ri(c,h);return Sd(d,o,s)}}),Cd=Ys({meanSquaredError_:function(e,t,n,r=Td.SUM_BY_NONZERO_WEIGHTS){const s=qs(e,"labels","meanSquaredError"),a=qs(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=qs(n,"weights","meanSquaredError")),D(s.shape,a.shape,"Error in meanSquaredError: ");const o=sh(s,a);return Sd(o,i,r)}}),Od=Ys({sigmoidCrossEntropy_:function(e,t,n,r=0,s=Td.SUM_BY_NONZERO_WEIGHTS){let a=qs(e,"multiClassLabels","sigmoidCrossEntropy");const i=qs(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=qs(n,"weights","sigmoidCrossEntropy")),D(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=_i(r),t=_i(1),n=_i(.5);a=fi(bi(a,Ri(t,e)),bi(n,e))}const u=function(e,t){const n=qs(e,"labels","sigmoidCrossEntropyWithLogits"),r=qs(t,"logits","sigmoidCrossEntropyWithLogits");D(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Rc(r),a=bi(r,n),i=Ol(pl(Rl(Fi(r))));return fi(Ri(s,a),i)}(a,i);return Sd(u,o,s)}}),Rd=Ys({softmaxCrossEntropy_:function(e,t,n,r=0,s=Td.SUM_BY_NONZERO_WEIGHTS){let a=qs(e,"onehotLabels","softmaxCrossEntropy");const i=qs(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=qs(n,"weights","softmaxCrossEntropy")),D(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=_i(r),t=_i(1),n=_i(a.shape[1]);a=fi(bi(a,Ri(t,e)),gi(e,n))}const u=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=vi((e,t,r)=>{const s=Ml(t,[n],!0),a=Ri(hi(t,"float32"),s);r([e,a]);const i=Rl(bi(a,e));return{value:ll(i,[n]),gradFunc:(e,t)=>{const[r,s]=t,a=nl(e.shape,[n]);return[bi(au(e,a),Ri(hi(r,"float32"),pl(s))),bi(au(e,a),Ri(pl(s),hi(r,"float32")))]}}});return r(e,t)}(a,i);return Sd(u,o,s)}}),Dd=Ys({sparseFillEmptyRows_:function(e,t,n,r){const s=qs(e,"indices","sparseFillEmptyRows","int32"),a=qs(t,"values","sparseFillEmptyRows"),i=qs(n,"denseShape","sparseFillEmptyRows","int32"),o=qs(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==a.rank)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const u={indices:s,values:a,denseShape:i,defaultValue:o},l=zs.runKernel(er,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}}),Fd=Ys({sparseReshape_:function(e,t,n){const r=qs(e,"inputIndices","sparseReshape","int32"),s=qs(t,"inputShape","sparseReshape","int32"),a=qs(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==a.rank)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:r,inputShape:s,newShape:a},o=zs.runKernel(tr,i);return{outputIndices:o[0],outputShape:o[1]}}}),Pd=Ys({sparseSegmentMean_:function(e,t,n){const r=qs(e,"data","sparseSegmentMean"),s=qs(t,"indices","sparseSegmentMean","int32"),a=qs(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return zs.runKernel(nr,i)}}),Md=Ys({sparseSegmentSum_:function(e,t,n){const r=qs(e,"data","sparseSegmentSum"),s=qs(t,"indices","sparseSegmentSum","int32"),a=qs(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return zs.runKernel(rr,i)}}),Ld=Ys({stringNGrams_:function(e,t,n,r,s,a,i,o){const u=qs(e,"data","stringNGrams","string");if("string"!==u.dtype)throw new Error("Data must be of datatype string");if(1!==u.shape.length)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=qs(t,"dataSplits","stringNGrams");if("int32"!==l.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},h={data:u,dataSplits:l},d=zs.runKernel(lr,h,c);return{nGrams:d[0],nGramsSplits:d[1]}}}),zd={fft:Qc,ifft:eh,rfft:rh,irfft:th},Bd={hammingWindow:Kh,hannWindow:Xh,frame:Yh,stft:Zh},Ud={flipLeftRight:Qh,grayscaleToRGB:ed,resizeNearestNeighbor:bd,resizeBilinear:gd,rgbToGrayscale:td,rotateWithOffset:nd,cropAndResize:Jh,nonMaxSuppression:sd,nonMaxSuppressionAsync:async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=qs(e,"boxes","nonMaxSuppressionAsync"),i=qs(t,"scores","nonMaxSuppressionAsync"),o=rd(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const u=await Promise.all([a.data(),i.data()]),l=u[0],c=u[1],{selectedIndices:h}=od(l,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),ch(h,"int32")},nonMaxSuppressionWithScore:fd,nonMaxSuppressionWithScoreAsync:async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=qs(e,"boxes","nonMaxSuppressionAsync"),o=qs(t,"scores","nonMaxSuppressionAsync"),u=rd(i,o,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const l=await Promise.all([i.data(),o.data()]),c=l[0],h=l[1],{selectedIndices:d,selectedScores:p}=ld(c,h,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ch(d,"int32"),selectedScores:ch(p)}},nonMaxSuppressionPadded:md,nonMaxSuppressionPaddedAsync:async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=qs(e,"boxes","nonMaxSuppressionAsync"),o=qs(t,"scores","nonMaxSuppressionAsync"),u=rd(i,o,n,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,[d,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=ud(d,p,l,c,h,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:ch(f,"int32"),validOutputs:_i(m,"int32")}},threshold:yd,transform:xd},Vd={bandPart:wd,gramSchmidt:vd,qr:kd},Wd={absoluteDifference:Id,computeWeightedLoss:Sd,cosineDistance:Nd,hingeLoss:Ed,huberLoss:$d,logLoss:Ad,meanSquaredError:Cd,sigmoidCrossEntropy:Od,softmaxCrossEntropy:Rd},jd={sparseFillEmptyRows:Dd,sparseReshape:Fd,sparseSegmentMean:Pd,sparseSegmentSum:Md},Gd={stringNGrams:Ld,stringSplit:Ys({stringSplit_:function(e,t,n=!0){const r=qs(e,"input","stringSplit","string"),s=qs(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},i={input:r,delimiter:s},o=zs.runKernel(cr,i,a);return{indices:o[0],values:o[1],shape:o[2]}}}),stringToHashBucketFast:Ys({stringToHashBucketFast_:function(e,t){const n=qs(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return zs.runKernel(hr,s,r)}}),staticRegexReplace:Ys({staticRegexReplace_:function(e,t,n,r=!0){const s=qs(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:r};return zs.runKernel(or,{x:s},a)}})},Hd=class{static sgd(e){return new Ui(e)}static momentum(e,t,n=!1){return new Vi(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new Wi(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new Di(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new $i(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new Bi(e,t,n,r,s)}static adagrad(e,t=.1){return new Ci(e,t)}},qd="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function Kd(){return new Promise(e=>qd(()=>e()))}function Xd(e,t){const n=e[0].length;e.forEach((e,t)=>{R(e.length===n,()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`)}),R(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=e[0];e.forEach((e,s)=>{for(let a=0;a<n;a++)R(a===t||e[a]===r[a],()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function Yd(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var Zd;function Jd(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function Qd(e){const t={FIRST_DIM_SIZE:Zd.FIRST_DIM_SIZE,VALUE_ROWIDS:Zd.VALUE_ROWIDS,ROW_LENGTHS:Zd.ROW_LENGTHS,ROW_SPLITS:Zd.ROW_SPLITS,ROW_LIMITS:Zd.ROW_LIMITS,ROW_STARTS:Zd.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function ep(e){return 0===e.length?0:e[0]===Zd.FIRST_DIM_SIZE?e.length-1:e.length}function tp(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const n=e[s],r=t[s+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${n} but ragged tensor input.flatValues.shape[${s-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(Zd||(Zd={}));const np=30;function rp(e){return e<=np?e:Q(e,Math.floor(Math.sqrt(e)))}function sp(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function ap(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)s=s.concat([e[r+1]/t[r],t[r]]);s=s.concat(e.slice(n+1))}return s}function ip(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function op(e,t,n,r=!0){const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?s.push(t[n-1]*e[n]):s.push(e[n]/t[n-1]):s.push(e[n]);return s}function up(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function lp(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}function cp(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===P(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let e=0;e<s.length-1;++e)i*=s[e];const o=e.shape,u=s.slice();u.pop();let l=1;for(let e=a;e<n;++e)l*=o[e],u.push(o[e]);const c=[...ee(e.shape).map(e=>e/l),1].slice(0,a);return[u,i,l,c]}const hp=1.7580993408473768,dp=1.0507009873554805,pp=.3275911,fp=.254829592,mp=-.284496736,gp=1.421413741,bp=-1.453152027,yp=1.061405429;function xp(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function wp(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function vp(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function _p(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function kp(e,t){return{real:e[2*t],imag:e[2*t+1]}}function Tp(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function Sp(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function Ip(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const Np="->",Ep=/->/g,$p=",",Ap="...";function Cp(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(Ep,"").length)/Np.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Np}").`);const[r,s]=e.split(Np);R(-1===r.indexOf(Ap),()=>`The ellipsis notation ("${Ap}") is not supported yet.`);const a=r.split($p),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let e=0;e<s.length;++e){const t=s[e];if(!a.some(e=>-1!==e.indexOf(t)))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===o.indexOf(t)&&o.push(t)}for(let e=0;e<r.length;++e){const t=r[e];-1===o.indexOf(t)&&t!==$p&&o.push(t)}const u=new Array(a.length);for(let e=0;e<i;++e){if(new Set(a[e].split("")).size!==a[e].length)throw new Error(`Found duplicate axes in input component ${a[e]}. Support for duplicate axes in input is not implemented yet.`);u[e]=[];for(let t=0;t<a[e].length;++t)u[e].push(o.indexOf(a[e][t]))}const l=o.length,c=[];for(let e=s.length;e<l;++e)c.push(e);return{allDims:o,summedDims:c,idDims:u}}function Op(e,t){let n=new Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;const r=[];for(let t=0;t<e;++t)-1===n[t]&&r.push(t);return n=n.filter(e=>-1!==e),{permutationIndices:n,expandDims:r}}function Rp(e,t,n){const r=new Array(e);for(let e=0;e<n.length;++e){const s=n[e].shape;for(let n=0;n<t[e].length;++n)void 0===r[t[e][n]]?r[t[e][n]]=s[n]:R(r[t[e][n]]===s[n],()=>`Expected dimension ${r[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(s)}, but got dimension ${s[n]}`)}}function Dp(e,t){const n=e,r=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let e=0;e<s;++e)r.push([]);const a=[];for(let e=0;e<n.length;++e){const s=Pp(t,n[e]);for(const t of s)-1===a.indexOf(t)&&(r[e].push(t),a.push(t))}return{path:n,steps:r}}function Fp(e){return e.every((e,t)=>e===t)}function Pp(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function Mp(e,t,n=0){let r=[];if("number"==typeof t)R(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce((e,t)=>(-1===t&&(e+=1),e),0);R(s<=1,()=>"There should be only one negative value in split array.");const a=t.indexOf(-1);if(-1!==a){const r=t.reduce((e,t)=>t>0?e+t:e);t[a]=e.shape[n]-r}R(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function Lp(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function zp(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function Bp(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Up(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Vp(e,t){return`size ${e} must be non-negative, not ${t}`}function Wp(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function jp(e,t){return`Input to reshape is a SparseTensor with ${P(e)}\n  dense values, but the requested shape requires a multiple of ${P(t)}. inputShape=${e} outputShape= ${t}`}function Gp(e,t){return`Input to reshape is a tensor with ${P(e)} dense values, but the requested shape has ${P(t)}. inputShape=${e} outputShape=${t}`}function Hp(){return"segment ids must be >= 0"}function qp(){return"segment ids are not increasing"}function Kp(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Xp(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function Yp(e,t){let n,r=!1;for(e<=np?(n=e,r=!0):n=Q(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Q(e,n+1);return n}function Zp(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function Jp(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const i=e.shape[n],o=[];let u=1,l=1,c=1;for(let t=0;t<r;++t)o.push(e.shape[t]),u*=e.shape[t];for(let t=r;t<n;t++)o.push(e.shape[t]),l*=e.shape[t];for(let e=r;e<s;e++)o.push(t.shape[e]);for(let t=n+1;t<a;t++)o.push(e.shape[t]),c*=e.shape[t];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:o}}function Qp(e){try{return e.map(e=>rs(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function ef(e){return e.map(e=>ns(e))}!function(){for(const e of ji)Ni(e)}();const tf={kernelName:ye,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bi(e,oh(hi(n,"float32"),-1))}}},nf={kernelName:xe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=xi(hi(n,"float32")),r=yi(Ri(_i(1),t));return Rl(gi(e,r))}}}},rf={kernelName:we,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=yi(Ri(xi(hi(n,"float32")),1));return gi(e,t)}}}},sf={kernelName:ve,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Li(n.shape,r.shape);return{a:()=>{let t=e;const r=Mi(n.shape,s);return r.length>0&&(t=ll(t,r)),au(t,n.shape)},b:()=>{let t=e;const n=Mi(r.shape,s);return n.length>0&&(t=ll(t,n)),au(t,r.shape)}}}},af={kernelName:_e,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach((t,r)=>{n[r]=()=>e.clone()}),n}},of={kernelName:Se,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>wi(n)}}},uf={kernelName:Ie,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>wi(n)}}},lf={kernelName:Ne,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gi(e,yi(Ri(_i(1),xi(hi(n,"float32")))))}}},cf={kernelName:Ee,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=yi(fi(_i(1),xi(hi(n,"float32"))));return gi(e,t)}}}},hf={kernelName:Ce,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Li(n.shape,r.shape);return{a:()=>{const t=fi(xi(n),xi(r));let a=bi(e,gi(r,t));const i=Mi(n.shape,s);return i.length>0&&(a=ll(a,i)),au(a,n.shape)},b:()=>{const t=fi(xi(n),xi(r));let a=Rl(bi(e,gi(n,t)));const i=Mi(r.shape,s);return i.length>0&&(a=ll(a,i)),au(a,r.shape)}}}},df={kernelName:$e,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gi(e,fi(xi(hi(n,"float32")),1))}}},pf={kernelName:Ae,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gi(e,Ri(_i(1),xi(hi(n,"float32"))))}}},ff=Ys({avgPool3dGrad_:function(e,t,n,r,s,a){const i=qs(e,"dy","avgPool3dGrad"),o=qs(t,"input","avgPool3dGrad");let u=i,l=o,c=!1;4===o.rank&&(c=!0,u=au(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=au(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),R(5===u.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),R(5===l.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),su("avgPool3dGrad",s,a);const h={dy:u,input:l},d={filterSize:n,strides:r,pad:s,dimRoundingMode:a},p=zs.runKernel(Fe,h,d);return c?au(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),mf={kernelName:De,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>ff(e,r,s,a,i,o)}}},gf=Ys({avgPoolGrad_:function(e,t,n,r,s){const a=qs(e,"dy","avgPoolGrad"),i=qs(t,"input","avgPoolGrad");R(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,u=a,l=!1;3===i.rank&&(l=!0,o=au(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=au(a,[1,a.shape[0],a.shape[1],a.shape[2]])),R(4===u.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),R(4===o.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const c={dy:u,input:o},h={filterSize:n,strides:r,pad:s},d=zs.runKernel(Re,c,h);return l?au(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),bf={kernelName:Oe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>gf(e,r,s,a,i)}}},yf={kernelName:Pe,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return a||i?!a&&i?{a:()=>lu(e,s,!1,!1),b:()=>lu(e,r,!0,!1)}:a&&!i?{a:()=>lu(s,e,!1,!0),b:()=>lu(r,e,!1,!1)}:{a:()=>lu(s,e,!0,!0),b:()=>lu(e,r,!0,!0)}:{a:()=>lu(e,s,!1,!0),b:()=>lu(r,e,!0,!1)}}},xf={kernelName:Me,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>pc(e,r,s)}}},wf={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let e=s.length-1;e>=0;e--)if(s[e]===a[e])i[e]=1;else if(1!==s[e])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const o=[];for(let e=0;e<i.length;e++)i[e]>1&&o.push(e);return{x:()=>ll(e,o,!0)}}},vf={kernelName:Ue,gradFunc:e=>({x:()=>e.clone()})},_f={kernelName:Ve,gradFunc:e=>({x:()=>wi(e)})},kf={kernelName:We,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>Hu(Ll(vl(r,s),El(r,a)),e,wi(e))}}},Tf={kernelName:Ge,inputsToSave:["x"],gradFunc:tf.gradFunc},Sf={kernelName:He,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map(e=>e.shape),{axis:s}=n,a=W(s,t[0].shape)[0],i=r.map(e=>e[a]);return nh(e,i,a).map(e=>()=>e)}},If={kernelName:qe,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:u}=n;return R(eu(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>Cu(r.shape,e,s,i,o,u),filter:()=>Lh(r,e,s.shape,i,o,u)}}},Nf={kernelName:Xe,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:u}=n;return{dy:()=>$u(e,s,a,i,o,1,u),filter:()=>Lh(e,r,s.shape,a,i,o,u)}}},Ef=Ys({conv3DBackpropFilter_:function(e,t,n,r,s){let a=e;4===e.rank&&(a=au(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=au(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),R(5===a.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),R(5===i.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),R(5===n.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),R(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),R(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);const o={x:a,dy:i},u={strides:r,pad:s,filterShape:n};return zs.runKernel(Ze,o,u)}}),$f={kernelName:Ye,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;R(eu(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[i,o]=t;return{x:()=>Du(i.shape,e,o,s,a),filter:()=>Ef(i,e,o.shape,s,a)}}},Af={kernelName:Qe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bi(Rl(Hc(hi(n,"float32"))),e)}}},Cf={kernelName:et,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bi(qc(hi(n,"float32")),e)}}},Of={kernelName:nt,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const t=sl([s],r.rank);let n=zu(e,s,a,!i);return null!=t&&(n=$h(n,t)),n}}}},Rf={kernelName:it,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=null==r?[1,1]:r;R(eu(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[u,l]=t;return R(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),R(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),R(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),R(tu(s,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`),su("depthwiseConv2d",a,i),{x:()=>Gh(u.shape,e,l,s,a,o,i),filter:()=>jh(u,e,l.shape,s,a,o,i)}}},Df={kernelName:ct,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>zs.runKernel(ht,a,n),filter:()=>zs.runKernel(dt,i,n)}}},Ff={kernelName:mt,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>zs.runKernel(gt,r)}}},Pf={kernelName:bt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=bi(pl(Rl(xi(n))),2/Math.sqrt(Math.PI));return{x:()=>bi(e,r)}}},Mf={kernelName:xt,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bi(e,n)}}},Lf={kernelName:wt,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>au(e,n.shape)}}},zf={kernelName:vt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bi(e,pl(n))}}},Bf={kernelName:St,gradFunc:e=>({x:()=>wi(e)})},Uf={kernelName:It,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Li(n.shape,r.shape);return{a:()=>{const t=gi(e,hi(r,"float32")),a=Mi(n.shape,s);return a.length>0?au(ll(t,a),n.shape):t},b:()=>{let t=bi(e,hi(n,"float32"));const a=Mi(r.shape,s);a.length>0&&(t=au(ll(t,a),r.shape));const i=xi(r);return Rl(gi(t,hi(i,"float32")))}}}},Vf={kernelName:Nt,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=t,u=null==o?_i(1):o,l=Mi(a.shape,s.shape),c=[];if(1===a.rank){for(let e=0;e<s.shape.length-1;++e)c.push(s.shape[e]);c.push(1)}const h=Ri(s,a),d=bi(e,u),p=Uc(fi(i,_i(r))),f=bi(bi(bi(p,p),p),_i(-.5));return{x:()=>1===a.rank?au(bi(bi(e,gl(au(p,[1,1,1,a.shape[0]]),c)),u),s.shape):au(bi(bi(e,p),u),s.shape),mean:()=>{let e=bi(bi(p,_i(-1)),d);return 1===a.rank&&(e=ll(e,l)),au(e,a.shape)},variance:()=>{let e=bi(bi(f,h),d);return 1===a.rank&&(e=ll(e,l)),au(e,a.shape)},scale:()=>{const t=bi(h,p);let n=bi(e,t);return 1===a.rank&&(n=ll(n,l)),au(n,a.shape)},offset:()=>{let t=e;return 1===a.rank&&(t=ll(t,l)),au(t,a.shape)}}}},Wf={kernelName:Et,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a,batchDims:i}=n,o=W(a,r.shape)[0],u=(e,t,n)=>()=>{const r=e.shape,s=t.size,i=r.slice(0,o),u=i.length,l=r.slice(a,r.length).slice(1),c=l.length,h=jf(0,u),d=jf(u+1,u+1+c),p=Gf([i,[s],l]),f=au(n,p),m=au(t,[s]),g=Gf([[u],h,d]),b=$h(f,g);let y=_h(b,m,e.shape[o]);const x=al(g);return y=$h(y,x),y};if(1===i){const t=r.shape[0],n=r.split(t,0);return{x:()=>{const t=ih(n.map((t,n)=>u(t,s.slice(n,1),e.slice(n,1))()));return t.reshape(r.shape)},indices:()=>s}}return{x:u(r,s,e),indices:()=>s}}};function jf(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function Gf(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const Hf={kernelName:Ct,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>wi(n),b:()=>wi(r)}}},qf={kernelName:Ot,gradFunc:e=>({x:()=>hi(e,"float32")})},Kf={kernelName:Ft,gradFunc:e=>({x:()=>wi(e)})},Xf={kernelName:Pt,gradFunc:e=>({x:()=>wi(e)})},Yf={kernelName:Mt,gradFunc:e=>({x:()=>wi(e)})},Zf={kernelName:Lt,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=wl(r,0);return{x:()=>Hu(a,e,bi(e,s))}}},Jf={kernelName:Wt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gi(e,fi(n,1))}}},Qf={kernelName:Vt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gi(e,hi(n,"float32"))}}},em={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const t=pl(r);return Ri(e,bi(ll(e,s,!0),t))}}}},tm=Ys({localResponseNormalizationBackprop_:function(e,t,n,r=5,s=1,a=1,i=.5){const o={x:e,y:t,dy:n},u={depthRadius:r,bias:s,alpha:a,beta:i};return zs.runKernel(Kt,o,u)}}),nm={kernelName:qt,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:u}=n;return{x:()=>tm(r,s,e,a,i,o,u)}}};function rm(e,t,n,r){return t.rank<n.rank&&(t=au(t,nl(t.shape,r))),e.rank<n.rank&&(e=au(e,nl(e.shape,r))),{x:()=>bi(e,hi(Gu(n,t),e.dtype))}}const sm={kernelName:Xt,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=rm(e,t[1],a,W(s,a.shape));return{x:()=>i.x()}}},am={kernelName:Yt,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>bi(e,hi(vl(n,r),"float32")),b:()=>bi(e,hi(Nl(n,r),"float32"))}}},im=Ys({maxPool3dGrad_:function(e,t,n,r,s,a,i){const o=qs(e,"dy","maxPool3dGrad"),u=qs(t,"input","maxPool3dGrad"),l=qs(n,"output","maxPool3dGrad");let c=o,h=u,d=l,p=!1;4===u.rank&&(p=!0,c=au(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=au(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),d=au(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),R(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),R(5===h.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),R(5===d.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),su("maxPool3dGrad",a,i);const f={dy:c,input:h,output:d},m={filterSize:r,strides:s,pad:a,dimRoundingMode:i},g=zs.runKernel(en,f,m);return p?au(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),om={kernelName:Qt,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=n;return{x:()=>im(e,r,s,a,i,o,u)}}},um=Ys({maxPoolGrad_:function(e,t,n,r,s,a,i){const o=qs(e,"dy","maxPoolGrad"),u=qs(t,"input","maxPoolGrad"),l=qs(n,"output","maxPoolGrad");R(u.rank===o.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`),R(4===o.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),R(4===u.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),su("maxPoolGrad",a,i);const c={dy:o,input:u,output:l},h={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return zs.runKernel(Jt,c,h)}}),lm={kernelName:Zt,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>um(e,r,s,a,i,o)}}},cm={kernelName:an,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map(e=>e[0]);return{x:()=>hu(e,a,r.shape)}}},hm={kernelName:yn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map(e=>e[0]);return{x:()=>hu(e,a,r.shape)}}},dm={kernelName:xn,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,o=Li(a.shape,i.shape);return{a:()=>{const t=hi(i,"float32");let n=bi(e,bi(t,Oi(a,Ri(t,_i(1)))));const r=Mi(a.shape,o);return r.length>0&&(n=ll(n,r)),au(n,a.shape)},b:()=>{const t=wl(a,0),n=Hu(t,Cl(a),wi(a));let r=bi(e,bi(s,n));const u=Mi(i.shape,o);return u.length>0&&(r=ll(r,u)),au(r,i.shape)}}}};const pm={kernelName:Vn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=wl(n,_i(0)),r=_i(hp),s=_i(dp),a=bi(e,s),i=bi(bi(e,r),pl(hi(n,"float32")));return Hu(t,a,i)}}}},fm={kernelName:Zn,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>fu(e,r,s)}}},mm={kernelName:Jn,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>uu(e,r)}}},gm=[tf,nf,rf,sf,af,of,uf,lf,cf,hf,df,pf,mf,bf,yf,xf,wf,vf,_f,kf,Tf,Sf,Nf,If,$f,Af,Cf,Of,Rf,Df,{kernelName:pt,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Li(n.shape,r.shape);return{a:()=>{const t=gi(e,hi(r,"float32")),a=Mi(n.shape,s);return a.length>0?au(ll(t,a),n.shape):t},b:()=>{let t=bi(e,hi(n,"float32"));const a=Mi(r.shape,s);a.length>0&&(t=au(ll(t,a),r.shape));const i=xi(r);return Rl(gi(t,hi(i,"float32")))}}}},Ff,Pf,Mf,Lf,zf,Uf,Bf,Vf,Wf,Hf,qf,Kf,Xf,Yf,Zf,Jf,Qf,em,nm,sm,sm,am,om,lm,{kernelName:nn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=W(s,r.shape),i=P(tl(r.shape,a)[1]);return{x:()=>{const t=r.shape.slice();a.forEach(e=>{t[e]=1});const n=au(e,t);return gi(bi(n,Yl(r.shape,"float32")),i)}}}},{kernelName:rn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,o=rm(e,i,a,W(s,a.shape));return{x:()=>o.x()}}},{kernelName:sn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>bi(e,hi(El(n,r),"float32")),b:()=>bi(e,hi(wl(n,r),"float32"))}}},cm,{kernelName:on,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Li(n.shape,r.shape);return{a:()=>{const t=Mi(n.shape,s);return t.length>0?au(ll(e,t),n.shape):e},b:()=>{const t=bi(e,Rl(yl(gi(n,r)))),a=Mi(r.shape,s);return a.length>0?au(ll(t,a),r.shape):t}}}},{kernelName:ln,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Li(n.shape,r.shape);return{a:()=>{const t=bi(e,hi(r,"float32")),a=Mi(n.shape,s);return a.length>0?au(ll(t,a),n.shape):t},b:()=>{const t=bi(e,hi(n,"float32")),a=Mi(r.shape,s);return a.length>0?au(ll(t,a),r.shape):t}}}},{kernelName:cn,gradFunc:e=>({x:()=>Rl(e)})},{kernelName:gn,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>Xl(n.shape,"float32")}}},{kernelName:mn,gradFunc:e=>({x:()=>wi(e)})},{kernelName:bn,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return kh(e,r).map(e=>()=>e)}},hm,hm,dm,{kernelName:wn,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=wl(n,0);return{x:()=>Hu(s,e,bi(e,r)),alpha:()=>{let t=Hu(s,wi(e),bi(e,n));const a=Mi(r.shape,e.shape);return a.length>0&&(t=ll(t,a)),au(t,r.shape)}}}},{kernelName:vn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;let a=[];return a=null==s?r.shape.map((e,t)=>t):"number"==typeof s?[s]:s,{x:()=>function(e,t,n){const r=e.shape.length,s=r-n.length,a=sl(n,r);let i=e;null!=a&&(i=$h(e,a));const o=i.shape.slice(),u=o.splice(r-n.length,n.length).reduce((e,t)=>e*t,1);o.push(u);let l=function(e,t,n){const r=e.shape.slice();r[n]=1;const s=au(t,r),a=Lu(e,n,!0,!1),i=Lu(e,n,!0,!0),o=bi(a,i);return bi(s,o)}(i.reshape(o),t,s);if(l=l.reshape(i.shape),null!=a){const e=al(a);l=$h(l,e)}return l}(r,e,a)}}},{kernelName:Nn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gi(e,Rl(xi(n)))}}},{kernelName:Dn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=bi(El(n,6),oh(n));return{x:()=>bi(e,hi(r,"float32"))}}},{kernelName:En,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bi(e,hi(oh(n),"float32"))}}},{kernelName:$n,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>au(e,n.shape)}}},{kernelName:On,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>zs.runKernel(Rn,s,n)}}},{kernelName:An,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>zs.runKernel(Cn,s,n)}}},{kernelName:Fn,gradFunc:(e,t,n)=>{const{dims:r}=n,s=W(r,e.shape);return{x:()=>Fc(e,s)}}},{kernelName:Pn,gradFunc:e=>({x:()=>wi(e)})},{kernelName:Mn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Rl(gi(e,bi(Oi(n,1.5),2)))}}},{kernelName:Un,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>hi(wi(n),"float32"),t:()=>bi(e,hi(n,e.dtype)),e:()=>bi(e,hi(zl(n),e.dtype))}}},pm,{kernelName:qn,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bi(e,bi(n,Ri(_i(1),n)))}}},{kernelName:Hn,gradFunc:e=>({x:()=>wi(e)})},{kernelName:jn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bi(Pu(hi(n,"float32")),e)}}},{kernelName:Gn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bi(Mu(hi(n,"float32")),e)}}},{kernelName:Wn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[o,u]=$o(r,s,a),l=[];for(let t=0;t<e.rank;t++)l.push([o[t],i[t]-o[t]-u[t]]);return{x:()=>uc(e,l)}}},{kernelName:Qn,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=bi(e,r);return{logits:()=>Ri(a,bi(ll(a,[s],!0),r))}}},{kernelName:Kn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bi(e,cu(n))}}},fm,fm,mm,mm,{kernelName:Xn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gi(e,bi(yi(hi(n,"float32")),2))}}},{kernelName:ar,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=_i(2);return{a:()=>bi(e,bi(s,Ri(n,r))),b:()=>bi(e,bi(s,Ri(r,n)))}}},{kernelName:ir,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bi(e,bi(hi(n,"float32"),2))}}},{kernelName:kr,gradFunc:e=>({x:()=>wi(e)})},{kernelName:dr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Li(n.shape,r.shape);return{a:()=>{let t=e;const r=Mi(n.shape,s);return r.length>0&&(t=ll(t,r)),au(t,n.shape)},b:()=>{let t=e;const n=Mi(r.shape,s);return n.length>0&&(t=ll(t,n)),au(Rl(t),r.shape)}}}},{kernelName:Yn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n;W(a,r.shape).forEach(e=>{s[e]=1});const i=au(e,s),o=bi(i,Yl(r.shape,"float32"));return{x:()=>o}}},{kernelName:pr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>gi(e,xi(Pu(n)))}}},{kernelName:fr,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bi(Ri(_i(1),xi(n)),e)}}},{kernelName:mr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let t=wi(r);if(1===r.rank)for(let n=0;n<s[0];++n)t=fi(t,hu(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)t=fi(t,hu(e,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)t=fi(t,hu(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)for(let o=0;o<s[3];++o)t=fi(t,hu(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},{kernelName:yr,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=al(s);return{x:()=>$h(e,a)}}},{kernelName:wr,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>ih(e,s)}}},{kernelName:vr,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=zi(t,wi(t)),r=xl(e,n);let s=vl(t,_i(0,"int32"));const a=r.rank-s.rank;for(let e=0;e<a;++e)s=fl(s,e+1);s=Ll(s,Yl(r.shape,"bool"));const i=wi(r);return Hu(s,r,i)}(e,n)}}},{kernelName:_r,gradFunc:e=>({x:()=>wi(e)})}];for(const e of gm)Pr(e);xs().prototype.abs=function(){return this.throwIfDisposed(),Fi(this)},xs().prototype.acos=function(){return this.throwIfDisposed(),Oo(this)},xs().prototype.acosh=function(){return this.throwIfDisposed(),Ro(this)},xs().prototype.add=function(e){return this.throwIfDisposed(),fi(this,e)},xs().prototype.all=function(e,t){return this.throwIfDisposed(),Fo(this,e,t)},xs().prototype.any=function(e,t){return this.throwIfDisposed(),Po(this,e,t)},xs().prototype.argMax=function(e){return this.throwIfDisposed(),Mo(this,e)},xs().prototype.argMin=function(e){return this.throwIfDisposed(),Lo(this,e)},xs().prototype.asScalar=function(){return this.throwIfDisposed(),R(1===this.size,()=>"The array must have only 1 element."),au(this,[])},xs().prototype.asType=function(e){return this.throwIfDisposed(),hi(this,e)},xs().prototype.as1D=function(){return this.throwIfDisposed(),au(this,[this.size])},xs().prototype.as2D=function(e,t){return this.throwIfDisposed(),au(this,[e,t])},xs().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),au(this,[e,t,n])},xs().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),au(this,[e,t,n,r])},xs().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),au(this,[e,t,n,r,s])},xs().prototype.asin=function(){return this.throwIfDisposed(),zo(this)},xs().prototype.asinh=function(){return this.throwIfDisposed(),Bo(this)},xs().prototype.atan=function(){return this.throwIfDisposed(),Uo(this)},xs().prototype.atan2=function(e){return this.throwIfDisposed(),Vo(this,e)},xs().prototype.atanh=function(){return this.throwIfDisposed(),Wo(this)},xs().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),iu(this,e,t,n,r)},xs().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),fu(this,e,t)},xs().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),mu(this,e,t,n,r,s)},xs().prototype.broadcastTo=function(e){return this.throwIfDisposed(),_u(this,e)},xs().prototype.cast=function(e){return this.throwIfDisposed(),hi(this,e)},xs().prototype.ceil=function(){return this.throwIfDisposed(),ku(this)},xs().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Tu(this,e,t)},xs().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof ys&&(e=[e]),uu([this,...e],t)},xs().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Au(this,e,t,n,r,s,a)},xs().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),Ou(this,e,t,n,r,s)},xs().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),$u(this,e,t,n,r,s,a)},xs().prototype.cos=function(){return this.throwIfDisposed(),Pu(this)},xs().prototype.cosh=function(){return this.throwIfDisposed(),Mu(this)},xs().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Lu(this,e,t,n)},xs().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),zu(this,e,t,n)},xs().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Uu(this,e,t)},xs().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Vu(this,e,t,n,r,s,a)},xs().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),ju(this,e,t,n,r,s)},xs().prototype.divNoNan=function(e){return this.throwIfDisposed(),qu(this,e)},xs().prototype.div=function(e){return this.throwIfDisposed(),gi(this,e)},xs().prototype.dot=function(e){return this.throwIfDisposed(),Ku(this,e)},xs().prototype.elu=function(){return this.throwIfDisposed(),Yu(this)},xs().prototype.equal=function(e){return this.throwIfDisposed(),Gu(this,e)},xs().prototype.erf=function(){return this.throwIfDisposed(),Ju(this)},xs().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),dl(this,e,t)},xs().prototype.exp=function(){return this.throwIfDisposed(),pl(this)},xs().prototype.expandDims=function(e){return this.throwIfDisposed(),fl(this,e)},xs().prototype.expm1=function(){return this.throwIfDisposed(),ml(this)},xs().prototype.fft=function(){return this.throwIfDisposed(),Qc(this)},xs().prototype.flatten=function(){return this.throwIfDisposed(),au(this,[this.size])},xs().prototype.floor=function(){return this.throwIfDisposed(),yl(this)},xs().prototype.floorDiv=function(e){return this.throwIfDisposed(),mi(this,e)},xs().prototype.gather=function(e,t,n){return this.throwIfDisposed(),xl(this,e,t,n)},xs().prototype.greaterEqual=function(e){return this.throwIfDisposed(),vl(this,e)},xs().prototype.greater=function(e){return this.throwIfDisposed(),wl(this,e)},xs().prototype.ifft=function(){return this.throwIfDisposed(),eh(this)},xs().prototype.irfft=function(){return this.throwIfDisposed(),th(this)},xs().prototype.isFinite=function(){return this.throwIfDisposed(),kl(this)},xs().prototype.isInf=function(){return this.throwIfDisposed(),Tl(this)},xs().prototype.isNaN=function(){return this.throwIfDisposed(),Sl(this)},xs().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Il(this,e)},xs().prototype.lessEqual=function(e){return this.throwIfDisposed(),El(this,e)},xs().prototype.less=function(e){return this.throwIfDisposed(),Nl(this,e)},xs().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),Al(this,e,t,n,r)},xs().prototype.logSigmoid=function(){return this.throwIfDisposed(),Fl(this)},xs().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Pl(this,e)},xs().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Ml(this,e,t)},xs().prototype.log=function(){return this.throwIfDisposed(),Cl(this)},xs().prototype.log1p=function(){return this.throwIfDisposed(),Ol(this)},xs().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Ll(this,e)},xs().prototype.logicalNot=function(){return this.throwIfDisposed(),zl(this)},xs().prototype.logicalOr=function(e){return this.throwIfDisposed(),Bl(this,e)},xs().prototype.logicalXor=function(e){return this.throwIfDisposed(),Ul(this,e)},xs().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),lu(this,e,t,n)},xs().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),Gl(this,e,t,n,r)},xs().prototype.max=function(e,t){return this.throwIfDisposed(),ol(this,e,t)},xs().prototype.maximum=function(e){return this.throwIfDisposed(),zi(this,e)},xs().prototype.mean=function(e,t){return this.throwIfDisposed(),Kl(this,e,t)},xs().prototype.min=function(e,t){return this.throwIfDisposed(),ul(this,e,t)},xs().prototype.minimum=function(e){return this.throwIfDisposed(),Jl(this,e)},xs().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Ql(this,e,t)},xs().prototype.mod=function(e){return this.throwIfDisposed(),ec(this,e)},xs().prototype.mul=function(e){return this.throwIfDisposed(),bi(this,e)},xs().prototype.neg=function(){return this.throwIfDisposed(),Rl(this)},xs().prototype.norm=function(e,t,n){return this.throwIfDisposed(),hl(this,e,t,n)},xs().prototype.notEqual=function(e){return this.throwIfDisposed(),sc(this,e)},xs().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),ac(this,e,t,n)},xs().prototype.onesLike=function(){return this.throwIfDisposed(),ic(this)},xs().prototype.pad=function(e,t){return this.throwIfDisposed(),uc(this,e,t)},xs().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),fc(this,e,t,n,r,s,a)},xs().prototype.pow=function(e){return this.throwIfDisposed(),Oi(this,e)},xs().prototype.prelu=function(e){return this.throwIfDisposed(),mc(this,e)},xs().prototype.prod=function(e,t){return this.throwIfDisposed(),gc(this,e,t)},xs().prototype.reciprocal=function(){return this.throwIfDisposed(),Oc(this)},xs().prototype.relu=function(){return this.throwIfDisposed(),Rc(this)},xs().prototype.relu6=function(){return this.throwIfDisposed(),Dc(this)},xs().prototype.reshapeAs=function(e){return this.throwIfDisposed(),au(this,e.shape)},xs().prototype.reshape=function(e){return this.throwIfDisposed(),au(this,e)},xs().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),gd(this,e,t,n)},xs().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),bd(this,e,t,n)},xs().prototype.reverse=function(e){return this.throwIfDisposed(),Fc(this,e)},xs().prototype.rfft=function(){return this.throwIfDisposed(),rh(this)},xs().prototype.round=function(){return this.throwIfDisposed(),Bc(this)},xs().prototype.rsqrt=function(){return this.throwIfDisposed(),Uc(this)},xs().prototype.selu=function(){return this.throwIfDisposed(),Vc(this)},xs().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Wc(this,e,t,n,r,s,a)},xs().prototype.sigmoid=function(){return this.throwIfDisposed(),cu(this)},xs().prototype.sign=function(){return this.throwIfDisposed(),Gc(this)},xs().prototype.sin=function(){return this.throwIfDisposed(),Hc(this)},xs().prototype.sinh=function(){return this.throwIfDisposed(),qc(this)},xs().prototype.slice=function(e,t){return this.throwIfDisposed(),hu(this,e,t)},xs().prototype.softmax=function(e){return this.throwIfDisposed(),Jc(this,e)},xs().prototype.softplus=function(){return this.throwIfDisposed(),Dl(this)},xs().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),pc(this,e,t)},xs().prototype.split=function(e,t){return this.throwIfDisposed(),nh(this,e,t)},xs().prototype.sqrt=function(){return this.throwIfDisposed(),yi(this)},xs().prototype.square=function(){return this.throwIfDisposed(),xi(this)},xs().prototype.squaredDifference=function(e){return this.throwIfDisposed(),sh(this,e)},xs().prototype.squeeze=function(e){return this.throwIfDisposed(),ah(this,e)},xs().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof ys?[this,e]:[this,...e];return ih(n,t)},xs().prototype.step=function(e){return this.throwIfDisposed(),oh(this,e)},xs().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),uh(this,e,t,n,r,s,a,i,o)},xs().prototype.sub=function(e){return this.throwIfDisposed(),Ri(this,e)},xs().prototype.sum=function(e,t){return this.throwIfDisposed(),ll(this,e,t)},xs().prototype.tan=function(){return this.throwIfDisposed(),lh(this)},xs().prototype.tanh=function(){return this.throwIfDisposed(),du(this)},xs().prototype.tile=function(e){return this.throwIfDisposed(),gl(this,e)},xs().prototype.toBool=function(){return this.throwIfDisposed(),hi(this,"bool")},xs().prototype.toFloat=function(){return this.throwIfDisposed(),hi(this,"float32")},xs().prototype.toInt=function(){return this.throwIfDisposed(),hi(this,"int32")},xs().prototype.topk=function(e,t){return this.throwIfDisposed(),xh(this,e,t)},xs().prototype.transpose=function(e){return this.throwIfDisposed(),$h(this,e)},xs().prototype.unique=function(e){return this.throwIfDisposed(),vh(this,e)},xs().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),_h(this,e,t)},xs().prototype.unstack=function(e){return this.throwIfDisposed(),kh(this,e)},xs().prototype.where=function(e,t){return this.throwIfDisposed(),Hu(e,this,t)},xs().prototype.zerosLike=function(){return this.throwIfDisposed(),wi(this)};class bm extends Error{constructor(e){super(e),Object.setPrototypeOf(this,bm.prototype)}}class ym extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ym.prototype)}}class xm extends Error{constructor(e){super(e),Object.setPrototypeOf(this,xm.prototype)}}class wm extends Error{constructor(e){super(e),Object.setPrototypeOf(this,wm.prototype)}}class vm extends Error{constructor(e){super(e),Object.setPrototypeOf(this,vm.prototype)}}Error;class _m{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function km(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function Tm(e,t){if(!e)throw new vm(t)}function Sm(e,t){let n=0;for(const r of e)r===t&&n++;return n}function Im(e){return 1===e.length?e[0]:e}function Nm(e){return Array.isArray(e)?e:[e]}function Em(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function $m(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Am={};function Cm(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Om(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach(e=>Om(e));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?Om(t):e[n]=t.value)}}}function Rm(e,t={},n={},r="object",s=!1){if("string"==typeof e){const s=e;let a;if(s in n)a=n[s];else if(s in Am)a=Am[s];else if(a=t[s],null==a)throw new xm(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const a=e;if(null==a.className||null==a.config)throw new xm(`${r}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const i=a.className;let o,u;if(i in n?[o,u]=n[i]:i in Am?[o,u]=Am.className:i in t&&([o,u]=t[i]),null==o)throw new xm(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=u){const e={};for(const t of Object.keys(Am))e[t]=Am[t];for(const t of Object.keys(n))e[t]=n[t];a.config.customObjects=e;const t=Object.assign({},Am);for(const e of Object.keys(n))Am[e]=n[e];Om(a.config);const r=u(o,a.config,n,s);return Am=Object.assign({},t),r}{const e=Object.assign({},Am);for(const e of Object.keys(n))Am[e]=n[e];const t=new o(a.config);return Am=Object.assign({},e),t}}}function Dm(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function Fm(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function Pm(e){if(null==e)throw new xm(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function Mm(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new xm(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function Lm(e,t,n=0,r=1/0){return Tm(n>=0),Tm(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(e=>typeof e===t)}function zm(e,t){Array.isArray(e)?(R(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((e,n)=>zm(e,`element ${n+1} of ${t}`))):R(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${Bm(e)}.`)}function Bm(e){return null===e?"null":Array.isArray(e)?"["+e.map(e=>Bm(e)).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function Um(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let Vm=0;function Wm(){return Vm++}const jm={};function Gm(e=""){return e in jm||(jm[e]=0),jm[e]+=1,e+jm[e].toString()}const Hm=["channelsFirst","channelsLast"],qm=["nearest","bilinear"],Km=["valid","same","causal"],Xm=["max","avg"],Ym=["sum","mul","concat","ave"],Zm=new Map;function Jm(e){Mm(Hm,"DataFormat",e)}function Qm(e){Mm(Km,"PaddingMode",e)}function eg(e){Mm(Xm,"PoolMode",e)}const tg=[];function ng(e,t){tg.push(e);try{const e=t();return tg.pop(),e}catch(e){throw tg.pop(),e}}function rg(e){if(!ig(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===tg.length?"":tg.join("/")+"/")+e}function sg(e){if(!ig(e))throw new Error("Not a valid tensor name: '"+e+"'");Zm.has(e)||Zm.set(e,0);const t=Zm.get(e);if(Zm.set(e,Zm.get(e)+1),t>0){const n=`${e}_${t}`;return Zm.set(n,1),n}return e}const ag=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function ig(e){return!!e.match(ag)}function og(e){return e===parseInt(e.toString(),10)}function ug(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function lg(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function cg(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function hg(e,t){if(t<e)throw new xm(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}let dg;function pg(){return null==dg&&(dg=la().epsilon()),dg}function fg(e,t){return hi(e,t)}function mg(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),au(e,n)}function gg(e,t,n){return sa(()=>{switch(e.rank){case 1:return Kc(e,t,n);case 2:return Xc(e,[t,0],[n,e.shape[1]]);case 3:return Yc(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Zc(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return hu(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return hu(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new xm(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function bg(e,t,n){return sa(()=>{switch(e.rank){case 1:return Kc(e,t,n);case 2:return Xc(e,[0,t],[e.shape[0],n]);case 3:return Yc(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Zc(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new xm(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function yg(e,t,n,r){return sa(()=>{switch(e.rank){case 1:return Kc(e,t,n);case 2:switch(r){case 1:return gg(e,t,n);case 2:return bg(e,t,n);default:throw new xm(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return gg(e,t,n);case 2:return Yc(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return bg(e,t,n);default:throw new xm(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return gg(e,t,n);case 2:return Zc(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Zc(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return bg(e,t,n);default:throw new xm(`The axis is not within the rank of the tensor ${r}`)}default:throw new xm(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function xg(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),uu(e,t)}function wg(e,t){switch(e.rank){case 1:return Su([e,t]);case 2:return Iu([e,t],0);case 3:return Nu([e,t],0);case 4:return Eu([e,t],0);default:throw new xm(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function vg(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new xm(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return gl(e,t)}function _g(e,t=0,n=1,r,s){return Ic(e,t,n,r,s)}function kg(e,t,n,r){if(e.rank<2||t.rank<2)throw new wm(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3&&e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new wm(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);if(2===e.rank&&2===t.rank)return qh({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?Ig(e.rank,r,"channelsLast"):null,activation:n});{const s=e.shape.slice(),a=s.pop();e=au(e,[-1,a]);const i=t.shape.slice(),o=i.pop(),u=i.pop(),l=[...i,o],c=Array.from({length:t.rank},(e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n);t=au($h(t,c),[u,-1]);const h=[...s,...l];return au(qh({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?Ig(e.rank,r,"channelsLast"):null,activation:n}),h)}}function Tg(e,t,n){return sa(()=>(t=Array.isArray(t)?ch(t,"int32"):hi(t,"int32"),xl(e,t,n)))}function Sg(e){return bi(e,e)}function Ig(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new xm(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?au(t,[1,r[0],1,1,1]):au(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?au(t,[1,1,1,1,r[0]]):au(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?au(t,[1,r[0],1,1]):au(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?au(t,[1,1,1,r[0]]):au(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?au(t,[1,r[0],1]):au(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?au(t,[1,1,r[0]]):au(t,[1].concat(r))}else if(e<3)return t;throw new xm(`Unsupported input rank by biasAdd: ${t.rank}`)}function Ng(e,t,n){return sa(()=>(null==n&&(n="channelsLast"),Jm(n),fi(e,Ig(e.rank,t,n))))}function Eg(e,t,n,r){return sa(()=>Dh(e,t,n,r))}function $g(e,t,n=!1){return n?e():t()}const Ag=["fanIn","fanOut","fanAvg"],Cg=["normal","uniform","truncatedNormal"];class Og extends Si{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Rg extends Og{apply(e,t){return Xl(e,t)}}Rg.className="Zeros",Ni(Rg);class Dg extends Og{apply(e,t){return Yl(e,t)}}Dg.className="Ones",Ni(Dg);class Fg extends Og{constructor(e){if(super(),"object"!=typeof e)throw new xm(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new xm(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return sa(()=>bi(_i(this.value),Yl(e,t)))}getConfig(){return{value:this.value}}}Fg.className="Constant",Ni(Fg);class Pg extends Og{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Ec(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Pg.className="RandomUniform",Ni(Pg);class Mg extends Og{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new wm(`randomNormal does not support dType ${t}.`);return _g(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Mg.className="RandomNormal",Ni(Mg);class Lg extends Og{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new wm(`truncatedNormal does not support dType ${t}.`);return wh(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Lg.className="TruncatedNormal",Ni(Lg);class zg extends Og{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return sa(()=>{if(2!==e.length||e[0]!==e[1])throw new xm("Identity matrix initializer can only be used for 2D square matrices.");return bi(this.gain,bl(e[0]))})}getConfig(){return{gain:this.gain}}}zg.className="Identity",Ni(zg);class Bg extends Og{constructor(e){if(super(),e.scale<0)throw new xm(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,Mm(Ag,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){Mm(Cg,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e,t="channelsLast"){let n,r;if(Jm(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=ug(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){const t=ug(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{const t=ug(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}(e),r=n[0],s=n[1];let a=this.scale;if("fanIn"===this.mode?a/=Math.max(1,r):"fanOut"===this.mode?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new wm(`${this.getClassName()} does not support dType ${t}.`);return wh(e,0,n,t,this.seed)}{const n=Math.sqrt(3*a);return Ec(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Bg.className="VarianceScaling",Ni(Bg);class Ug extends Bg{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Bg.className}}Ug.className="GlorotUniform",Ni(Ug);class Vg extends Bg{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Bg.className}}Vg.className="GlorotNormal",Ni(Vg);class Wg extends Bg{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Bg.className}}Wg.className="HeNormal",Ni(Wg);class jg extends Bg{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Bg.className}}jg.className="HeUniform",Ni(jg);class Gg extends Bg{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Bg.className}}Gg.className="LeCunNormal",Ni(Gg);class Hg extends Bg{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Bg.className}}Hg.className="LeCunUniform",Ni(Hg);class qg extends Og{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return sa(()=>{if(e.length<2)throw new wm("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);const n=P(e.slice(0,-1)),r=e[e.length-1],s=n*r;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);const a=_g([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=Vd.qr(a,!1);let o=i[0];const u=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=bi(o,u.sign()),n<r&&(o=o.transpose()),bi(_i(this.gain),o.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}qg.className="Orthogonal",Ni(qg);const Kg={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Xg(e,t={}){return Rm(e,Ii.getMap().classNameMap,t,"initializer")}function Yg(e){return Cm(e)}function Zg(e){if("string"==typeof e){const t=e in Kg?Kg[e]:e;if("GlorotNormal"===t)return new Vg;if("GlorotUniform"===t)return new Ug;if("HeNormal"===t)return new Wg;if("HeUniform"===t)return new jg;if("LeCunNormal"===t)return new Gg;if("LeCunUniform"===t)return new Hg;{const e={};return e.className=t,e.config={},Xg(e)}}return e instanceof Og?e:Xg(e)}function Jg(e){return Array.isArray(e)&&Array.isArray(e[0])}function Qg(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function eb(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new xm(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function tb(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new xm(`Expected exactly 1 Shape; got ${e.length}`)}return e}function nb(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce((e,t)=>e*t);return t}const rb="Variable";class sb{constructor(e,t="float32",n=rb,r=!0,s=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=Wm(),n=null==n?rb:n,this.originalName=rg(n),this.name=sg(this.originalName),this.trainable_=r,this.constraint=s,this.val=Sh(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function ab(e){return e.map(e=>e.read())}function ib(e){e.forEach(e=>{e[0].write(e[1])})}class ob{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class ub{constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=Wm(),null!=a&&(this.originalName=rg(a),this.name=sg(this.originalName)),this.rank=t.length}}let lb=0;class cb{constructor(e,t){this.callArgs=t,this.id=lb++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const t of e.inboundLayers)null!=t&&t.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let hb=0;class db extends Si{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=hb++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=Em(e)+"_"+Gm(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new ym(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new xm(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Im(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Im(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new bm(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new bm(`Layer ${this.name} is not connected, no input to return.`);return Im(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new bm(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new bm(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Im(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Nm(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=Nm(this.inputSpec);if(t.length!==n.length)throw new xm(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let e=0;e<t.length;e++){const r=t[e],s=n[e];if(null==s)continue;const a=r.rank;if(null!=s.ndim&&a!==s.ndim)throw new xm(`Input ${e} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(null!=s.maxNDim&&a>s.maxNDim)throw new xm(`Input ${e} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(null!=s.minNDim&&a<s.minNDim)throw new xm(`Input ${e} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(null!=s.dtype&&r.dtype!==s.dtype)throw new xm(`Input ${e} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){const t=r.shape;for(const n in s.axes){const r=Number(n),a=s.axes[n],i=r>=0?t[r]:t[t.length+r];if(null!=a&&-1===[a,null].indexOf(i))throw new xm(`Input ${e} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${a} but got shape ${t}.`)}}if(null!=s.shape)for(let t=0;t<s.shape.length;++t){const n=s.shape[t],a=r.shape[t];if(null!=n&&null!=a&&n!==a)throw new xm(`Input ${e} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=Nm(e),r=function(e){let t=!0;for(const n of Nm(e))if(!(n instanceof ub)){t=!1;break}return t}(e),s=function(e){let t=!0;for(const n of Nm(e))if(n instanceof ub){t=!1;break}return t}(e);if(r===s)throw new xm("Arguments to apply() must be all SymbolicTensors or all Tensors");return ng(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of Nm(e))t.push(n.shape);this.build(Im(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const s=Nm(r),a=[];for(let e of s)-1!==n.indexOf(e)&&(e=e.clone()),a.push(e);if(r=Im(a),null!=this.activityRegularizer)throw new wm("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=Nm(e);const t=[];for(const n of e)t.push(n.shape);return Im(t)}(e),r=this.computeOutputShape(n);let s;const a="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map((n,r)=>new ub(a,n,this,Nm(e),t,this.name,r)):new ub(a,r,this,Nm(e),t,this.name),this.addInboundNode(e,s,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new wm("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}})}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new bm(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new bm(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ym(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return nb(this.weights)}build(e){this.built=!0}getWeights(e=!1){return ab(e?this.trainableWeights:this.weights)}setWeights(e){sa(()=>{const t=this.weights;if(t.length!==e.length)throw new xm(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=ab(t);for(let s=0;s<r.length;++s){const a=r[s],i=t[s],o=e[s];if(!M(a.shape,o.shape))throw new xm(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}ib(n)})}addWeight(e,t,n,r,s,a,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new xm(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():Zg("zeros"));const u=r.apply(t,n),l=new sb(u,n,e,a,i);return u.dispose(),null!=s&&this.addLoss(()=>s.apply(l.read())),null==a&&(a=!0),a?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=Nm(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach(e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n),s=Nm(t),a=Nm(r);if(s.length!==a.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let e=0;e<s.length;e++)s[e].kerasMask=a[e]}addInboundNode(e,t,n,r,s,a,i=null){const o=Nm(e);t=Nm(t),n=Nm(n),r=Nm(r),s=Qg(s),a=Qg(a);const u=[],l=[],c=[];for(const e of o)u.push(e.sourceLayer),l.push(e.nodeIndex),c.push(e.tensorIndex);new cb({outboundLayer:this,inboundLayers:u,nodeIndices:l,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let e=0;e<t.length;e++)t[e].sourceLayer=this,t[e].nodeIndex=this.inboundNodes.length-1,t[e].tensorIndex=e}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function pb(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=pb(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class fb extends db{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Gm("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new xm("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new xm("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new xm("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new ub(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new cb({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new xm(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}fb.className="InputLayer",Ni(fb);class mb{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof mb)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new xm(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return hi(t,e.dtype)}catch(n){throw new xm(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof ub){if(null==this.id2Value[e.id])throw new xm(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new xm(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof ub){if(null==this.id2Value[e.id])throw new xm(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new xm(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&aa(this.id2Mask)}}const gb=new _m,bb=new _m;function yb(e,t,n,r){const s=null!=n&&n.training,a=Array.isArray(e),i=a?e:[e],o=i.map(e=>e.name),u=[],l=t.names();for(const e of o)-1!==l.indexOf(e)?u.push(t.getValue(e)):u.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().sort().join(",");let h,d=gb.get(c);if(null==d){const e=function(e,t){R(null!=e&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(1===e.length){const s=wb(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:e,recipientMap:i}=wb(a,t);for(const t of e)s.has(t.name)||(n.push(t),s.add(t.name));for(const e in i)null==r[e]&&(r[e]=new Set),i[e].forEach(t=>r[e].add(t))}}return{sorted:n,recipientCounts:xb(r)}}(i,t);d=e.sorted,h=e.recipientCounts,gb.put(c,d),bb.put(c,h)}h={},s||Object.assign(h,bb.get(c));const p=new mb(t);for(let e=0;e<d.length;++e){if(null!=r){const e=ra().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const a=d[e],i=a.sourceLayer;if(i instanceof fb)continue;const l=[],c=[],f=[];let m=!1;for(const e of a.inputs){const n=p.getValue(e),r=p.getMask(e);l.push(n),c.push(r),null!=r&&(m=!0),s||(h[e.name]--,0!==h[e.name]||t.hasKey(e)||-1!==o.indexOf(e.name)||n.isDisposed||!0===e.sourceLayer.stateful||f.push(n))}m&&((n=n||{}).mask=c[0]);const g=Nm(i.apply(l,n));let b=null;i.supportsMasking&&(b=i.computeMask(l,c));const y=vb(a),x=Array.isArray(y)?y:[y];for(let e=0;e<x.length;++e){p.hasKey(x[e])||p.add(x[e],g[e],Array.isArray(b)?b[0]:b);const t=o.indexOf(x[e].name);-1!==t&&(u[t]=g[e])}s||aa(f)}return p.disposeMasks(),a?u:u[0]}function xb(e){const t={};for(const n in e)t[n]=e[n].size;return t}function wb(e,t){const n=new Set,r=[],s={};for(const e of t.names())n.add(e);const a=[],i=[];for(a.push(e);a.length>0;){const e=a[a.length-1];if(n.has(e.name)){a.pop();continue}const t=i[i.length-1]===a.length-1;if(0===e.inputs.length||t)a.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(a.length-1);for(const t of e.inputs)null==s[t.name]&&(s[t.name]=new Set),s[t.name].add(e.name),n.has(t.name)||a.push(t)}}return{sorted:r,recipientMap:s}}function vb(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function _b(e,t){return sa(()=>yi(ll(bi(e,e),t,!0)))}pe().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function(e){null!=gb&&gb.setMaxEntries(e),null!=bb&&bb.setMaxEntries(e)});class kb extends Si{getConfig(){return{}}}class Tb extends kb{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return sa(()=>{const t=_b(e,this.axis),n=Tu(t,0,this.maxValue);return bi(e,gi(n,fi(pg(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Tb.className="MaxNorm",Ni(Tb);class Sb extends kb{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return sa(()=>gi(e,fi(pg(),_b(e,this.axis))))}getConfig(){return{axis:this.axis}}}Sb.className="UnitNorm",Ni(Sb);class Ib extends kb{apply(e){return Rc(e)}}Ib.className="NonNeg",Ni(Ib);class Nb extends kb{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return sa(()=>{const t=_b(e,this.axis),n=fi(bi(this.rate,Tu(t,this.minValue,this.maxValue)),bi(1-this.rate,t));return bi(e,gi(n,fi(pg(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Nb.className="MinMaxNorm",Ni(Nb);const Eb={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function $b(e){return Cm(e)}function Ab(e,t={}){return Rm(e,Ii.getMap().classNameMap,t,"constraint")}function Cb(e){return null==e?null:"string"==typeof e?Ab({className:e in Eb?Eb[e]:e,config:{}}):e instanceof kb?e:Ab(e)}async function Ob(e){if(null==e)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if("number"!=typeof a){const e=a;t.push(e.data()),n.push(s),r.push(e)}}if(t.length>0){const s=await Promise.all(t);for(let t=0;t<s.length;++t)e[n[t]]=s[t][0];aa(r)}}function Rb(e){if(null!=e)for(const t in e){const n=e[t];"number"!=typeof n&&n.dispose()}}var Db;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(Db||(Db={}));class Fb{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Pb{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Mb extends Fb{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const e in t){const r=t[e];if("number"==typeof r)this.totals.hasOwnProperty(e)||(this.totals[e]=0),this.totals[e]=this.totals[e]+r*n;else{let t;e in this.totals?t=this.totals[e]:this.totals[e]=0;const s=sa(()=>fi(this.totals[e],bi(r,n)));this.totals[e]=s,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const e of this.params.metrics)null!=this.totals[e]&&("number"==typeof this.totals[e]?t[e]=this.totals[e]/this.seen:sa(()=>{const n=bi(gi(1,this.seen),this.totals[e]);t[e]=n,this.totals[e].dispose(),ia(t[e])}))}}class Lb extends Fb{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const e in t)null==this.history[e]&&(this.history[e]=[]),this.history[e].push(t[e])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const s=this.history[r];for(let a=0;a<s.length;++a)if("number"!=typeof s[a]){const i=s[a];e.push(i.data()),t.push(r),n.push(a)}}const r=await Promise.all(e);for(let e=0;e<r.length;++e)this.history[t[e]][n[e]].dispose(),this.history[t[e]][n[e]]=r[e][0]}}class zb extends Fb{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Kd,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Y(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,s=null!=n?n():ts();return(...a)=>{const i=null!=n?n():ts();return i-s<t||(s=i,r=e(...a)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await Ob(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await Ob(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await Ob(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await Ob(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await Ob(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):Y(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await Ob(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await Ob(e),await this.trainEnd(e))}}function Bb(e,t){return null==e&&(e={}),e instanceof Fb?[e]:Array.isArray(e)&&e[0]instanceof Fb?e:Nm(e).map(e=>new zb(e,t))}class Ub{constructor(){}static registerCallbackConstructor(e,t){R(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Ub.checkForDuplicate(t),null==Ub.constructors[e]&&(Ub.constructors[e]=[]),Ub.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Ub.constructors)Ub.constructors[+t].forEach(t=>{if(t===e)throw new xm("Duplicate callback constructor.")})}static clear(){Ub.constructors={}}static createCallbacks(e){const t=[];for(const n in Ub.constructors){const r=+n;e>=r&&t.push(...Ub.constructors[r])}return t.map(e=>new e)}}function Vb(e,t,n,r,s,a,i,o,u){const l=new Lb,c=[new Mb,...Ub.createCallbacks(t)];null!=e&&c.push(...e),c.push(l);const h=new Pb(c);return h.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:u}),{callbackList:h,history:l}}function Wb(e,t={},n=!1){return Rm(e,Ii.getMap().classNameMap,t,"layer",n)}function jb(e,t){return sa(()=>{"float32"!==e.dtype&&(e=hi(e,"float32"));const n=ll(Sg(e),t,!0),r=Ai(n.shape,pg()),s=yi(zi(n,r));return gi(e,s)})}function Gb(e,t){return sa(()=>Kl(Sg(Ri(t,e)),-1))}function Hb(e,t){return sa(()=>Kl(Fi(Ri(t,e)),-1))}function qb(e,t){return sa(()=>{const n=Ri(e,t),r=Tu(Fi(e),pg(),Number.MAX_VALUE),s=Fi(gi(n,r));return bi(100,Kl(s,-1))})}function Kb(e,t,n=!1){return sa(()=>{if(n)t=Jc(t);else{const e=ll(t,t.shape.length-1,!0);t=gi(t,e)}return t=Tu(t,pg(),1-pg()),Rl(ll(bi(hi(e,"float32"),Cl(t)),t.shape.length-1))})}function Xb(e,t,n=!1){return sa(()=>{const r=hi(yl(function(e){const t=[ug(e.shape)];return au(e,t)}(e)),"int32"),s=(t=Tu(t,pg(),1-pg())).shape;return Kb(au(ac(r,s[s.length-1]),s),t,n)})}function Yb(e,t){return sa(()=>{let n;return n=Tu(t,pg(),1-pg()),n=Cl(gi(n,Ri(1,n))),Kl(function(e,t){if(!M(e.shape,t.shape))throw new xm(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return sa(()=>{const n=Rc(t),r=Rl(Fi(t));return fi(Ri(n,bi(t,e)),Ol(pl(r)))})}(e,n),-1)})}function Zb(e,t){return sa(()=>{const n=jb(e,-1),r=jb(t,-1),s=bi(n,r);return Rl(ll(s,-1))})}Ub.constructors={};const Jb={meanSquaredError:Gb,meanAbsoluteError:Hb,meanAbsolutePercentageError:qb,meanSquaredLogarithmicError:function(e,t){return sa(()=>{const n=Tu(t,pg(),Number.MAX_VALUE),r=Cl(fi(1,n)),s=Tu(e,pg(),Number.MAX_VALUE),a=Cl(fi(1,s));return Kl(Sg(Ri(r,a)),-1)})},squaredHinge:function(e,t){return sa(()=>{const n=zi(0,Ri(1,bi(e,t)));return Kl(Sg(n),-1)})},hinge:function(e,t){return sa(()=>{const n=zi(0,Ri(1,bi(e,t)));return Kl(n,-1)})},categoricalHinge:function(e,t){return sa(()=>{const n=ll(bi(e,t),-1),r=ol(bi(Ri(1,e),t),-1);return zi(0,fi(1,Ri(r,n)))})},logcosh:function(e,t){return sa(()=>{const n=Math.log(2),r=Ri(t,e),s=Ri(fi(r,Dl(bi(-2,r))),n);return Kl(s,-1)})},categoricalCrossentropy:Kb,sparseCategoricalCrossentropy:Xb,binaryCrossentropy:Yb,kullbackLeiblerDivergence:function(e,t){return sa(()=>{const n=Tu(e,pg(),1),r=Tu(t,pg(),1);return ll(bi(e,Cl(gi(n,r))),-1)})},poisson:function(e,t){return sa(()=>{const n=Cl(fi(pg(),t));return Kl(Ri(t,bi(e,n)),-1)})},cosineProximity:Zb};function Qb(e){if("string"==typeof e){if(e in Jb)return Jb[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new xm(t)}return e}function ey(e,t){return sa(()=>{const n=bi(.5,ic(t)),r=fg(wl(t,n),e.dtype);return Kl(Gu(e,r),-1)})}function ty(e,t){return sa(()=>fg(Gu(Mo(e,-1),Mo(t,-1)),"float32"))}function ny(e,t){return Yb(e,t)}function ry(e,t){return e.rank===t.rank&&(e=ah(e,[e.rank-1])),(t=Mo(t,-1)).dtype!==e.dtype&&(t=hi(t,e.dtype)),hi(Gu(e,t),"float32")}const sy=Kb,ay=Xb,iy={binaryAccuracy:ey,categoricalAccuracy:ty,precision:function(e,t){return sa(()=>{const n=function(e,t){return sa(()=>hi(ll(Ll(Gu(e,1),Gu(t,1))),"float32"))}(e,t),r=function(e,t){return sa(()=>hi(ll(Ll(Gu(e,0),Gu(t,1))),"float32"))}(e,t),s=fi(n,r);return hi(Hu(wl(s,0),gi(n,s),0),"float32")})},categoricalCrossentropy:sy,sparseCategoricalCrossentropy:ay,mse:Gb,MSE:Gb,mae:Hb,MAE:Hb,mape:qb,MAPE:qb,cosine:Zb};function oy(e){if("string"==typeof e&&e in iy)return iy[e];if("string"!=typeof e&&null!=e)return e;throw new xm(`Unknown metric ${e}`)}function uy(e){if(Tm(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(const n of Object.keys(Jb))if(Jb[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(iy))if(iy[n]===e){t=n;break}return void 0!==t?t:e.name}}function ly(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!cy(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function cy(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!=typeof n)return!1;if(!cy(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!cy(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function hy(e,t,n=console.log){let r="";for(let n=0;n<e.length;++n)n>0&&(r=r.slice(0,r.length-1)+" "),r+=e[n],r=r.slice(0,t[n]),r+=" ".repeat(t[n]-r.length);n(r)}function dy(e,t,n){let r,s;try{s=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(e){s="multiple"}try{r=JSON.stringify(e.outputShape)}catch(e){r="multiple"}hy([`${e.name} (${e.getClassName()})`,s,r,e.countParams().toString()],t,n)}function py(e,t,n,r){let s,a;try{a=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(e){a="multiple"}try{s=JSON.stringify(e.outputShape)}catch(e){s="multiple"}const i=[];for(const t of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(t)))for(let e=0;e<t.inboundLayers.length;++e){const n=t.inboundLayers[e].name,r=t.nodeIndices[e],s=t.tensorIndices[e];i.push(`${n}[${r}][${s}]`)}const o=e.name,u=e.getClassName(),l=0===i.length?"":i[0];hy([`${o} (${u})`,a,s,e.countParams().toString(),l],t,r);for(let e=1;e<i.length;++e)hy(["","","","",i[e]],t,r)}function fy(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function my(e,t){if(null===e)return null;if("string"==typeof e)return $m(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];fy(t,s,r)?n.push(r):n.push(my(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{const e=$m(n);t[e]=my(r,e)}}return t}}function gy(e,t){if(null==e)return null;if("string"==typeof e)return Em(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];fy(t,s,r)?n.push(r):n.push(gy(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];t[Em(n)]="name"!==n&&"className"!==n||"string"!=typeof r?gy(r,n):r}return t}}const by="4.22.0";class yy extends db{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=Gm(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Fm(this.inputs).length!==this.inputs.length)throw new xm(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(e=>e.name)}`);Fm(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(e=>e.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const e of this.outputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(const e of this.inputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;Tm(0===n,"input layer has >1 nodes"),Tm(0===r,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let t=0;t<this.inputLayers.length;t++){const n=this.inputLayers[t];if(!(n instanceof fb))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${t} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(const e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map(e=>e.shape),this.internalOutputShapes=this.outputs.map(e=>e.shape);const t={},n={},r={},s={},a={},i=[],o=(e,t,n,r,s,u)=>{null!=r&&null!=s&&null!=u||(r=e.sourceLayer,s=e.nodeIndex,u=e.tensorIndex);const l=r.inboundNodes[s];if(-1!==n.indexOf(l))throw new ym(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(l))return;this.containerNodes.add(yy.nodeKey(r,s)),r.id in a||(a[r.id]=Object.keys(a).length),-1===n.indexOf(l)&&n.push(l);const c=l.inboundLayers.length;for(let e=0;e<c;e++){const r=l.inputTensors[e],s=l.inboundLayers[e],a=l.nodeIndices[e],i=l.tensorIndices[e];o(r,t,n,s,a,i)}for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);i.push(l)},u=[],l=[];for(const e of this.outputs)o(e,u,l);const c=i.slice().reverse();for(const e of c){n[e.id]=e,e.id in t||(t[e.id]=0);let a=t[e.id];const i=null==r[e.outboundLayer.id]?0:r[e.outboundLayer.id];a=Math.max(a,i),r[e.outboundLayer.id]=a,s[e.outboundLayer.id]=e.outboundLayer,t[e.id]=a;for(let r=0;r<e.inboundLayers.length;r++){const s=e.inboundLayers[r],i=e.nodeIndices[r],o=s.inboundNodes[i],u=null==t[o.id]?0:t[o.id];t[o.id]=Math.max(a+1,u),n[o.id]=o}}const h={};for(const e in t){const r=t[e];r in h||(h[r]=[]),h[r].push(n[e])}const d={};for(const e in r){const t=r[e];t in d||(d[t]=[]),d[t].push(s[e])}let p=Object.keys(d).map(e=>parseInt(e,10)).sort(Dm);this.layers=[];for(const e of p){const t=d[e];t.sort((e,t)=>{const n=a[e.id],r=a[t.id];return n<r?-1:n>r?1:0});for(const e of t)e instanceof yy&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=d,p=Object.keys(h).map(e=>parseInt(e,10)).sort(Dm);const f=this.inputs.slice(),m=[];for(const e of p)for(const t of h[e]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new ym(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${m}`);for(const e of t.outputTensors)f.push(e);m.push(e.name)}}this.nodesByDepth=h;const g=this.layers.map(e=>e.name);for(const e of g){const t=g.filter(t=>t===e).length;if(1!==t)throw new ym(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new cb({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(e=>null),outputMasks:this.outputs.map(e=>null),inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs.map(e=>e.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(t=>t.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new xm("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let r=0;const s=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);s&&this.parseWeights(e);for(const e of this.layers)for(const[t,a]of e.weights.entries()){const e=s?`${a.name.split("/").slice(0,-1).join("/")+"/"}${t}`:a.originalName;if(null!=n[e])throw new xm(`Duplicate weight name: ${e}`);n[e]=a,r++}const a=[];for(const r in e){let s=r;if(null==n[r]){const e=r.split("/");s=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[s])a.push([n[s],e[r]]);else if(t)throw new xm(`Provided weight data has no target variable: ${r}`);delete n[s]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new xm(`${e.length} of ${r} weights are not set: ${e}`)}ib(a)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],s=n.map(e=>e.startsWith("_")?e.slice(1):e).filter(e=>!r.includes(e)).join("/");s!==t&&(e[s]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${by}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=gy(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return sa(()=>{e=Nm(e);const n=new mb;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return yb(this.outputs,n,t)})}computeMask(e,t){return sa(()=>{let n;return e=Nm(e),n=null==t?km(null,e.length):Nm(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){const t=Qg(e);if(t.length!==this.inputLayers.length)throw new xm(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let e=0;e<t.length;e++){const r=this.inputLayers[e],s=t[e];n[r.name+"_0_0"]=s}const r=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(Dm);if(r.length>1)for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map(e=>e.id).indexOf(t.id))continue;const r=[];for(let t=0;t<e.inboundLayers.length;t++){const s=e.inboundLayers[t],a=e.nodeIndices[t],i=e.tensorIndices[t],o=n[`${s.name}_${a}_${i}`];r.push(o)}const s=Qg(t.computeOutputShape(Im(r))),a=t.inboundNodes.indexOf(e);for(let e=0;e<s.length;e++)n[`${t.name}_${a}_${e}`]=s[e]}}const s=[],a=[];for(let e=0;e<this.outputLayers.length;e++){const t=this.outputLayers[e],n=this.outputLayersNodeIndices[e],r=this.outputLayersTensorIndices[e],s=`${t.name}_${n}_${r}`;a.push(s)}for(let e=0;e<a.length;e++){const t=a[e];Tm(t in n),s.push(n[t])}return Im(s)}runInternalGraph(e,t){null==t&&(t=km(null,e.length));const n={};for(let r=0;r<this.inputs.length;++r){const s=this.inputs[r],a=e[r],i=t[r];n[s.id]=[a,i]}const r=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(Dm);for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,s=e.outputTensors,a=new Array;for(const e of r)e.id in n&&a.push(n[e.id]);if(a.length===r.length){let r,i,o,u,l={};if(null!=e.callArgs&&(l=e.callArgs),1===a.length){const[e,n]=a[0];null==l.mask&&(l.mask=n),o=Nm(t.call(e,l)),u=Nm(t.computeMask(e,n)),r=[e],i=[n]}else r=a.map(e=>e[0]),i=a.map(e=>e[1]),null==l.mask&&(l.mask=i),o=Nm(t.call(r,l)),u=Nm(t.computeMask(r,i));if(t.activityRegularizer)throw new wm("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<s.length;++e){const t=s[e],r=o[e],a=u[e];n[t.id]=[r,a]}}}}const s=[],a=[],i=[];for(const e of this.outputs){Tm(e.id in n,`Could not compute output ${e.name} : ${e.id}`);const[t,r]=n[e.id];i.push(t.shape),s.push(t),a.push(r)}return[s,a,i]}buildNodeConversionMap(e){const t={};let n;for(const e of this.layers){n=e instanceof yy?1:0;for(let r=0;r<e.inboundNodes.length;r++){const s=yy.nodeKey(e,r);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new xm("Provide either a layer name or layer index");if("number"==typeof e)return this.findLayer(e);for(const t of this.layers)if(t.name===e)return t;throw new xm(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new xm(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return sa(()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=yy.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const e of this.layers){const r=e.getClassName(),s=e.getConfig(),a=[];for(let n=0;n<e.inboundNodes.length;n++){const r=e.inboundNodes[n],s=yy.nodeKey(e,n);let i={};if(this.containerNodes.has(s)){if(r.callArgs)try{JSON.stringify(r.callArgs),i=r.callArgs}catch(t){console.warn(`Layer ${e.name} was passed non-serializable keyword arguments: ${r.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(r.inboundLayers.length>0){const e=[];for(let n=0;n<r.inboundLayers.length;n++){const s=r.inboundLayers[n],a=r.nodeIndices[n],o=r.tensorIndices[n];let u=t[yy.nodeKey(s,a)];null==u&&(u=0),e.push([s.name,u,o,i])}a.push(e)}}}const i={};i.name=e.name,i.className=r,i.config=s,i.inboundNodes=a,n.push(i)}e.layers=n;const r=[];for(let e=0;e<this.inputLayers.length;e++){const n=this.inputLayers[e],s=this.inputLayersNodeIndices[e],a=yy.nodeKey(n,s);if(!this.containerNodes.has(a))continue;let i=t[a];null==i&&(i=0);const o=this.inputLayersTensorIndices[e];r.push([n.name,i,o])}e.inputLayers=r;const s=[];for(let e=0;e<this.outputLayers.length;e++){const n=this.outputLayers[e],r=this.outputLayersNodeIndices[e],a=yy.nodeKey(n,r);if(!this.containerNodes.has(a))continue;let i=t[a];null==i&&(i=0);const o=this.outputLayersTensorIndices[e];s.push([n.name,i,o])}return e.outputLayers=s,e}static fromConfig(e,t,n={},r=!1){const s={},a={};function i(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function o(e,t){const n=[];let r;for(const a of t){const o=a[0],u=a[1],l=a[2];if(r=null==a[3]?{}:a[3],!(o in s))return void i(e,t);const c=s[o];if(c.inboundNodes.length<=u)return void i(e,t);const h=c.inboundNodes[u];n.push(h.outputTensors[l])}n.length>0&&e.apply(Im(n),r)}function u(e){const n=e.name,a=Wb(e,null!=t.customObjects?t.customObjects:{});a.setFastWeightInitDuringBuild(r),s[n]=a,e.inboundNodes.forEach(e=>{if(!(e instanceof Array))throw new xm(`Corrupted configuration, expected array for nodeData: ${e}`);i(a,e)})}const l=t.name,c=t.layers;for(const e of c)u(e);for(;!Pm(a);)for(const e of c){const t=s[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)o(t,n)}}const h=[],d=[],p=t.inputLayers;for(const e of p){const t=e[0],n=e[1],r=e[2];Tm(t in s);const a=s[t].inboundNodes[n].outputTensors;h.push(a[r])}const f=t.outputLayers;for(const e of f){const t=e[0],n=e[1],r=e[2];Tm(t in s);const a=s[t].inboundNodes[n].outputTensors;d.push(a[r])}return new e({inputs:h,outputs:d,name:l})}get stateful(){if(this._stateful)throw new xm("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){sa(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function xy(e,t){return function(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>null);if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const n=[];return t.forEach(t=>{t in e?n.push(e[t]):n.push(null)}),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}(e,t,"classWeight")}async function wy(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=sa(()=>{if(1===e.shape.length)return di(e);if(2===e.shape.length){if(e.shape[1]>1)return Mo(e,1);if(1===e.shape[1])return au(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(await t.data());aa(t);const s=[];return r.forEach(e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);s.push(n[e])}),ch(s,"float32")}return null}function vy(e,t){return bi(e,t)}function _y(e,t){let n,r;const s=t;n=s.xs,r=s.ys,R(null!=n&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const a=ky("input",e.inputNames,n),i=ky("output",e.outputNames,r),o=a[0].shape[0];R(a.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),R(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let t=0;t<a.length;t++)R(a[t].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[t]} has ${a[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let t=0;t<i.length;t++)R(i[t].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[t]} has ${i[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:a,ys:i}}function ky(e,t,n){if(n instanceof ys)return[n];if(Array.isArray(n))return R(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{const r=[];for(const s of t){if(null==n[s])throw new xm(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function Ty(e){return"function"==typeof e.iterator}function Sy(e){R(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Iy(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(e=>gg(e,t,n-t)):gg(e,t,n-t)}function Ny(e,t){return sa(()=>null==e?null:Array.isArray(e)?e.map(e=>Ny(e,t)):Tg(e,"int32"===t.dtype?t:hi(t,"int32")))}function Ey(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function $y(e){const t=[];e instanceof ys&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(mg(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Ay(e,t){if(null==e)return;const n=[];if(t instanceof ys)n.push(t.id);else if(Array.isArray(t))t.forEach(e=>n.push(e.id));else if(null!=t)for(const e in t){const r=t[e];n.push(r.id)}const r=[];if(e instanceof ys)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach(e=>{-1===n.indexOf(e.id)&&r.push(e)});else if(null!=e)for(const t in e){const s=e[t];-1===n.indexOf(s.id)&&r.push(s)}r.forEach(e=>{e.isDisposed||e.dispose()})}function Cy(e){return Array.isArray(e)}function Oy(e){return!function(e){return e instanceof ys}(e)&&!Cy(e)}function Ry(e,t,n,r=!0,s=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(Cy(e)&&e.length>0)t=!0;else if(Oy(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new xm(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map(e=>null);let a;if(Oy(e)){a=[];for(const n of t){if(null==e[n])throw new xm(`No data provided for "${n}". Need data for each key in: ${t}`);a.push(e[n])}}else if(Cy(e)){if(e.length!==t.length)throw new xm(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(t.length>1)throw new xm(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=$y(a),null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const i=a[e];if(i.shape.length!==n[e].length)throw new xm(`Error when checking ${s}: expected ${t[e]} to have ${n[e].length} dimension(s). but got array with shape ${i.shape}`);for(let t=0;t<n[e].length;++t){if(0===t&&!r)continue;const a=i.shape[t],o=n[e][t];if(null!=o&&o>=0&&a!==o)throw new xm(`${s} expected a batch of elements where each example has shape [${n[e].slice(1,n[e].length)}] (i.e.,tensor shape [*,${n[e].slice(1,n[e].length)}]) but the ${s} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return a}function Dy(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new xm(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new xm(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const i=a[e];if(i.shape.length!==n[e].length)throw new xm(`Error when checking ${s}: expected ${t[e]} to have ${n[e].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let a=0;a<n[e].length;++a){if(0===a&&!r)continue;const o=i.shape[a],u=n[e][a];if(null!=u&&u!==o)throw new xm(`Error when checking ${s}: expected ${t[e]} to have shape ${JSON.stringify(n[e])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}class Fy extends yy{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new xm("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(e,t,n,r=console.log){const s=function(e){let t=!0;const n=[],r=[];for(const t in e.nodesByDepth)n.push(e.nodesByDepth[t]);for(const e of n){if(e.length>1||1===e.length&&e[0].inboundLayers.length>1){t=!1;break}r.push(...e)}if(t)for(const n of e.layers){let e=!1;for(const s of n.inboundNodes)if(-1!==r.indexOf(s)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),a=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(e=>Math.floor(t*e))),!s){a.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),hy(a,n,r),r("=".repeat(t));const o=e.layers;for(let e=0;e<o.length;++e)s?dy(o[e],n,r):py(o[e],n,i,r),r((e===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const u=function(e){let t;return t=null!=e.collectedTrainableWeights?nb(e.collectedTrainableWeights):nb(e.trainableWeights),t}(e),l=nb(e.nonTrainableWeights);r(`Total params: ${u+l}`),r(`Trainable params: ${u}`),r(`Non-trainable params: ${l}`),r("_".repeat(t))}(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>Hd.adagrad(.01),Adadelta:()=>Hd.adadelta(1,.95,pg()),Adam:()=>Hd.adam(.001,.9,.999,pg()),Adamax:()=>Hd.adamax(.002,.9,.999,pg(),0),RMSProp:()=>Hd.rmsprop(.001,.9,0,pg()),SGD:()=>Hd.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new xm(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Ei))throw new xm("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new xm(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map(e=>Qb(e))}else{const n=Qb(e.loss);this.outputs.forEach(e=>{t.push(n)})}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new xm(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(Qb(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let e=0;e<this.outputs.length;++e){const t=this.internalOutputShapes[e],n=this.outputNames[e];this.feedOutputNames.push(n),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[e])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ng("loss",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}});const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>[]);let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map(e=>n);{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),s=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};ng("metric",()=>{for(let e=0;e<this.outputs.length;++e)-1===n.indexOf(e)&&(t=>{let n,r,a;for(const i of t){if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let s;1===t[t.length-1]||this.lossFunctions[e]===Yb?-1!==["accuracy","acc"].indexOf(i)?r=ey:-1!==["crossentropy","ce"].indexOf(i)&&(r=ny):this.lossFunctions[e]===Xb?-1!==["accuracy","acc"].indexOf(i)?r=ry:-1!==["crossentropy","ce"].indexOf(i)&&(r=ay):-1!==["accuracy","acc"].indexOf(i)?r=ty:-1!==["crossentropy","ce"].indexOf(i)&&(r=sy),-1!==["accuracy","acc"].indexOf(i)?s="acc":-1!==["crossentropy","ce"].indexOf(i)&&(s="ce"),a=r,n=""+s}else{const e=oy(i);a=e,n=""+uy(i)}let t;ng(n,()=>{t=a}),s(e,n,t)}})(r[e])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const r=null==n.batchSize?32:n.batchSize;Sy(r);const s=this.standardizeUserDataXY(e,t,!0,r);try{const e=s[0].concat(s[1]);this.makeTestFunction();const t=this.testFunction;return Im(this.testLoop(t,e,r,n.verbose,n.steps))}finally{Ay(s[0],e),Ay(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,s=e.testFunction;let a=[];if(n.verbose>0)throw new wm("Verbose mode is not implemented yet.");R(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const i="function"==typeof t.next?t:await t.iterator();let o=0,u=0;for(;!r||u<n.batches;){const t=await i.next();if(a=sa(()=>{if(t.value){const{xs:n,ys:r}=_y(e,t.value),i=n.concat(r),l=sa(()=>s(i));if(aa(i),0===u)for(let e=0;e<l.length;++e)a.push(_i(0));const c=i[0].shape[0];for(let e=0;e<l.length;++e){const t=l[e],n=a[e];a[e]=sa(()=>fi(a[e],bi(c,t))),u>0&&aa(n)}aa(l),o+=c,++u}return a}),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let e=0;e<a.length;++e){const t=a[e];a[e]=gi(a[e],o),aa(t)}return Im(a)}(this,e,t)}checkNumSamples(e,t,n,r="steps"){let s;if(null!=n){if(s=null,null!=t)throw new xm(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new xm(`Either the input data should have a defined shape, or ${r} shoud be specified.`);s=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return s}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new xm("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new mb;if(e instanceof ys&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new xm(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)a.add(this.inputs[t],e[t])}else for(const t of this.inputs){const n=e[t.name];if(null==n)throw new xm(`No value is provided for the model's input ${t.name}`);a.add(t,n)}const i=yb(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){const t=km(null,e.length);let n=e.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],a=s.map(e=>e.name);for(let r=0;r<e.length;++r){const i=a.indexOf(e[r]);if(-1!==i&&(t[r]=s[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach((t,r)=>{null==t&&n.push(e[r])}),new xm(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return sa(()=>{const r=this.checkNumSamples(e);if(n)throw new wm("Verbose predictLoop() is not implemented yet.");const s=Ey(r,t),a=this.outputs.map(e=>[]);for(let t=0;t<s.length;++t)sa(()=>{const n=s[t][0],r=s[t][1],a=Iy(e,n,r),i=[];if(Array.isArray(a))for(let e=0;e<a.length;++e)i.push({key:this.inputs[e],value:a[e]});else i.push({key:this.inputs[0],value:a});const o=new mb(i);return yb(this.outputs,o)}).forEach((e,t)=>a[t].push(e));return Im(a.map(e=>uu(e,0)))})}predict(e,t={}){const n=$y(e);Dy(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return Sy(e),this.predictLoop(n,e)}finally{Ay(n,e)}}predictOnBatch(e){Dy(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new ym("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let e=0;e<this.feedOutputShapes.length;++e){const t=this.feedOutputShapes[e];this.feedLossFns[e]===Xb?s.push(t.slice(0,t.length-1).concat([1])):s.push(t)}if(function(e,t){const n=Fm(e.map(e=>e.shape[0]));n.sort();const r=Fm(t.map(e=>e.shape[0]));if(r.sort(),n.length>1)throw new xm(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(e=>e.shape))}`);if(r.length>1)throw new xm(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(e=>e.shape))}`);if(n.length>0&&r.length>0&&!M(n,r))throw new xm(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=Ry(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Ry(t,this.feedOutputNames,s,!1,"target")),function(e,t,n){const r=[Gb,Yb,Kb];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],o=n[s];if(null!=i){if(i===Kb&&1===a.shape[a.shape.length-1])throw new xm(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=a.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],s=t[n];if(null!=s&&r!==s)throw new xm(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!==0)throw new xm(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,s=!0,a){const[i,o]=this.standardizeUserDataXY(e,t,s,a);if(null!=n)throw new Error("sample weight is not supported yet.");let u=null;if(null!=r){const e=xy(r,this.outputNames);u=[];for(let t=0;t<e.length;++t)u.push(await wy(o[t],null,e[t]))}return[i,o,u]}testLoop(e,t,n,r=0,s){return sa(()=>{const a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new wm("Verbose mode is not implemented yet.");if(null!=s)throw new wm("steps mode in testLoop() is not implemented yet");{const r=Ey(a,n),s=ch(hg(0,a));for(let n=0;n<r.length;++n){const a=r[n][0],o=r[n][1],u=gg(s,a,o-a),l=Ny(t,u),c=e(l);if(0===n)for(let e=0;e<c.length;++e)i.push(_i(0));for(let e=0;e<c.length;++e){const t=c[e];i[e]=fi(i[e],bi(o-a,t))}}for(let e=0;e<i.length;++e)i[e]=gi(i[e],a)}return i})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let s=r;Sm(e,r)>1&&(s+=`_${Sm(e.slice(0,n),r)}`),t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],i=this.collectedTrainableWeights.map(e=>e.read());return[this.optimizer_.minimize(()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new mb(e),o=yb(this.outputs,i,{training:!0});let u;for(let e=0;e<this.lossFunctions.length;++e){let n=(0,this.lossFunctions[e])(r[e],o[e]);null!=s[e]&&(n=vy(n,s[e]));const a=Kl(n);t.push(a),u=0===e?n:fi(u,n)}for(let e=0;e<this.metricsTensors.length;++e){let n;if(this.outputs.length>1&&e<this.outputs.length)n=t[e];else{const t=this.metricsTensors[e][0],s=this.metricsTensors[e][1];n=Kl(t(r[s],o[s]))}ia(n),a.push(n)}return u=Kl(u),this.calculateLosses().forEach(e=>{u=fi(u,e)}),u},!0,i)].concat(a)}}makeTestFunction(){this.testFunction=e=>sa(()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let e=0;e<this.inputs.length;++e)a.push({key:this.inputs[e],value:r[e]});const i=new mb(a),o=yb(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],a=Kl(r(s[e],o[e]));n=0===e?a:fi(n,a),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],a=Kl(n(s[r],o[r]));t.push(a)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let r,s,a,i,o,u,l,c,h;this.isTraining=!0;try{const d=null==n.batchSize?32:n.batchSize;Sy(d);const p=!1,f=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,p,d);r=f[0],s=f[1],h=f[2];let m,g=!1;if(null!=n.validationData&&n.validationData.length>0){if(g=!0,2!==n.validationData.length)throw 3===n.validationData.length?new wm("validationData including sample weights is not supported yet."):new xm(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);o=n.validationData[0],u=n.validationData[1];const e=!0,t=await this.standardizeUserData(o,u,null,null,e,d);l=t[0],c=t[1],m=l.concat(c)}else if(null!=n.validationSplit&&n.validationSplit>0&&n.validationSplit<1){g=!0;const e=Math.floor(r[0].shape[0]*(1-n.validationSplit)),t=r[0].shape[0];l=Iy(r,e,t),a=r,r=Iy(r,0,e),c=Iy(s,e,t),i=s,s=Iy(s,0,e),m=l.concat(c)}else null!=n.validationSteps&&(g=!0);const b=r.concat(s).concat(h);this.checkTrainableWeightsConsistency();const y=this.makeTrainFunction(),x=this.getDedupedMetricsNames();let w,v;g?(this.makeTestFunction(),w=this.testFunction,v=x.slice().concat(x.map(e=>"val_"+e))):(w=null,m=[],v=x.slice());const _=Bb(n.callbacks,n.yieldEvery);return await this.fitLoop(y,b,x,d,n.epochs,n.verbose,_,w,m,n.shuffle,v,n.initialEpoch,null,null)}finally{this.isTraining=!1,Ay(r,e),Ay(s,t),Ay(a,e),Ay(i,t),Ay(l,o),Ay(c,u),null!=h&&aa(h)}}async fitLoop(e,t,n,r,s,a,i,o,u,l,c,h,d,p){null==r&&(r=32),null==s&&(s=1),null==l&&(l=!0),null==h&&(h=0);let f=!1;if(null!=o&&null!=u&&(f=!0),null!=p&&(f=!0,null==d))throw new xm("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,r,d,"steps_per_epoch");let g;null!=m&&(g=hg(0,m)),null==a&&(a=1);const{callbackList:b,history:y}=Vb(i,a,s,h,m,d,r,f,c);b.setModel(this),this.history=y,await b.onTrainBegin(),this.stopTraining_=!1;for(let a=h;a<s;++a){await b.onEpochBegin(a);const s={};if(null!=d)throw new wm("stepsPerEpoch mode is not implemented yet.");{if("batch"===l)throw new wm("batch shuffling is not implemneted yet");l&&$(g);const a=ch(g),i=Ey(m,r);for(let l=0;l<i.length;++l){const c={};if(await b.onBatchBegin(l,c),sa(()=>{const h=i[l][0],d=i[l][1],p=gg(a,h,d-h);c.batch=l,c.size=d-h;const m=Ny(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],r=g[e];c[t]=r,ia(r)}if(l===i.length-1&&f){const e=this.testLoop(o,u,r);for(let t=0;t<n.length;++t){const r=n[t],a=e[t];ia(a),s["val_"+r]=a}}}),await b.onBatchEnd(l,c),Rb(c),this.stopTraining_)break}a.dispose()}if(await b.onEpochEnd(a,s),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return async function(e,t,n){const r=null!=n.batchesPerEpoch;if(R(null!=e.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),R(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),R(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),R(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),R(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=n.validationData;let a,i;if(s)if(Ty(n.validationData))R(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const e=function(e){if(3===e.length)throw new wm("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,i=e.ys}const o=e.makeTrainFunction(),u=e.getDedupedMetricsNames();let l;l=s?u.slice().concat(u.map(e=>"val_"+e)):u.slice();const c=Bb(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=Vb(c,h,n.epochs,null,null,function(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}(t,n),null,s,l);d.setModel(e),e.history=p,await d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const l={};await d.onEpochBegin(f);let c=0,h=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){const t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:s}=_y(e,t.value),a={};a.batch=h,a.size=r[0].shape[0],await d.onBatchBegin(h,a);const i=[];if(null!=n.classWeight){const t=xy(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await wy(s[e],null,t[e]))}const l=r.concat(s).concat(i),p=o(l);aa(l);for(let e=0;e<u.length;++e){const t=u[e],n=p[e];a[t]=n,ia(n)}await d.onBatchEnd(h,a),Rb(a),h++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(s){let t;t=Ty(n.validationData)?Nm(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):Nm(e.evaluate(a,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)l[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,l),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction()(r.concat(s)),i=[];for(const e of a){const t=await e.data();i.push(t[0])}return aa(a),Ay(n[0],e),Ay(n[1],t),Im(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let e=0;e<r.length;++e)n&&!r[e].trainable||t.push({name:r[e].originalName,tensor:s[e]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=ra().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-ra().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=Em(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(e=>Em(e))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=Em(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Em(uy(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Em(uy(e)));{const e={};for(const t in this.metrics)e[t]=Em(uy(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Wb(my(e.optimizer_config));let n,r;if("string"==typeof e.loss)n=$m(e.loss);else if(Array.isArray(e.loss))n=e.loss.map(e=>$m(e));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=$m(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map(e=>$m(e));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=$m(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"==typeof e){const t=Ca(e);if(0===t.length)throw new xm(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new xm(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new xm("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await ha(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${by}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:s}=await ha(await this.optimizer.getWeights(),e);n.specs.push(...s),n.data=va([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;ly(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){ly(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Fy.className="Model",Ni(Fy);class Py extends Fy{}Py.className="Functional",Ni(Py);class My extends Fy{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Gm("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new xm(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof My||e instanceof Fy;let n;if(t){if(n=e,1!==n.outputs.length)throw new xm("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new xm("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new xm("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new xm("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new fb({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new xm(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new xm("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=pb(this.outputs[0])}this.inboundNodes=[],new cb({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:km(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(tb(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Fy({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new ym("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new ym("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new ym("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new ym("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let s,a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new xm("Legacy serialization format not supported yet.");s=t}else R(null!=t.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=t.layers,delete t.layers,a=t;const i=new e(a);if(!(i instanceof My))throw new wm(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(const e of s){const t=Wb(e,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),i.add(t)}return i}set stopTraining(e){if(null==this.model)throw new xm("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new xm("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}My.className="Sequential",Ni(My);class Ly extends Si{getConfig(){return{}}}class zy extends Ly{apply(e,t=1){return function(e,t=1){if(1!==t)throw new wm(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Yu(e)}(e,t)}}zy.className="elu",Ni(zy);class By extends Ly{apply(e){return Vc(e)}}By.className="selu",Ni(By);class Uy extends Ly{apply(e){return Rc(e)}}Uy.className="relu",Ni(Uy);class Vy extends Ly{apply(e){return sa(()=>Jl(6,Rc(e)))}}Vy.className="relu6",Ni(Vy);class Wy extends Ly{apply(e){return e}}Wy.className="linear",Ni(Wy);class jy extends Ly{apply(e){return cu(e)}}jy.className="sigmoid",Ni(jy);class Gy extends Ly{apply(e){return function(e){return sa(()=>{const t=fi(.5,bi(.2,e));return Tu(t,0,1)})}(e)}}Gy.className="hardSigmoid",Ni(Gy);class Hy extends Ly{apply(e){return Dl(e)}}Hy.className="softplus",Ni(Hy);class qy extends Ly{apply(e){return function(e){return sa(()=>gi(e,fi(Fi(e),1)))}(e)}}qy.className="softsign",Ni(qy);class Ky extends Ly{apply(e){return du(e)}}Ky.className="tanh",Ni(Ky);class Xy extends Ly{apply(e,t=-1){return Jc(e,t)}}Xy.className="softmax",Ni(Xy);class Yy extends Ly{apply(e,t=-1){return Pl(e,t)}}Yy.className="logSoftmax",Ni(Yy);class Zy extends Ly{apply(e){return sa(()=>sa(()=>{const t=Math.sqrt(2),n=bi(.5,fi(1,Ju(gi(e,t))));return bi(e,n)}))}}Zy.className="gelu",Ni(Zy);class Jy extends Ly{apply(e){return sa(()=>bi(.5,bi(e,fi(1,du(bi(yi(gi(2,Math.PI)),fi(e,bi(.044715,Oi(e,3)))))))))}}Jy.className="gelu_new",Ni(Jy);class Qy extends Ly{apply(e){return sa(()=>bi(e,du(Dl(e))))}}Qy.className="mish",Ni(Qy);class ex extends Ly{apply(e,t=1){return sa(()=>bi(cu(bi(e,t)),e))}}function tx(e){return e.getClassName()}function nx(e,t={}){return Rm(e,Ii.getMap().classNameMap,t,"activation")}function rx(e){if(null==e){return nx({className:"linear",config:{}})}if("string"==typeof e){const t={};return t.className=e,t.config={},nx(t)}return e instanceof Ly?e:nx(e)}ex.className="swish",Ni(ex);class sx extends Si{}class ax extends sx{constructor(e){super(),function(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return sa(()=>{let t=Xl([1]);return this.hasL1&&(t=fi(t,ll(bi(this.l1,Fi(e))))),this.hasL2&&(t=fi(t,ll(bi(this.l2,Sg(e))))),au(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}ax.className="L1L2",Ni(ax);const ix={l1l2:"L1L2"};function ox(e){return Cm(e)}function ux(e,t={}){return Rm(e,Ii.getMap().classNameMap,t,"regularizer")}function lx(e){return null==e?null:"string"==typeof e?ux({className:e in ix?ix[e]:e,config:{}}):e instanceof sx?e:ux(e)}class cx extends db{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=eb(e);let n=Rc(e);return null!=this.maxValue&&(n=Tu(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}cx.className="ReLU",Ni(cx);class hx extends db{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=eb(e);return Il(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}hx.className="LeakyReLU",Ni(hx);class dx extends db{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Zg(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=lx(e.alphaRegularizer),this.alphaConstraint=Cb(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new xm(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=tb(e)).slice(1);if(null!=this.sharedAxes)for(const e of this.sharedAxes)t[e-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let t=1;t<e.length;++t)n[t]=e[t];this.inputSpec=[new ob({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=eb(e),mc(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Yg(this.alphaInitializer),alphaRegularizer:ox(this.alphaRegularizer),alphaConstraint:$b(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}dx.className="PReLU",Ni(dx);class px extends db{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new wm(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=eb(e);return Yu(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}px.className="ELU",Ni(px);class fx extends db{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=eb(e);return bi(n,hi(wl(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}fx.className="ThresholdedReLU",Ni(fx);class mx extends db{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new Xy).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return sa(()=>{let n=eb(e);const r=t.mask;if(null!=r){const e=bi(Ri(Yl(n.shape),hi(r,n.dtype)),_i(-1e9));n=fi(n,e)}return this.axis instanceof Array?this.axis.length>1?pl(Ri(n,Ml(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function gx(e,t,n){if("number"==typeof e)return km(e,t);if(e.length!==t)throw new xm(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){const s=e[r];if(!og(s))throw new xm(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function bx(e,t,n,r,s=1){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*(s-1))+1,Math.floor((a+r-1)/r)}function yx(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+cg([n-t,0]);else{if("same"!==r)throw new xm(`Unsupport padding mode: ${r}.`);e*=t}return e}function xx(e,t){return sa(()=>(Jm(t),"channelsFirst"===t?$h(e,[0,2,3,1]):e))}function wx(e,t){return sa(()=>(Jm(t),"channelsFirst"===t?$h(e,[0,2,3,4,1]):e))}function vx(e,t,n,r=[1,1],s="valid",a,i,o=null){return sa(()=>{if(null==a&&(a="channelsLast"),Jm(a),3!==e.rank&&4!==e.rank)throw new xm(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new xm(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let u=xx(e,a);if("causal"===s)throw new wm("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Wh({x:u,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===a&&(u=$h(u,[0,3,1,2])),u})}mx.className="Softmax",Ni(mx);class _x extends db{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",_x.verifyArgs(t),this.rank=e,zm(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new wm(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=gx(t.kernelSize,e,"kernelSize"),this.strides=gx(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,Qm(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Jm(this.dataFormat),this.activation=rx(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=Zg(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Cb(t.biasConstraint),this.biasRegularizer=lx(t.biasRegularizer),this.activityRegularizer=lx(t.activityRegularizer),this.dilationRate=gx(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new xm(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new xm(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new xm(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(Tm("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!Lm(e.kernelSize,"number",1,3))throw new xm(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:tx(this.activation),useBias:this.useBias,biasInitializer:Yg(this.biasInitializer),biasRegularizer:ox(this.biasRegularizer),activityRegularizer:ox(this.activityRegularizer),biasConstraint:$b(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class kx extends _x{constructor(e,t){super(e,t),this.kernel=null,kx.verifyArgs(t),this.filters=t.filters,zm(this.filters,"filters"),this.kernelInitializer=Zg(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Cb(t.kernelConstraint),this.kernelRegularizer=lx(t.kernelRegularizer)}build(e){e=tb(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new xm(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return sa(()=>{let t;e=eb(e);const n=null==this.bias?null:this.bias.read(),r=Um(this.activation.getClassName());if(null!=r&&2===this.rank)t=vx(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n,r=1,s="valid",a,i=1){return sa(()=>{if(null==a&&(a="channelsLast"),Jm(a),3!==e.shape.length)throw new xm(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new xm(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new xm(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===a&&(e=$h(e,[0,2,1])),"causal"===s)throw new wm("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Au(e,t,r,"same"===s?"same":"valid","NWC",i);return null!=n&&(o=Ng(o,n)),o})}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=vx(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new wm("convolutions greater than 3D are not implemented yet.");t=function(e,t,n,r=[1,1,1],s="valid",a,i){return sa(()=>{if(null==a&&(a="channelsLast"),Jm(a),4!==e.rank&&5!==e.rank)throw new xm(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new xm(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=wx(e,a);if("causal"===s)throw new wm("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Ru(o,t,r,"same"===s?"same":"valid","NDHWC",i),null!=n&&(o=Ng(o,n)),"channelsFirst"===a&&(o=$h(o,[0,4,1,2,3])),o})}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t})}computeOutputShape(e){e=tb(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let e=0;e<n.length;++e){const r=bx(n[e],this.kernelSize[e],this.padding,this.strides[e],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[e]);t.push(r)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Yg(this.kernelInitializer),kernelRegularizer:ox(this.kernelRegularizer),kernelConstraint:$b(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new xm(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Tx extends kx{constructor(e){super(2,e),Tx.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Lm(e.kernelSize,"number",1,2))throw new xm(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Tx.className="Conv2D",Ni(Tx);class Sx extends kx{constructor(e){super(3,e),Sx.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new xm(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Sx.className="Conv3D",Ni(Sx);class Ix extends Tx{constructor(e){if(super(e),this.inputSpec=[new ob({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new xm(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=tb(e)).length)throw new xm("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new xm("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ob({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return sa(()=>{let t=eb(e);if(4!==t.shape.length)throw new xm(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a;"channelsFirst"===this.dataFormat?(s=2,a=3):(s=1,a=2);const i=n[s],o=n[a],u=this.kernelSize[0],l=this.kernelSize[1],c=this.strides[0],h=this.strides[1],d=[r,yx(i,c,u,this.padding),yx(o,h,l,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=$h(t,[0,2,3,1]));let p=Ou(t,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=$h(p,[0,3,1,2])),null!=this.bias&&(p=Ng(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p})}computeOutputShape(e){const t=(e=tb(e)).slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],u=this.strides[1];return t[n]=this.filters,t[r]=yx(t[r],o,a,this.padding),t[s]=yx(t[s],u,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Ix.className="Conv2DTranspose",Ni(Ix);class Nx extends Sx{constructor(e){if(super(e),this.inputSpec=[new ob({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new xm(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=tb(e)).length)throw new xm("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new xm("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ob({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return sa(()=>{let t=eb(e);if(5!==t.shape.length)throw new xm(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a,i;"channelsFirst"===this.dataFormat?(i=2,s=3,a=4):(i=1,s=2,a=3);const o=n[i],u=n[s],l=n[a],c=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[r,yx(o,p,c,this.padding),yx(u,f,h,this.padding),yx(l,m,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=$h(t,[0,2,3,4,1]));let b=Fu(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=$h(b,[0,4,1,2,3])),null!==this.bias&&(b=Ng(b,this.bias.read(),this.dataFormat)),null!==this.activation&&(b=this.activation.apply(b)),b})}computeOutputShape(e){const t=(e=tb(e)).slice();let n,r,s,a;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);const i=this.kernelSize[0],o=this.kernelSize[1],u=this.kernelSize[2],l=this.strides[0],c=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[r]=yx(t[r],l,i,this.padding),t[s]=yx(t[s],c,o,this.padding),t[a]=yx(t[a],h,u,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Nx.className="Conv3DTranspose",Ni(Nx);class Ex extends kx{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new xm("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new xm("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new xm(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Zg(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=lx(t.depthwiseRegularizer),this.depthwiseConstraint=Cb(t.depthwiseConstraint),this.pointwiseInitializer=Zg(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=lx(t.pointwiseRegularizer),this.pointwiseConstraint=Cb(t.pointwiseConstraint)}build(e){if((e=tb(e)).length<this.rank+2)throw new xm(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new xm(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let e=0;e<this.rank;++e)s.push(1);s.push(n*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new ob({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return sa(()=>{let t;if(e=eb(e),1===this.rank)throw new wm("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=$h(e,[0,2,3,1])),t=Wc(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=Ng(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=$h(t,[0,3,1,2])),t})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Yg(this.depthwiseInitializer),e.pointwiseInitializer=Yg(this.pointwiseInitializer),e.depthwiseRegularizer=ox(this.depthwiseRegularizer),e.pointwiseRegularizer=ox(this.pointwiseRegularizer),e.depthwiseConstraint=$b(this.depthwiseConstraint),e.pointwiseConstraint=$b(this.pointwiseConstraint),e}}Ex.className="SeparableConv";class $x extends Ex{constructor(e){super(2,e)}}$x.className="SeparableConv2D",Ni($x);class Ax extends kx{constructor(e){super(1,e),Ax.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Lm(e.kernelSize,"number",1,1))throw new xm(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Ax.className="Conv1D",Ni(Ax);class Cx extends db{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return sa(()=>{if(e=eb(e),"channelsLast"===this.dataFormat){const t=yg(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return yg(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=yg(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return yg(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Cx.className="Cropping2D",Ni(Cx);class Ox extends db{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Jm(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,Mm(qm,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return sa(()=>{let t=eb(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=$h(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],s="nearest"===this.interpolation?Ud.resizeNearestNeighbor(t,[e,r]):Ud.resizeBilinear(t,[e,r]);return $h(s,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?Ud.resizeNearestNeighbor(t,[e,r]):Ud.resizeBilinear(t,[e,r])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}Ox.className="UpSampling2D",Ni(Ox);class Rx extends _x{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Zg(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Cb(e.depthwiseConstraint),this.depthwiseRegularizer=lx(e.depthwiseRegularizer)}build(e){if((e=tb(e)).length<4)throw new xm(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new xm(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return sa(()=>{let t=function(e,t,n=[1,1],r="valid",s,a){return sa(()=>{null==s&&(s="channelsLast"),Jm(s);let i=xx(e,s);if(4!==e.rank)throw new xm(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new xm(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Vu(i,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===s&&(i=$h(i,[0,3,1,2])),i})}(e=eb(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=Ng(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t})}computeOutputShape(e){e=tb(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=bx(t,this.kernelSize[0],this.padding,this.strides[0]),a=bx(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Yg(this.depthwiseInitializer),e.depthwiseRegularizer=ox(this.depthwiseRegularizer),e.depthwiseConstraint=$b(this.depthwiseRegularizer),e}}function Dx(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new xm("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=s(t),constants:n=s(n)}}function Fx(e,t,n,r=!1,s,a,i=!1,o=!1){return sa(()=>{const u=t.shape.length;if(u<3)throw new xm(`Input should be at least 3D, but is ${u}D.`);const l=[1,0].concat(hg(2,u));if(t=$h(t,l),null!=a)throw new wm("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=hi(hi(s,"bool"),"float32")).rank===u-1&&(s=fl(s,-1)),s=$h(s,l)),r&&(t=Fc(t,0),null!=s&&(s=Fc(s,0)));const c=[];let h,d=n;const p=t.shape[0],f=kh(t);let m,g;null!=s&&(m=kh(s));for(let t=0;t<p;++t){const n=f[t],r=sa(()=>e(n,d));if(null==s)h=r[0],d=r[1];else{const e=sa(()=>{const e=m[t],n=Ri(ic(e),e);return{output:fi(bi(r[0],e),bi(d[0],n)),newStates:d.map((t,s)=>fi(bi(r[1][s],e),bi(t,n)))}});h=e.output,d=e.newStates}o&&c.push(h)}return o&&(g=ih(c,1)),[h,g,d]})}Rx.className="DepthwiseConv2D",Ni(Rx);class Px extends db{constructor(e){let t;if(super(e),null==e.cell)throw new xm("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new jx({cells:e.cell}):e.cell,null==t.stateSize)throw new xm("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new ob({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?hg(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(e=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){Jg(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return sa(()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map(e=>null);return[e].concat(t)}return e})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new wm("Constants support is not implemented in RNN yet.");Jg(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new ob({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let s;if(this.cell.build(r),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!M(this.stateSpec.map(e=>e.shape[e.shape.length-1]),s))throw new xm(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(e=>new ob({shape:[null,e]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){sa(()=>{if(!this.stateful)throw new bm("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new xm("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>Xl([n,e])):this.states_=[Xl([n,this.cell.stateSize])];else if(null==e)aa(this.states_),null!=this.keptStates&&(aa(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>Xl([n,e])):this.states_[0]=Xl([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new xm(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):aa(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,a=[n,s];if(!M(r.shape,a))throw new xm(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map(e=>ia(e.clone()))})}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=Dx(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let a=[],i=[];if(null!=n){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new ob({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=r&&(t.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof ub){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return sa(()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let s=null==t?null:t.initialState;e=eb(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new xm(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},o=Fx((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]},e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),u=o[0],l=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const h=this.returnSequences?l:u;return this.returnState?[h].concat(c):h})}getInitialState(e){return sa(()=>{let t=Xl(e.shape);return t=ll(t,[1,2]),t=mg(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>e>1?vg(t,[1,e]):t):this.cell.stateSize>1?[vg(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===Px.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t,n={}){const r=Wb(t.cell,n);return new e(Object.assign(t,{cell:r}))}}Px.className="RNN",Ni(Px);class Mx extends db{}class Lx extends Mx{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,zm(this.units,"units"),this.activation=rx(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Zg(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Zg(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Zg(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=lx(e.kernelRegularizer),this.recurrentRegularizer=lx(e.recurrentRegularizer),this.biasRegularizer=lx(e.biasRegularizer),this.kernelConstraint=Cb(e.kernelConstraint),this.recurrentConstraint=Cb(e.recurrentConstraint),this.biasConstraint=Cb(e.biasConstraint),this.dropout=lg([1,cg([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=lg([1,cg([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=tb(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return sa(()=>{if(2!==e.length)throw new xm(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Gx({ones:()=>ic(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Gx({ones:()=>ic(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;s=kg(null!=a?bi(e,a):e,this.kernel.read()),null!=this.bias&&(s=Ng(s,this.bias.read())),null!=i&&(n=bi(n,i));let o=fi(s,kg(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:tx(this.activation),useBias:this.useBias,kernelInitializer:Yg(this.kernelInitializer),recurrentInitializer:Yg(this.recurrentInitializer),biasInitializer:Yg(this.biasInitializer),kernelRegularizer:ox(this.kernelRegularizer),recurrentRegularizer:ox(this.recurrentRegularizer),biasRegularizer:ox(this.biasRegularizer),activityRegularizer:ox(this.activityRegularizer),kernelConstraint:$b(this.kernelConstraint),recurrentConstraint:$b(this.recurrentConstraint),biasConstraint:$b(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}Lx.className="SimpleRNNCell",Ni(Lx);class zx extends Px{constructor(e){e.cell=new Lx(e),super(e)}call(e,t){return sa(()=>{null!=this.cell.dropoutMask&&(aa(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(aa(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return new e(t)}}zx.className="SimpleRNN",Ni(zx);class Bx extends Mx{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new xm("GRUCell does not support reset_after parameter set to true.");this.units=e.units,zm(this.units,"units"),this.activation=rx(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=rx(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Zg(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Zg(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Zg(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=lx(e.kernelRegularizer),this.recurrentRegularizer=lx(e.recurrentRegularizer),this.biasRegularizer=lx(e.biasRegularizer),this.kernelConstraint=Cb(e.kernelConstraint),this.recurrentConstraint=Cb(e.recurrentConstraint),this.biasConstraint=Cb(e.biasConstraint),this.dropout=lg([1,cg([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=lg([1,cg([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=tb(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return sa(()=>{if(2!==e.length)throw new xm(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Gx({ones:()=>ic(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Gx({ones:()=>ic(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,a=this.recurrentDropoutMask;let i,o,u;0<this.dropout&&this.dropout<1&&(e=bi(e,s[0]));let l=kg(e,this.kernel.read());this.useBias&&(l=Ng(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=bi(r,a[0]));const c=this.recurrentKernel.read(),[h,d]=nh(c,[2*this.units,this.units],c.rank-1),p=kg(r,h),[f,m,g]=nh(l,3,l.rank-1),[b,y]=nh(p,2,p.rank-1);i=this.recurrentActivation.apply(fi(f,b)),o=this.recurrentActivation.apply(fi(m,y));const x=kg(bi(o,r),d);u=this.activation.apply(fi(g,x));const w=fi(bi(i,r),bi(fi(1,Rl(i)),u));return[w,w]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:tx(this.activation),recurrentActivation:tx(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Yg(this.kernelInitializer),recurrentInitializer:Yg(this.recurrentInitializer),biasInitializer:Yg(this.biasInitializer),kernelRegularizer:ox(this.kernelRegularizer),recurrentRegularizer:ox(this.recurrentRegularizer),biasRegularizer:ox(this.biasRegularizer),activityRegularizer:ox(this.activityRegularizer),kernelConstraint:$b(this.kernelConstraint),recurrentConstraint:$b(this.recurrentConstraint),biasConstraint:$b(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}Bx.className="GRUCell",Ni(Bx);class Ux extends Px{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Bx(e),super(e)}call(e,t){return sa(()=>{null!=this.cell.dropoutMask&&(aa(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(aa(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}Ux.className="GRU",Ni(Ux);class Vx extends Mx{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,zm(this.units,"units"),this.activation=rx(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=rx(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Zg(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Zg(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Zg(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=lx(e.kernelRegularizer),this.recurrentRegularizer=lx(e.recurrentRegularizer),this.biasRegularizer=lx(e.biasRegularizer),this.kernelConstraint=Cb(e.kernelConstraint),this.recurrentConstraint=Cb(e.recurrentConstraint),this.biasConstraint=Cb(e.biasConstraint),this.dropout=lg([1,cg([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=lg([1,cg([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=tb(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new((t=class extends Og{apply(t,r){const s=e.apply([n]),a=(new Dg).apply([n]),i=e.apply([2*n]);return wg(wg(s,a),i)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return sa(()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new xm(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Gx({ones:()=>ic(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Gx({ones:()=>ic(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,u,l,c;0<this.dropout&&this.dropout<1&&(e=bi(e,a[0]));let h=kg(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=bi(r,i[0])),h=fi(h,kg(r,this.recurrentKernel.read())),this.useBias&&(h=Ng(h,this.bias.read()));const[d,p,f,m]=nh(h,4,h.rank-1);o=this.recurrentActivation.apply(d),u=this.recurrentActivation.apply(p),l=fi(bi(u,s),bi(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);const g=bi(c,this.activation.apply(l));return[g,g,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:tx(this.activation),recurrentActivation:tx(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Yg(this.kernelInitializer),recurrentInitializer:Yg(this.recurrentInitializer),biasInitializer:Yg(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:ox(this.kernelRegularizer),recurrentRegularizer:ox(this.recurrentRegularizer),biasRegularizer:ox(this.biasRegularizer),activityRegularizer:ox(this.activityRegularizer),kernelConstraint:$b(this.kernelConstraint),recurrentConstraint:$b(this.recurrentConstraint),biasConstraint:$b(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}Vx.className="LSTMCell",Ni(Vx);class Wx extends Px{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Vx(e),super(e)}call(e,t){return sa(()=>{null!=this.cell.dropoutMask&&(aa(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(aa(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}Wx.className="LSTM",Ni(Wx);class jx extends Mx{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return sa(()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let a;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(const e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)})}build(e){let t;Jg(e)&&(e=e[0]),this.cells.forEach((n,r)=>{ng(`RNNCell_${r}`,()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map(e=>({className:e.getClassName(),config:e.getConfig()}))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t,n={}){const r=[];for(const e of t.cells)r.push(Wb(e,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return ab(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,s=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],s[e]])}ib(t)}}function Gx(e){const{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>null!=a?a(t(),n):Eg(t(),n),o=()=>$g(i,t,r);return!s||s<=1?ia(o().clone()):Array(s).fill(void 0).map(o).map(e=>ia(e.clone()))}jx.className="StackedRNNCells",Ni(jx);class Hx extends Px{constructor(e){if(e.unroll)throw new wm("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new wm("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new ob({ndim:5})]}call(e,t){return sa(()=>{if(null!=this.cell.dropoutMask&&(aa(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(aa(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new xm("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return sa(()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=Xl([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){sa(()=>{if(!this.stateful)throw new bm("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(null==n[0])throw new xm("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Xl(s)):this.states_=[Xl(s)];else if(null==e)aa(this.states_),null!=this.keptStates&&(aa(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Xl(s)):this.states_[0]=Xl(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new xm(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):aa(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=s;if(!M(n.shape,r))throw new xm(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map(e=>ia(e.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,o="channelsFirst"===t,u=e[o?3:2],l=e[o?4:3],c=bx(u,r[0],s,a[0],i[0]),h=bx(l,r[1],s,a[1],i[1]);return[...e.slice(0,2),...o?[n,c,h]:[c,h,n]]}}Hx.className="ConvRNN2D";class qx extends Vx{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,zm(this.filters,"filters"),this.kernelSize=gx(n,2,"kernelSize"),this.kernelSize.forEach(e=>zm(e,"kernelSize")),this.strides=gx(r||1,2,"strides"),this.strides.forEach(e=>zm(e,"strides")),this.padding=s||"valid",Qm(this.padding),this.dataFormat=a||"channelsLast",Jm(this.dataFormat),this.dilationRate=gx(i||1,2,"dilationRate"),this.dilationRate.forEach(e=>zm(e,"dilationRate"))}build(e){var t;e=tb(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new xm(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],s=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends Og{apply(e,t){return xg([n.apply([r]),Yl([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return sa(()=>{if(3!==e.length)throw new xm(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],s=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Gx({ones:()=>ic(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?bi(t[n],e):e;let u=o(r,i,0),l=o(r,i,1),c=o(r,i,2),h=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Gx({ones:()=>ic(s),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=o(s,d,0),f=o(s,d,1),m=o(s,d,2),g=o(s,d,3);const[b,y,x,w]=nh(this.kernel.read(),4,3),[v,_,k,T]=this.useBias?nh(this.bias.read(),4):[null,null,null,null];u=this.inputConv(u,b,v,this.padding),l=this.inputConv(l,y,_,this.padding),c=this.inputConv(c,x,k,this.padding),h=this.inputConv(h,w,T,this.padding);const[S,I,N,E]=nh(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,S),f=this.recurrentConv(f,I),m=this.recurrentConv(m,N),g=this.recurrentConv(g,E);const $=this.recurrentActivation.apply(fi(u,p)),A=this.recurrentActivation.apply(fi(l,f)),C=fi(bi(A,a),bi($,this.activation.apply(fi(c,m)))),O=bi(this.recurrentActivation.apply(fi(h,g)),this.activation.apply(C));return[O,O,C]})}getConfig(){const e=super.getConfig(),{units:t}=e,n=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n}(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const s=$u(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?Ng(s,n,this.dataFormat):s}recurrentConv(e,t){return $u(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}qx.className="ConvLSTM2DCell",Ni(qx);class Kx extends Hx{constructor(e){const t=new qx(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}Kx.className="ConvLSTM2D",Ni(Kx);class Xx extends db{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let e=0;e<this.noiseShape.length;++e)n.push(null==this.noiseShape[e]?t[e]:this.noiseShape[e]);return n}call(e,t){return sa(()=>{this.invokeCallHook(e,t);const n=eb(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return $g(()=>Eg(n,this.rate,r,this.seed),()=>n,e)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}Xx.className="Dropout",Ni(Xx);class Yx extends Xx{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}Yx.className="SpatialDropout1D",Ni(Yx);class Zx extends db{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,zm(this.units,"units"),this.activation=rx(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=Zg(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Zg(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Cb(e.kernelConstraint),this.biasConstraint=Cb(e.biasConstraint),this.kernelRegularizer=lx(e.kernelRegularizer),this.biasRegularizer=lx(e.biasRegularizer),this.activityRegularizer=lx(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=tb(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=tb(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return sa(()=>{this.invokeCallHook(e,t);const n=eb(e),r=Um(this.activation.getClassName());let s;return null!=r?s=kg(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=kg(n,this.kernel.read()),null!=this.bias&&(s=Ng(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s})}getConfig(){const e={units:this.units,activation:tx(this.activation),useBias:this.useBias,kernelInitializer:Yg(this.kernelInitializer),biasInitializer:Yg(this.biasInitializer),kernelRegularizer:ox(this.kernelRegularizer),biasRegularizer:ox(this.biasRegularizer),activityRegularizer:ox(this.activityRegularizer),kernelConstraint:$b(this.kernelConstraint),biasConstraint:$b(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Zx.className="Dense",Ni(Zx);class Jx extends db{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=tb(e);for(const t of e.slice(1))if(null==t)throw new xm(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],ug(e,1)]}call(e,t){return sa(()=>{this.invokeCallHook(e,t);let n=eb(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=$h(n,e)}return function(e){if(e.rank<=1)throw new xm(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],ug(e.shape,1)];return au(e,t)}(n)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}Jx.className="Flatten",Ni(Jx);class Qx extends db{constructor(e){super(e),this.supportsMasking=!0,this.activation=rx(e.activation)}call(e,t){return sa(()=>{this.invokeCallHook(e,t);const n=eb(e);return this.activation.apply(n)})}getConfig(){const e={activation:tx(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}Qx.className="Activation",Ni(Qx);class ew extends db{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return sa(()=>{return e=eb(e),t=e,n=this.n,sa(()=>{if(2!==t.shape.length)throw new xm(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return vg(mg(t,1),[1,n,1])});var t,n})}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}ew.className="RepeatVector",Ni(ew);class tw extends db{constructor(e){super(e),this.targetShape=e.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let s=1,a=null;for(let e=0;e<r.length;++e){const t=r[e];if(this.isUnknown(t)){if(null!==a)throw new xm("Can only specifiy one unknown dimension.");a=e}else s*=t}const i=ug(e);if(null!==a){if(0===s||i%s!==0)throw new xm(n);r[a]=i/s}else if(i!==s)throw new xm(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return sa(()=>{this.invokeCallHook(e,t);const n=eb(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return au(n,s)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}tw.className="Reshape",Ni(tw);class nw extends db{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=hg(1,e.dims.length+1);if(!M(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ob({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=tb(e)).slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return $h(eb(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}nw.className="Permute",Ni(nw);class rw extends db{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=eb(e);return Po(sc(n,this.maskValue),-1)}call(e,t){return sa(()=>{this.invokeCallHook(e,t);const n=eb(e),r=Po(sc(n,this.maskValue),-1,!0);return bi(n,hi(r,n.dtype))})}}rw.className="Masking",Ni(rw);class sw extends db{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Nm(e.inputLength))}this.inputDim=e.inputDim,zm(this.inputDim,"inputDim"),this.outputDim=e.outputDim,zm(this.outputDim,"outputDim"),this.embeddingsInitializer=Zg(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=lx(e.embeddingsRegularizer),this.activityRegularizer=lx(e.activityRegularizer),this.embeddingsConstraint=Cb(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return sa(()=>this.maskZero?(e=eb(e),sc(e,wi(e))):null)}computeOutputShape(e){if(e=tb(e),null==this.inputLength)return[...e,this.outputDim];const t=Nm(this.inputLength);if(t.length!==e.length-1)throw new xm(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const s=t[r],a=e[r+1];if(null!=s&&null!=a&&s!==a)throw new xm(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==s&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return sa(()=>{this.invokeCallHook(e,t);let n=eb(e);"int32"!==n.dtype&&(n=fg(n,"int32"));const r=Tg(this.embeddings.read(),au(n,[n.size]));return au(r,tb(this.computeOutputShape(n.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Yg(this.embeddingsInitializer),embeddingsRegularizer:ox(this.embeddingsRegularizer),activityRegularizer:ox(this.activityRegularizer),embeddingsConstraint:$b(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}sw.className="Embedding",Ni(sw);class aw extends db{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new wm}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const s=e[e.length-t.length+r],a=t[r];if(null==s||null==a||s<0||a<0)n.push(null);else if(1===s)n.push(a);else if(1===a)n.push(s);else{if(s!==a)throw new xm("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[tb(e)]),e.length<2)throw new xm(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const n of e)null!=n&&null!==n[0]&&t.push(n[0]);if(t=Fm(t),t.length>1)throw new xm(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let t=1;t<e.length;++t){const r=null==e[t]?null:e[t].slice(1);n=this.computeElementwiseOpOutputShape(n,r)}const r=e.map(e=>e.length);-1===e.indexOf(null)&&1===Fm(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return sa(()=>{if(this.reshapeRequired){const t=[],n=e.map(e=>e.rank);if(-1===n.indexOf(null)){const r=cg(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=mg(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const r of e){const e=r.rank;if(null==e){const e=r.shape,s=e[0],a=e.slice(1).concat([s]);let i=au(r,[s].concat(ug(e.slice(1))));i=$h(i,[1,0]),i=au(i,a),t.push(i),n=!0}else if(e>1){const s=hg(1,e).concat([0]);t.push($h(r,s)),n=!0}else t.push(r)}let r=this.mergeFunction(t);const s=r.rank;if(n)if(null==s){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=au($h(au(r,[-1,t]),[1,0]),n)}else if(s>1){const e=[s-1].concat(hg(0,s-1));r=$h(r,e)}return r}}return this.mergeFunction(e)})}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let n=1;n<e.length;++n){const r=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(const t of e)null!=t&&null!==t[0]&&n.push(t[0]);return n=Fm(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return sa(()=>{if(null==t)return null;if(!Array.isArray(t))throw new xm("`mask` should be an Array");if(!Array.isArray(e))throw new xm("`inputs` should be an Array");if(t.length!==e.length)throw new xm(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(e=>null==e))return null;let n=(t=t.map(e=>null==e?e:fl(e,0)))[0];for(let e=1;e<t.length-1;++e)n=Ll(n,t[e]);return n})}}class iw extends aw{constructor(e){super(e)}mergeFunction(e){return sa(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=fi(t,e[n]);return t})}}iw.className="Add",Ni(iw);class ow extends aw{constructor(e){super(e)}mergeFunction(e){return sa(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=bi(t,e[n]);return t})}}ow.className="Multiply",Ni(ow);class uw extends aw{constructor(e){super(e)}mergeFunction(e){return sa(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=fi(t,e[n]);return bi(1/e.length,t)})}}uw.className="Average",Ni(uw);class lw extends aw{constructor(e){super(e)}mergeFunction(e){return sa(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=zi(t,e[n]);return t})}}lw.className="Maximum",Ni(lw);class cw extends aw{constructor(e){super(e)}mergeFunction(e){return sa(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Jl(t,e[n]);return t})}}cw.className="Minimum",Ni(cw);class hw extends aw{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new xm("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const n of e)if(null!=n){t=!1;break}if(t)return;const n=[];for(let t=0;t<e.length;++t){const r=e[t].slice();r.splice(this.axis,1);let s=!1;for(const e of n)if(M(e,r)){s=!0;break}s||n.push(r)}if(n.length>1)throw new xm("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return sa(()=>xg(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new xm("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const e of t.slice(1)){if(null==n[r]||null==e[r]){n[r]=null;break}n[r]+=e[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new xm("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new xm("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new xm(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return sa(()=>{let n=!0;if(t.forEach(e=>{null==e||(n=!1)}),n)return null;const r=[];for(let n=0;n<e.length;++n)null==t[n]?r.push(hi(ic(e[n]),"bool")):t[n].rank<e[n].rank?r.push(fl(t[n],-1)):r.push(t[n]);const s=uu(r,this.axis);return Fo(s,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function dw(e,t){for(;e<0;)e+=t;return e}hw.className="Concatenate",Ni(hw);class pw extends aw{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){R(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new wm("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new xm(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new xm(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map((t,n)=>dw(t,e[n].shape.length)):[dw(this.axes,n.shape.length),dw(this.axes,r.shape.length)],this.normalize&&(n=jb(n,t[0]),r=jb(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new wm("batchDot is not implemented for tensors of 4D or higher rank yet");if(R(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),R(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new wm("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;null==n&&(n=[r-1,s-2]);const a=n;return sa(()=>{let n,i;if(r>s){n=r-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=au(t,t.shape.concat(e))}else if(s>r){n=s-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=au(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=a[0]===a[1]?ll(bi(e,t),a[0]):ll(bi($h(e,[1,0]),t),a[1]);else{const n=a[0]!==e.shape.length-1,r=a[1]===t.shape.length-1;i=lu(e,t,n,r)}if(n>0){let e;e=r>s?r+s-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=ah(i,t)}return 1===i.shape.length&&(i=fl(i,1)),i})}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[dw(this.axes,e.length),dw(this.axes,t.length)],n}computeOutputShape(e){R(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new wm("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const s=t.concat(n);return 1===s.length&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}pw.className="Dot",Ni(pw);class fw extends db{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return sa(()=>{this.invokeCallHook(e,t);const n=eb(e);return $g(()=>fi(_g(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}}fw.className="GaussianNoise",Ni(fw);class mw extends db{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return sa(()=>{this.invokeCallHook(e,t);const n=eb(e);return this.rate>0&&this.rate<1?$g(()=>{const e=Math.sqrt(this.rate/(1-this.rate));return bi(n,_g(n.shape,1,e))},()=>n,t.training||!1):n})}}mw.className="GaussianDropout",Ni(mw);class gw extends db{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||eb(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return sa(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e);return $g(()=>{const t=eb(e),r=-1.7580993408473766;let s=vl(Ec(n),this.rate);s=fg(s,"float32");const a=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-a*r*this.rate,o=fi(bi(t,s),bi(fi(s,-1),r));return fi(bi(o,a),i)},()=>eb(e),t.training||!1)}return e})}}function bw(e,t,n,r,s,a=.001){let i;if(2===e.rank)i=gu(e,t,n,r,s,a);else if(3===e.rank)i=bu(e,t,n,r,s,a);else{if(4!==e.rank)throw new wm(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=yu(e,t,n,r,s,a)}return i}gw.className="AlphaDropout",Ni(gw);class yw extends db{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Zg(e.betaInitializer||"zeros"),this.gammaInitializer=Zg(e.gammaInitializer||"ones"),this.movingMeanInitializer=Zg(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Zg(e.movingVarianceInitializer||"ones"),this.betaConstraint=Cb(e.betaConstraint),this.gammaConstraint=Cb(e.gammaConstraint),this.betaRegularizer=lx(e.betaRegularizer),this.gammaRegularizer=lx(e.gammaRegularizer)}build(e){e=tb(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new xm(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new ob({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return sa(()=>{const n=null!=t.training&&t.training,r=eb(e),s=r.shape,a=s.length,i=hg(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);const u=km(1,a);u[o]=s[o];const l=i.slice();l.sort();const c=!M(l,hg(0,a).slice(0,a-1));if(!n)return(()=>{if(c){const e=au(this.movingMean.read(),u),t=au(this.movingVariance.read(),u),n=this.center?au(this.beta.read(),u):null,s=this.scale?au(this.gamma.read(),u):null;return bw(r,e,t,n,s,this.epsilon)}return bw(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=function(e,t,n,r,s=.001){return M(r.slice().sort(),hg(0,e.rank-1))?function(e,t,n,r,s=.001){return sa(()=>{const a=tc(e,r),i=a.mean,o=a.variance;return[bw(e,i,o,n,t,s),i,o]})}(e,t,n,r,s):function(e,t,n,r,s=.001){return sa(()=>{const a=tc(e,r),i=a.mean,o=a.variance,u=[];for(const t of hg(0,e.rank))-1!==r.indexOf(t)?u.push(1):u.push(e.shape[t]);const l=au(i,u),c=au(o,u),h=null==t?null:au(t,u),d=null==n?null:au(n,u);return[bw(e,l,c,d,h,s),i,o]})}(e,t,n,r,s)}(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{sa(()=>{const r=1-n,s=e.read(),a=bi(Ri(s,t),r);e.write(Ri(s,a))})};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Yg(this.betaInitializer),gammaInitializer:Yg(this.gammaInitializer),movingMeanInitializer:Yg(this.movingMeanInitializer),movingVarianceInitializer:Yg(this.movingVarianceInitializer),betaRegularizer:ox(this.betaRegularizer),gammaRegularizer:ox(this.gammaRegularizer),betaConstraint:$b(this.betaConstraint),gammaConstraint:$b(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}yw.className="BatchNormalization",Ni(yw);class xw extends db{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Zg(e.betaInitializer||"zeros"),this.gammaInitializer=Zg(e.gammaInitializer||"ones"),this.betaRegularizer=lx(e.betaRegularizer),this.gammaRegularizer=lx(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=tb(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let e=0;e<this.axis.length;++e)this.axis[e]<0&&(this.axis[e]+=t);for(const e of this.axis)if(e<0||e>=t)throw new Error(`Invalid axis: ${e}`);if(this.axis.length!==Fm(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map(t=>e[t]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=eb(e),r=n.shape,s=r.length;return sa(()=>{let{mean:e,variance:t}=tc(n,this.axis,!0);const a=km(1,s);for(const e of this.axis)a[e]=r[e];const i=e=>null!=e&&e.shape.length!==s?au(e,a):e;let o=this.scale?i(this.gamma.read()):null,u=this.center?i(this.beta.read()):null;const l=[],c=[];for(let e=0;e<s;++e)-1!==this.axis.indexOf(e)?(l.push(r[e]),c.push(1)):(l.push(1),c.push(r[e]));return e=gl(e,l),t=gl(t,l),null!=o&&(o=gl(o,c)),null!=u&&(u=gl(u,c)),bw(n,e,t,u,o,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Yg(this.betaInitializer),gammaInitializer:Yg(this.gammaInitializer),betaRegularizer:ox(this.betaRegularizer),gammaRegularizer:ox(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}xw.className="LayerNormalization",Ni(xw);class ww extends db{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new xm(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new xm(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new xm(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new ob({ndim:4})]}computeOutputShape(e){let t,n;return e=tb(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return sa(()=>{return t=eb(e),n=this.padding,r=this.dataFormat,sa(()=>{if(4!==t.rank)throw new xm(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new xm("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new xm(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],uc(t,e)});var t,n,r})}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function vw(e,t,n,r,s,a){return sa(()=>{let i;Jm(s),eg(a),Qm(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=xx(e,s);const o="same"===r?"same":"valid";return i="max"===a?Gl(e,t,n,o):iu(e,t,n,o),"channelsFirst"===s&&(i=$h(i,[0,3,1,2])),i})}function _w(e,t,n,r,s,a){return sa(()=>{let i;Jm(s),eg(a),Qm(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=wx(e,s);const o="same"===r?"same":"valid";return i="max"===a?Hl(e,t,n,o):ou(e,t,n,o),"channelsFirst"===s&&(i=$h(i,[0,4,1,2,3])),i})}ww.className="ZeroPadding2D",Ni(ww);class kw extends db{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new xm(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(zm(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new xm(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}zm(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,Qm(this.padding),this.inputSpec=[new ob({ndim:3})]}computeOutputShape(e){const t=bx((e=tb(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return sa(()=>{this.invokeCallHook(e,t),e=mg(eb(e),2);const n=this.poolingFunction(eb(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return ah(n,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class Tw extends kw{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Jm(s),Qm(r),vw(e,t,n,r,s,"max")}}Tw.className="MaxPooling1D",Ni(Tw);class Sw extends kw{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Jm(s),Qm(r),vw(e,t,n,r,s,"avg")}}Sw.className="AveragePooling1D",Ni(Sw);class Iw extends db{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new xm(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];zm(this.poolSize,"poolSize"),zm(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Jm(this.dataFormat),Qm(this.padding),this.inputSpec=[new ob({ndim:4})]}computeOutputShape(e){e=tb(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=bx(t,this.poolSize[0],this.padding,this.strides[0]),n=bx(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return sa(()=>(this.invokeCallHook(e,t),this.poolingFunction(eb(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Nw extends Iw{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Jm(s),Qm(r),vw(e,t,n,r,s,"max")}}Nw.className="MaxPooling2D",Ni(Nw);class Ew extends Iw{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Jm(s),Qm(r),vw(e,t,n,r,s,"avg")}}Ew.className="AveragePooling2D",Ni(Ew);class $w extends db{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new xm(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];zm(this.poolSize,"poolSize"),zm(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Jm(this.dataFormat),Qm(this.padding),this.inputSpec=[new ob({ndim:5})]}computeOutputShape(e){e=tb(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=bx(t,this.poolSize[0],this.padding,this.strides[0]),n=bx(n,this.poolSize[1],this.padding,this.strides[1]),r=bx(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return sa(()=>(this.invokeCallHook(e,t),this.poolingFunction(eb(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Aw extends $w{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Jm(s),Qm(r),_w(e,t,n,r,s,"max")}}Aw.className="MaxPooling3D",Ni(Aw);class Cw extends $w{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Jm(s),Qm(r),_w(e,t,n,r,s,"avg")}}Cw.className="AveragePooling3D",Ni(Cw);class Ow extends db{constructor(e){super(e),this.inputSpec=[new ob({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new wm}}class Rw extends Ow{constructor(e){super(e||{})}call(e,t){return sa(()=>{const t=eb(e);return Kl(t,1)})}}Rw.className="GlobalAveragePooling1D",Ni(Rw);class Dw extends Ow{constructor(e){super(e||{})}call(e,t){return sa(()=>{const t=eb(e);return ol(t,1)})}}Dw.className="GlobalMaxPooling1D",Ni(Dw);class Fw extends db{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Jm(this.dataFormat),this.inputSpec=[new ob({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new wm}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Pw extends Fw{call(e,t){return sa(()=>{const t=eb(e);return"channelsLast"===this.dataFormat?Kl(t,[1,2]):Kl(t,[2,3])})}}Pw.className="GlobalAveragePooling2D",Ni(Pw);class Mw extends Fw{call(e,t){return sa(()=>{const t=eb(e);return"channelsLast"===this.dataFormat?ol(t,[1,2]):ol(t,[2,3])})}}Mw.className="GlobalMaxPooling2D",Ni(Mw);class Lw extends db{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const r=Wb(t.layer,n);delete t.layer;const s={layer:r};return Object.assign(s,t),new e(s)}}class zw extends Lw{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=tb(e)).length<3)throw new xm(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=tb(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return sa(()=>Fx((e,n)=>[eb(this.layer.call(e,t)),[]],e=eb(e),[],!1,null,null,!1,!0)[1])}}zw.className="TimeDistributed",Ni(zw);class Bw extends Lw{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Wb(n),t.goBackwards=!0!==t.goBackwards;const r={};var s;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Wb(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,s=this.mergeMode,Mm(Ym,"BidirectionalMergeMode",s),e.weights)throw new wm("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState?(r=s.slice(1),t=s[0]):t=s[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):Im(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=Dx(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const a=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new xm("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);const r=n.map(e=>new ob({shape:e.shape}));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new wm("Support for constants in Bidirectional layers is not implemented yet.");const o=a[0]instanceof ub;for(const e of a)if(e instanceof ub!==o)throw new xm("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return sa(()=>{const n=t.initialState;let r,s,a,i;if(null==n)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const a=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=Fc(s,1)),"concat"===this.mergeMode?i=xg([r,s]):"sum"===this.mergeMode?i=fi(r,s):"ave"===this.mergeMode?i=bi(.5,fi(r,s)):"mul"===this.mergeMode?i=bi(r,s):null==this.mergeMode&&(i=[r,s]),this.returnState?null==this.mergeMode?i.concat(a):[i].concat(a):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){ng(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),ng(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map(e=>null);return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=Wb(t.layer);if(delete t.layer,null!=t.numConstants)throw new wm("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}Bw.className="Bidirectional",Ni(Bw);class Uw extends db{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return sa(()=>("float32"!==(e=eb(e)).dtype&&(e=fg(e,"float32")),fi(bi(e,this.scale),this.offset)))}}Uw.className="Rescaling",Ni(Uw);const{resizeBilinear:Vw,cropAndResize:Ww}=Ud;class jw extends db{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,s,a,i,o){return sa(()=>{let u,l=!1;const c=[t/a,n/i,(r+t)/a,(s+n)/i],h=[];3===e.rank?(l=!0,u=ih([e])):u=e;for(let e=0;e<u.shape[0];e++)h.push(c);const d=Qs(h,[h.length,4]),p=Ac(0,h.length,1,"int32"),f=Ww(u,d,p,[r,s],"nearest");return fg(l?eb(kh(f)):f,o)})}upsize(e,t,n,r){return sa(()=>fg(Vw(e,[t,n]),r))}call(e,t){return sa(()=>{const t=eb(e),n=t.dtype,r=t.shape,s=r[r.length-3],a=r[r.length-2];let i=0;s!==this.height&&(i=Math.floor((s-this.height)/2));let o=0;return a!==this.width&&(o=Math.floor((a-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,s,a,n):this.upsize(e,this.height,this.width,n)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=tb(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}jw.className="CenterCrop",Ni(jw);class Gw extends db{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=tb(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return sa(()=>{let n;if("int32"!==(e=eb(e)).dtype&&(e=fg(e,"int32")),void 0!==t.countWeights){if("count"!==this.outputMode)throw new xm(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=eb(t.countWeights)}const r=ol(e),s=ul(e),a=wl(this.numTokens,r).bufferSync().get(0),i=vl(s,0).bufferSync().get(0);if(!a||!i)throw new xm(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let s=eb(e);if("int32"!==s.dtype&&(s=fg(s,"int32")),"int"===t)return s;const a=s.shape;if(0===s.rank&&(s=fl(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=fl(s,-1)),s.rank>2)throw new xm(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t);let o;if(o=Bu(s,void 0!==r&&"count"===t?r:[],n,i),"tfIdf"!==t)return o;if(r)return bi(o,r);throw new xm("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)})}}Gw.className="CategoryEncoding",Ni(Gw);const Hw=new Set(["bilinear","nearest"]);class qw extends db{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!Hw.has(e.interpolation))throw new xm(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=tb(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return sa(()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return Ud.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Ud.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...Hw]} are supported`)})}}qw.className="Resizing",Ni(qw);class Kw{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}Kw.className="RandomSeed";class Xw extends db{constructor(e){super(e),this.randomGenerator=new Kw(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}Xw.className="BaseRandomLayer";const Yw=new Set(["bilinear","nearest"]);class Zw extends Xw{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new xm(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new xm(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new xm(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!Yw.has(n))throw new xm(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=tb(e))[2];return[this.imgHeight,-1,t]}call(e,t){return sa(()=>{const t=eb(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=Ec([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const s=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return Ud.resizeBilinear(e,s);case"nearest":return Ud.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...Yw]} are supported`)}})}}var Jw,Qw;Zw.className="RandomWidth",Ni(Zw),pe().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(Jw||(Jw={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(Qw||(Qw={}));const ev={};function tv(e){return ev[e]}function nv(e,t,n,r,s){const a=t.inputParams[e];if(a&&void 0!==a.inputIndexStart){const e=a.inputIndexStart,i=0===a.inputIndexEnd?void 0:void 0===a.inputIndexEnd?e+1:a.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===a.type)return rv(t.inputNames[o],n,r,s);if("tensors"===a.type){const a=t.inputs.slice(e,i);return t.inputNames.slice(e,i).filter((e,t)=>{var n;return"NoOp"!==(null===(n=a[t])||void 0===n?void 0:n.op)}).map(e=>rv(e,n,r,s))}const u=rv(t.inputNames[o],n,r,s),l=u.dataSync();return"number"===a.type?l[0]:ne(u.shape,l)}const i=t.attrParams[e];return i&&i.value}function rv(e,t,n,r){const[s,a]=ov(e,n);if(null!=r){const e=r.getHashTableHandleByName(s);if(null!=e)return e}const i=n.currentContextIds.find(e=>!!t[iv(s,e)]);return void 0!==i?t[iv(s,i)][a]:void 0}function sv(e,t,n){return t[iv(e,n.currentContextId)]}function av(e,t){const[n,r,s]=ov(e,t);return[iv(n,t&&t.currentContextId),r,s]}function iv(e,t){return t?`${e}-${t}`:e}function ov(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const r=e.split(":");let s;if(1===r.length)s=[e,0,void 0];else{const e=r[0],t=3===r.length?r[1]:void 0;s=[e,Number(r[r.length-1]),t]}return n&&t.parseNodeNameCache.set(e,s),s}function uv(e,t,n){let r=nv("pad",e,t,n);if("explicit"===r){r=nv("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=r[2*e],s[e][1]=r[2*e+1];return s}return r}function lv(e){return e.kept?e:di(e)}const cv=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],hv=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],dv=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],pv=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],fv=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],mv=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],gv=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],bv=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],yv=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],xv=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],wv=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],vv=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],_v=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],kv=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Tv=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Sv=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Iv=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Nv=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Ev=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class $v{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[a,i,o,u,l,c,h,d,p,f,m,g,b,y,x,w,v,_,k].map(e=>e.json));this.opMappers=e.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e,t={}){const n=e.node,r=[],s=[],a=[],i=n.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||a.push(e[t.name]),e),{});let o=[];const u=[];let l={},c={};null!=t&&(l=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const h=Object.keys(i);h.forEach(e=>{const t=i[e];t.inputNames.forEach((e,n)=>{const[r,,s]=av(e),a=i[r];if(null!=a.outputs){const e=a.outputs.indexOf(s);if(-1!==e){const s=`${r}:${e}`;t.inputNames[n]=s}}t.inputs.push(a),a.children.push(t)})}),0===Object.keys(c).length?h.forEach(e=>{const t=i[e];0===t.children.length&&u.push(t)}):Object.keys(c).forEach(e=>{const[t]=av(e),n=i[t];null!=n&&(n.signatureKey=c[e],u.push(n))}),Object.keys(l).length>0?Object.keys(l).forEach(e=>{const[t]=av(e),n=i[t];n&&(n.signatureKey=l[e],o.push(n))}):o=r;let d={};null!=e.library&&null!=e.library.function&&(d=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));const p={nodes:i,inputs:o,outputs:u,weights:s,placeholders:r,signature:t,functions:d};return a.length>0&&(p.initNodes=a),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){const t=tv(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.slice(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce((t,n)=>{const r=n.type;let s;switch(n.type){case"string":s=Cv(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Cv(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=Uv(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Uv(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=Rv(e.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=Rv(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=Bv(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Bv(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=Ov(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Ov(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=Wv(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Wv(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=zv(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=zv(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=Vv(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Vv(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=Pv(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Pv(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=Mv(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Mv(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=Fv(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Fv(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:s,type:r},t},{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e),{}));const s=[],a=[];e.signature.inputArg.forEach(e=>{const[t]=av(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Dv(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),r[t]=n}),Object.keys(r).forEach(e=>{const t=r[e];t.inputNames.forEach((e,n)=>{const[s,,a]=av(e),i=r[s];if(null!=i.outputs){const e=i.outputs.indexOf(a);if(-1!==e){const r=`${s}:${e}`;t.inputNames[n]=r}}t.inputs.push(i),i.children.push(t)})});const i=e.ret;e.signature.outputArg.forEach(e=>{const[t,n]=av(i[e.name]),s=r[t];null!=s&&(s.defaultOutput=n,a.push(s))});const o=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:a,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function Av(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=pe().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function Cv(e,t,n,r=!1){const s=e[t];return null!=s?Av(s.s,r):n}function Ov(e,t,n){const r=e[t];return r?r.b:n}function Rv(e,t,n){const r=e[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof s?s:parseInt(s,10)}function Dv(e){switch("string"==typeof e&&(e=Jw[e]),e){case Jw.DT_FLOAT:case Jw.DT_HALF:return"float32";case Jw.DT_INT32:case Jw.DT_INT64:case Jw.DT_INT8:case Jw.DT_UINT8:return"int32";case Jw.DT_BOOL:return"bool";case Jw.DT_DOUBLE:return"float32";case Jw.DT_STRING:return"string";case Jw.DT_COMPLEX64:case Jw.DT_COMPLEX128:return"complex64";default:return null}}function Fv(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function Pv(e,t,n){const r=e[t];return r&&r.type?Dv(r.type):n}function Mv(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map(e=>Dv(e)):n}function Lv(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(e=>"number"==typeof e.size?e.size:parseInt(e.size,10)):[]}function zv(e,t,n){const r=e[t];return r&&r.shape?Lv(r.shape):n}function Bv(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(e=>"number"==typeof e?e:parseInt(e,10)):n}function Uv(e,t,n,r=!1){const s=e[t];return s&&s.list&&s.list.s?s.list.s.map(e=>Av(e,r)):n}function Vv(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(e=>Lv(e)):n}function Wv(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class jv{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return rv(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return rv(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return Rv(this.node.rawAttrs,e,t);if(null!=n.s)return Cv(this.node.rawAttrs,e,t);if(null!=n.b)return Ov(this.node.rawAttrs,e,t);if(null!=n.shape)return zv(this.node.rawAttrs,e,t);if(null!=n.type)return Pv(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return Bv(this.node.rawAttrs,e,t);if(null!=n.list.s)return Uv(this.node.rawAttrs,e,t);if(null!=n.list.shape)return Vv(this.node.rawAttrs,e,t);if(null!=n.list.b)return Wv(this.node.rawAttrs,e,t);if(null!=n.list.type)return Mv(this.node.rawAttrs,e,t)}return t}}function Gv(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){R(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){const s=e[r],a=t[r];R(s<0||a<0||s===a,()=>n+` Shapes ${e} and ${t} must match`)}}}function Hv(e){return"number"!=typeof e&&!e.some(e=>e<0)}function qv(e,t,n){let r=Kv(e,n);const s=!Hv(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(e=>{r=Kv(e.shape,r)}),!Hv(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Kv(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}class Xv{constructor(e,t,n,r,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=_i(0),ia(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),Gv(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,ia(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((e,n)=>this.write(e,t[n]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Qs([],[0].concat(this.elementShape));const n=this.readMany(e);return Gv(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),ih(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return Qs([],[0].concat(this.elementShape));const t=[];for(let e=0;e<this.size();e++)t.push(e);const n=this.readMany(t);return Gv(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),uu(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,kh(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map(e=>(n+=e,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:t.size/n,a=[];sa(()=>{t=au(t,[1,n,s]);for(let n=0;n<e.length;++n){const i=[0,0===n?0:r[n-1],0],o=[1,e[n],s];a[n]=au(hu(t,i,o),this.elementShape)}return a});const i=[];for(let t=0;t<e.length;t++)i[t]=t;this.writeMany(i,a)}}class Yv{get id(){return this.idTensor.id}constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach(e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);Gv(t,e.shape,"TensorList shape mismatch: "),ia(e)}),this.idTensor=_i(0),this.maxNumElements=r,ia(this.idTensor)}copy(){return new Yv([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Gv(e,this.elementShape,"TensorList shape mismatch: ");const r=qv(this.elementShape,this.tensors,e);return sa(()=>{const e=this.tensors.map(e=>au(e,r));return ih(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=qv(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,Gv(r.shape,e,"TensorList shape mismatch: "),au(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Gv(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ia(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Yv([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);Gv(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=qv(this.elementShape,this.tensors,t);return au(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Gv(this.elementShape,t.shape,"TensorList shape mismatch: "),ia(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Gv(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=qv(this.elementShape,this.tensors,n);return 0===e.length?Qs([],[0].concat(r)):sa(()=>{const t=e.map(e=>au(this.tensors[e],r));return ih(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Gv(this.elementShape,t,"TensorList shape mismatch: ");const n=qv(this.elementShape,this.tensors,t);return 0===this.size()?Qs([],[0].concat(n)):sa(()=>{const e=this.tensors.map(e=>au(e,n));return uu(e,0)})}}function Zv(e,t,n){const[r,s]=nv("fusedOps",e,t,n),a="biasadd"===r,i=!a,o="prelu"===s,u="fusedbatchnorm"===r,l=nv("numArgs",e,t,n);if(a){if(o&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=nv("strides",e,t,n),h=uv(e,t,n),d=nv("dataFormat",e,t,n).toUpperCase(),p=nv("dilations",e,t,n);let[f,m]=nv("args",e,t,n);return i&&(m=f,f=void 0),{stride:c,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:nv("leakyreluAlpha",e,t,n)}}function Jv(e,t,n){return{boxes:nv("boxes",e,t,n),scores:nv("scores",e,t,n),maxOutputSize:nv("maxOutputSize",e,t,n),iouThreshold:nv("iouThreshold",e,t,n),scoreThreshold:nv("scoreThreshold",e,t,n),softNmsSigma:nv("softNmsSigma",e,t,n)}}class Qv{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=_i(0),this.tensorMap=new Map,ia(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return _i(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),sa(()=>{const e=kh(t),r=n.length,s=e.length;R(r===s,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`);for(let t=0;t<r;t++){const r=n[t],s=e[t];ia(s),this.tensorMap.set(r,s)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return sa(()=>{const e=[];for(let r=0;r<n.length;r++){const s=n[r],a=this.findWithDefault(s,t);e.push(a)}return ih(e)})}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function e_(e,t,n,r,s=sa){const a=((e,t,n)=>{switch(e.category){case"arithmetic":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(nv("a",e,t,n),nv("b",e,t,n))];case"AddN":return[r.addN(nv("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(nv("a",e,t,n),nv("b",e,t,n))];case"Mul":return[r.mul(nv("a",e,t,n),nv("b",e,t,n))];case"RealDiv":case"Div":return[r.div(nv("a",e,t,n),nv("b",e,t,n))];case"DivNoNan":return[r.divNoNan(nv("a",e,t,n),nv("b",e,t,n))];case"FloorDiv":return[r.floorDiv(nv("a",e,t,n),nv("b",e,t,n))];case"Sub":return[r.sub(nv("a",e,t,n),nv("b",e,t,n))];case"Minimum":return[r.minimum(nv("a",e,t,n),nv("b",e,t,n))];case"Maximum":return[r.maximum(nv("a",e,t,n),nv("b",e,t,n))];case"Pow":return[r.pow(nv("a",e,t,n),nv("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(nv("a",e,t,n),nv("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"basic_math":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(nv("x",e,t,n))];case"Acos":return[r.acos(nv("x",e,t,n))];case"Acosh":return[r.acosh(nv("x",e,t,n))];case"Asin":return[r.asin(nv("x",e,t,n))];case"Asinh":return[r.asinh(nv("x",e,t,n))];case"Atan":return[r.atan(nv("x",e,t,n))];case"Atan2":return[r.atan2(nv("x",e,t,n),nv("y",e,t,n))];case"Atanh":return[r.atanh(nv("x",e,t,n))];case"Ceil":return[r.ceil(nv("x",e,t,n))];case"Complex":return[r.complex(nv("real",e,t,n),nv("imag",e,t,n))];case"Cos":return[r.cos(nv("x",e,t,n))];case"Cosh":return[r.cosh(nv("x",e,t,n))];case"Elu":return[r.elu(nv("x",e,t,n))];case"Erf":return[r.erf(nv("x",e,t,n))];case"Exp":return[r.exp(nv("x",e,t,n))];case"Expm1":return[r.expm1(nv("x",e,t,n))];case"Floor":return[r.floor(nv("x",e,t,n))];case"Log":return[r.log(nv("x",e,t,n))];case"Log1p":return[r.log1p(nv("x",e,t,n))];case"Imag":return[r.imag(nv("x",e,t,n))];case"Neg":return[r.neg(nv("x",e,t,n))];case"Reciprocal":return[r.reciprocal(nv("x",e,t,n))];case"Real":return[r.real(nv("x",e,t,n))];case"Relu":return[r.relu(nv("x",e,t,n))];case"Round":return[r.round(nv("x",e,t,n))];case"Selu":return[r.selu(nv("x",e,t,n))];case"Sigmoid":return[r.sigmoid(nv("x",e,t,n))];case"Sin":return[r.sin(nv("x",e,t,n))];case"Sign":return[r.sign(nv("x",e,t,n))];case"Sinh":return[r.sinh(nv("x",e,t,n))];case"Softplus":return[r.softplus(nv("x",e,t,n))];case"Sqrt":return[r.sqrt(nv("x",e,t,n))];case"Square":return[r.square(nv("x",e,t,n))];case"Tanh":return[r.tanh(nv("x",e,t,n))];case"Tan":return[r.tan(nv("x",e,t,n))];case"ClipByValue":return[r.clipByValue(nv("x",e,t,n),nv("clipValueMin",e,t,n),nv("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(nv("x",e,t,n))];case"Rsqrt":return[r.rsqrt(rv(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(nv("x",e,t,n),nv("alpha",e,t,n))];case"Prelu":return[r.prelu(nv("x",e,t,n),nv("alpha",e,t,n))];case"IsNan":return[r.isNaN(rv(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(rv(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(rv(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"control":return(async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=nv("thenBranch",e,t,n),s=nv("elseBranch",e,t,n),a=nv("cond",e,t,n),i=nv("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=nv("body",e,t,n),s=nv("cond",e,t,n),a=nv("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map(e=>e.id);let u=await i[0].data();i.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()});let l=a;for(;u[0];){const e=l;l=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map(e=>e.id);e.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()});const a=await n.functionMap[s].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);u=await a[0].data(),a.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()})}return l}case"LoopCond":return[lv(nv("pred",e,t,n))];case"Switch":{const r=nv("pred",e,t,n);let s=nv("data",e,t,n);return s.kept||(s=lv(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=e.inputNames.find(e=>void 0!==rv(e,t,n));return r?[lv(rv(r,t,n))]:void 0}case"Enter":{const r=nv("frameName",e,t,n),s=nv("tensor",e,t,n);return n.enterFrame(r),[lv(s)]}case"Exit":{const r=nv("tensor",e,t,n);return n.exitFrame(),[lv(r)]}case"NextIteration":{const r=nv("tensor",e,t,n);return n.nextIteration(),[lv(r)]}case"TensorArrayV3":{const r=nv("size",e,t,n),s=nv("dtype",e,t,n),a=nv("elementShape",e,t,n),i=nv("dynamicSize",e,t,n),o=nv("clearAfterRead",e,t,n),u=nv("identicalElementShapes",e,t,n),l=nv("name",e,t,n),c=new Xv(l,s,r,a,u,i,o);return n.addTensorArray(c),[c.idTensor,_i(1)]}case"TensorArrayWriteV3":{const r=nv("tensorArrayId",e,t,n),s=nv("index",e,t,n),a=nv("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{const r=nv("tensorArrayId",e,t,n),s=nv("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=nv("tensorArrayId",e,t,n),s=nv("indices",e,t,n),a=nv("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=nv("tensorArrayId",e,t,n),s=nv("indices",e,t,n),a=nv("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{const r=nv("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=nv("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=nv("tensorArrayId",e,t,n),s=nv("tensor",e,t,n),a=nv("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{const r=nv("tensorArrayId",e,t,n);return[_i(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=nv("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=nv("tensorListId",e,t,n),s=nv("index",e,t,n),a=nv("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{const r=nv("tensorListId",e,t,n),s=nv("index",e,t,n),a=nv("elementShape",e,t,n),i=nv("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=nv("indices",e,t,n),s=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new Yv([],n,e.dtype,r),i=kh(e,0);return t.forEach((e,t)=>{a.setItem(e,i[t])}),a}(nv("tensor",e,t,n),r,nv("elementShape",e,t,n),nv("numElements",e,t,n));return n.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=nv("elementShape",e,t,n),s=nv("elementDType",e,t,n);let a;a="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=nv(a,e,t,n),o=function(e,t,n,r){return new Yv([],e,t,r)}(r,s,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const r=nv("tensorListId",e,t,n),s=nv("indices",e,t,n),a=nv("elementShape",e,t,n),i=nv("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{const r=nv("tensorListId",e,t,n),s=nv("elementShape",e,t,n),a=nv("elementDType",e,t,n),i=nv("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);Gv(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=kh(e);return new Yv(s,t,r)}(nv("tensor",e,t,n),nv("elementShape",e,t,n),nv("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=nv("tensorListId",e,t,n),s=n.getTensorList(r.id),a=nv("dtype",e,t,n),i=nv("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{const r=nv("tensorListId",e,t,n),s=nv("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=nv("tensorListId",e,t,n),s=nv("elementShape",e,t,n),a=nv("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=nv("tensor",e,t,n),s=nv("elementShape",e,t,n),a=function(e,t,n){let r=0;const s=t.map(e=>(r+=e,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const a=Kv(e.shape.slice(1),n),i=0===r?0:e.size/r,o=sa(()=>{const n=[];e=au(e,[1,r,i]);for(let r=0;r<t.length;++r){const o=[0,0===r?0:s[r-1],0],u=[1,t[r],i];n[r]=au(hu(e,o,u),a)}return e.dispose(),n}),u=new Yv([],n,e.dtype,t.length);for(let e=0;e<o.length;e++)u.setItem(e,o[e]);return u}(r,nv("lengths",e,t,n),s);return n.addTensorList(a),[a.idTensor]}case"TensorListLength":{const r=nv("tensorListId",e,t,n);return[_i(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{const r=nv("tensorListId",e,t,n),s=nv("size",e,t,n),a=n.getTensorList(r.id).resize(s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"convolution":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"Conv1D":{const s=nv("stride",e,t,n),a=nv("pad",e,t,n),i=nv("dataFormat",e,t,n).toUpperCase(),o=nv("dilation",e,t,n);return[r.conv1d(nv("x",e,t,n),nv("filter",e,t,n),s,a,i,o)]}case"Conv2D":{const s=nv("strides",e,t,n),a=uv(e,t,n),i=nv("dataFormat",e,t,n).toUpperCase(),o=nv("dilations",e,t,n);return[r.conv2d(nv("x",e,t,n),nv("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:h}=Zv(e,t,n);return[r.fused.conv2d({x:nv("x",e,t,n),filter:nv("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:h}=Zv(e,t,n);return[r.fused.depthwiseConv2d({x:nv("x",e,t,n),filter:nv("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=nv("outputShape",e,t,n),a=nv("strides",e,t,n),i=uv(e,t,n);return[r.conv2dTranspose(nv("x",e,t,n),nv("filter",e,t,n),s,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=nv("strides",e,t,n),a=uv(e,t,n),i=nv("dilations",e,t,n),o=nv("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(nv("input",e,t,n),nv("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"Conv3D":{const s=nv("strides",e,t,n),a=nv("pad",e,t,n),i=nv("dataFormat",e,t,n).toUpperCase(),o=nv("dilations",e,t,n);return[r.conv3d(nv("x",e,t,n),nv("filter",e,t,n),[s[1],s[2],s[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{const s=nv("strides",e,t,n),a=nv("pad",e,t,n),i=nv("kernelSize",e,t,n);return[r.avgPool(nv("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=nv("strides",e,t,n),a=nv("pad",e,t,n),i=nv("kernelSize",e,t,n);return[r.maxPool(nv("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=nv("strides",e,t,n),a=nv("pad",e,t,n),i=nv("kernelSize",e,t,n),o=nv("includeBatchInIndex",e,t,n),{result:u,indexes:l}=r.maxPoolWithArgmax(nv("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a,o);return[u,l]}case"AvgPool3D":{const s=nv("strides",e,t,n),a=nv("pad",e,t,n),i=nv("kernelSize",e,t,n);return[r.avgPool3d(nv("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=nv("strides",e,t,n),a=nv("pad",e,t,n),i=nv("kernelSize",e,t,n);return[r.maxPool3d(nv("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=nv("strides",e,t,n),a=nv("pad",e,t,n),i=nv("dilations",e,t,n),o=s[1],u=s[2],l=i[1],c=i[2];return[r.dilation2d(nv("x",e,t,n),nv("filter",e,t,n),[o,u],a,[l,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"creation":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"Fill":{const s=nv("shape",e,t,n),a=nv("dtype",e,t,n),i=nv("value",e,t,n);return[r.fill(s,i,a)]}case"LinSpace":{const s=nv("start",e,t,n),a=nv("stop",e,t,n),i=nv("num",e,t,n);return[r.linspace(s,a,i)]}case"Multinomial":{const s=nv("logits",e,t,n),a=nv("numSamples",e,t,n),i=nv("seed",e,t,n);return[r.multinomial(s,a,i)]}case"OneHot":{const s=nv("indices",e,t,n),a=nv("depth",e,t,n),i=nv("onValue",e,t,n),o=nv("offValue",e,t,n),u=nv("dtype",e,t,n);return[r.oneHot(s,a,i,o,u)]}case"Ones":return[r.ones(nv("shape",e,t,n),nv("dtype",e,t,n))];case"OnesLike":return[r.onesLike(nv("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(nv("shape",e,t,n),nv("dtype",e,t,n),nv("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(nv("shape",e,t,n),nv("minval",e,t,n),nv("maxval",e,t,n),nv("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(nv("shape",e,t,n),nv("minval",e,t,n),nv("maxval",e,t,n),nv("seed",e,t,n))];case"Range":{const s=nv("start",e,t,n),a=nv("stop",e,t,n),i=nv("step",e,t,n);return[r.range(s,a,i,nv("dtype",e,t,n))]}case"TruncatedNormal":{const s=nv("shape",e,t,n),a=nv("mean",e,t,n),i=nv("stdDev",e,t,n),o=nv("seed",e,t,n);return[r.truncatedNormal(s,a,i,nv("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(nv("shape",e,t,n),nv("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(nv("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"dynamic":return(async(e,t,n,r,s=T)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=Jv(e,t,n),c=await s.image.nonMaxSuppressionWithScoreAsync(r,a,i,o,u,l);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=Jv(e,t,n),l=nv("padToMaxOutputSize",e,t,n),c=await s.image.nonMaxSuppressionPaddedAsync(r,a,i,o,u,l);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=Jv(e,t,n);return[await s.image.nonMaxSuppressionAsync(r,a,i,o,u)]}case"Where":{const r=s.cast(nv("condition",e,t,n),"bool"),a=[await s.whereAsync(r)];return r.dispose(),a}case"ListDiff":return s.setdiff1dAsync(nv("x",e,t,n),nv("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"evaluation":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"LowerBound":{const s=nv("sortedSequence",e,t,n),a=nv("values",e,t,n);return[r.lowerBound(s,a)]}case"TopKV2":{const s=nv("x",e,t,n),a=nv("k",e,t,n),i=nv("sorted",e,t,n),o=r.topk(s,a,i);return[o.values,o.indices]}case"UpperBound":{const s=nv("sortedSequence",e,t,n),a=nv("values",e,t,n);return[r.upperBound(s,a)]}case"Unique":{const s=nv("x",e,t,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=nv("x",e,t,n),a=nv("axis",e,t,n),i=r.unique(s,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"image":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"ResizeBilinear":{const s=nv("images",e,t,n),a=nv("size",e,t,n),i=nv("alignCorners",e,t,n),o=nv("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(s,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{const s=nv("images",e,t,n),a=nv("size",e,t,n),i=nv("alignCorners",e,t,n),o=nv("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],i,o)]}case"CropAndResize":{const s=nv("image",e,t,n),a=nv("boxes",e,t,n),i=nv("boxInd",e,t,n),o=nv("cropSize",e,t,n),u=nv("method",e,t,n),l=nv("extrapolationValue",e,t,n);return[r.image.cropAndResize(s,a,i,o,u,l)]}case"ImageProjectiveTransformV3":{const s=nv("images",e,t,n),a=nv("transforms",e,t,n),i=nv("outputShape",e,t,n),o=nv("fillValue",e,t,n),u=nv("interpolation",e,t,n),l=nv("fillMode",e,t,n);return[r.image.transform(s,a,u.toLowerCase(),l.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"graph":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const s=nv("default",e,t,n);return[rv(e.name,t,n)||s];case"Placeholder":return[rv(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[lv(nv("x",e,t,n))];case"IdentityN":return nv("x",e,t,n).map(e=>lv(e));case"Shape":return[r.tensor1d(nv("x",e,t,n).shape,"int32")];case"ShapeN":return nv("x",e,t,n).map(e=>r.tensor1d(e.shape));case"Size":return[r.scalar(nv("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(nv("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const a=nv("x",e,t,n),i=nv("data",e,t,n),o=nv("message",e,t,n),u=nv("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,u));return[a];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"logical":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"Equal":return[r.equal(nv("a",e,t,n),nv("b",e,t,n))];case"NotEqual":return[r.notEqual(nv("a",e,t,n),nv("b",e,t,n))];case"Greater":return[r.greater(nv("a",e,t,n),nv("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(nv("a",e,t,n),nv("b",e,t,n))];case"Less":return[r.less(nv("a",e,t,n),nv("b",e,t,n))];case"LessEqual":return[r.lessEqual(nv("a",e,t,n),nv("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(nv("a",e,t,n),nv("b",e,t,n))];case"LogicalNot":return[r.logicalNot(nv("a",e,t,n))];case"LogicalOr":return[r.logicalOr(nv("a",e,t,n),nv("b",e,t,n))];case"Select":case"SelectV2":return[r.where(nv("condition",e,t,n),nv("a",e,t,n),nv("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(nv("a",e,t,n),nv("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"matrices":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(nv("a",e,t,n),nv("b",e,t,n),nv("transposeA",e,t,n),nv("transposeB",e,t,n))];case"Einsum":return[r.einsum(nv("equation",e,t,n),...nv("tensors",e,t,n))];case"Transpose":return[r.transpose(nv("x",e,t,n),nv("perm",e,t,n))];case"_FusedMatMul":const[s,a]=nv("fusedOps",e,t,n),i="biasadd"===s,o="prelu"===a,u=nv("numArgs",e,t,n),l=nv("leakyreluAlpha",e,t,n);if(i){if(o&&2!==u)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==u)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=nv("args",e,t,n);return[r.fused.matMul({a:nv("a",e,t,n),b:nv("b",e,t,n),transposeA:nv("transposeA",e,t,n),transposeB:nv("transposeB",e,t,n),bias:c,activation:a,preluActivationWeights:h,leakyreluAlpha:l})];case"MatrixBandPart":return[r.linalg.bandPart(nv("a",e,t,n),nv("numLower",e,t,n),nv("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"normalization":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(nv("x",e,t,n),nv("axis",e,t,n),nv("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(nv("x",e,t,n),nv("mean",e,t,n),nv("variance",e,t,n),nv("offset",e,t,n),nv("scale",e,t,n),nv("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(nv("x",e,t,n),nv("radius",e,t,n),nv("bias",e,t,n),nv("alpha",e,t,n),nv("beta",e,t,n))];case"Softmax":return[r.softmax(nv("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(nv("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"ragged":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(nv("paramsNestedSplits",e,t,n),nv("paramsDenseValues",e,t,n),nv("indices",e,t,n),nv("outputRaggedRank",e,t,n));return s.concat(a)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(nv("starts",e,t,n),nv("limits",e,t,n),nv("splits",e,t,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(nv("shape",e,t,n),nv("values",e,t,n),nv("defaultValue",e,t,n),nv("rowPartitionTensors",e,t,n),nv("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"reduction":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"Max":{const s=nv("axis",e,t,n),a=nv("keepDims",e,t,n);return[r.max(nv("x",e,t,n),s,a)]}case"Mean":{const s=nv("axis",e,t,n),a=nv("keepDims",e,t,n);return[r.mean(nv("x",e,t,n),s,a)]}case"Min":{const s=nv("axis",e,t,n),a=nv("keepDims",e,t,n);return[r.min(nv("x",e,t,n),s,a)]}case"Sum":{const s=nv("axis",e,t,n),a=nv("keepDims",e,t,n);return[r.sum(nv("x",e,t,n),s,a)]}case"All":{const s=nv("axis",e,t,n),a=nv("keepDims",e,t,n);return[r.all(nv("x",e,t,n),s,a)]}case"Any":{const s=nv("axis",e,t,n),a=nv("keepDims",e,t,n);return[r.any(nv("x",e,t,n),s,a)]}case"ArgMax":{const s=nv("axis",e,t,n);return[r.argMax(nv("x",e,t,n),s)]}case"ArgMin":{const s=nv("axis",e,t,n);return[r.argMin(nv("x",e,t,n),s)]}case"Prod":{const s=nv("axis",e,t,n),a=nv("keepDims",e,t,n);return[r.prod(nv("x",e,t,n),s,a)]}case"Cumprod":{const s=nv("axis",e,t,n),a=nv("exclusive",e,t,n),i=nv("reverse",e,t,n);return[r.cumprod(nv("x",e,t,n),s,a,i)]}case"Cumsum":{const s=nv("axis",e,t,n),a=nv("exclusive",e,t,n),i=nv("reverse",e,t,n);return[r.cumsum(nv("x",e,t,n),s,a,i)]}case"Bincount":const s=nv("x",e,t,n),a=nv("weights",e,t,n),i=nv("size",e,t,n);return[r.bincount(s,a,i)];case"DenseBincount":{const s=nv("x",e,t,n),a=nv("weights",e,t,n),i=nv("size",e,t,n),o=nv("binaryOutput",e,t,n);return[r.denseBincount(s,a,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"slice_join":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"ConcatV2":case"Concat":{const s=nv("n",e,t,n),a=nv("axis",e,t,n);let i=nv("tensors",e,t,n);return i=i.slice(0,s),[r.concat(i,a)]}case"Gather":{const s=nv("x",e,t,n),a=nv("indices",e,t,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=nv("axis",e,t,n),a=nv("batchDims",e,t,n),i=nv("x",e,t,n),o=nv("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),s,a)]}case"Reverse":{const s=nv("dims",e,t,n),a=[];for(let e=0;e<s.length;e++)s[e]&&a.push(e);const i=nv("x",e,t,n);return[r.reverse(i,a)]}case"ReverseV2":{const s=nv("axis",e,t,n),a=nv("x",e,t,n);return[r.reverse(a,s)]}case"Slice":{const s=nv("begin",e,t,n),a=nv("size",e,t,n);return[r.slice(nv("x",e,t,n),s,a)]}case"StridedSlice":{const s=nv("begin",e,t,n),a=nv("end",e,t,n),i=nv("strides",e,t,n),o=nv("beginMask",e,t,n),u=nv("endMask",e,t,n),l=nv("ellipsisMask",e,t,n),c=nv("newAxisMask",e,t,n),h=nv("shrinkAxisMask",e,t,n),d=nv("x",e,t,n);return[r.stridedSlice(d,s,a,i,o,u,l,c,h)]}case"Pack":return sa(()=>{const s=nv("axis",e,t,n),a=nv("tensors",e,t,n),i=a[0].shape,o=r.squeeze(a[0]).shape,u=a.map(e=>{const t=M(e.shape,i);if(!t&&!M(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)});return[r.stack(u,s)]});case"Unpack":{const s=nv("axis",e,t,n),a=nv("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{const s=nv("reps",e,t,n);return[r.tile(nv("x",e,t,n),s)]}case"Split":case"SplitV":{const s=nv("axis",e,t,n),a=nv("numOrSizeSplits",e,t,n),i=nv("x",e,t,n);return r.split(i,a,s)}case"ScatterNd":{const s=nv("indices",e,t,n),a=nv("values",e,t,n),i=nv("shape",e,t,n);return[r.scatterND(s,a,i)]}case"GatherNd":{const s=nv("x",e,t,n),a=nv("indices",e,t,n);return[r.gatherND(s,a)]}case"SparseToDense":{const s=nv("sparseIndices",e,t,n),a=nv("outputShape",e,t,n),i=nv("sparseValues",e,t,n),o=nv("defaultValue",e,t,n);return[r.sparseToDense(s,i,a,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{const s=nv("indices",e,t,n),a=nv("values",e,t,n),i=nv("tensor",e,t,n);return[r.tensorScatterUpdate(i,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"sparse":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(nv("indices",e,t,n),nv("values",e,t,n),nv("denseShape",e,t,n),nv("defaultValue",e,t,n));return[s,a,i,o]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(nv("inputIndices",e,t,n),nv("inputShape",e,t,n),nv("newShape",e,t,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(nv("data",e,t,n),nv("indices",e,t,n),nv("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(nv("data",e,t,n),nv("indices",e,t,n),nv("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"spectral":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"FFT":return[r.fft(nv("x",e,t,n))];case"IFFT":return[r.ifft(nv("x",e,t,n))];case"RFFT":return[r.rfft(nv("x",e,t,n))];case"IRFFT":return[r.irfft(nv("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"string":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(nv("input",e,t,n),nv("pattern",e,t,n),nv("rewrite",e,t,n),nv("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(nv("data",e,t,n),nv("dataSplits",e,t,n),nv("separator",e,t,n),nv("nGramWidths",e,t,n),nv("leftPad",e,t,n),nv("rightPad",e,t,n),nv("padWidth",e,t,n),nv("preserveShortSequences",e,t,n));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:i}=r.string.stringSplit(nv("input",e,t,n),nv("delimiter",e,t,n),nv("skipEmpty",e,t,n));return[s,a,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(nv("input",e,t,n),nv("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"transformation":return s(()=>((e,t,n,r=T)=>{switch(e.op){case"Cast":return[r.cast(nv("x",e,t,n),nv("dtype",e,t,n))];case"ExpandDims":{const s=nv("axis",e,t,n);return[r.expandDims(nv("x",e,t,n),s)]}case"Squeeze":{const s=nv("axis",e,t,n);return[r.squeeze(nv("x",e,t,n),s)]}case"Reshape":return[r.reshape(nv("x",e,t,n),nv("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(nv("x",e,t,n),nv("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(nv("x",e,t,n),nv("padding",e,t,n),nv("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(nv("x",e,t,n),nv("padding",e,t,n),nv("constantValue",e,t,n))];case"SpaceToBatchND":{const s=nv("blockShape",e,t,n),a=nv("paddings",e,t,n);return[r.spaceToBatchND(nv("x",e,t,n),s,a)]}case"BatchToSpaceND":{const s=nv("blockShape",e,t,n),a=nv("crops",e,t,n);return[r.batchToSpaceND(nv("x",e,t,n),s,a)]}case"DepthToSpace":{const s=nv("blockSize",e,t,n),a=nv("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(nv("x",e,t,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(nv("x",e,t,n),nv("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(nv("s0",e,t,n),nv("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(e.name);if(null!=s)return[s];{const s=nv("keyDType",e,t,n),a=nv("valueDType",e,t,n),i=new Qv(s,a);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=nv("tableHandle",e,t,n,r),a=nv("keys",e,t,n),i=nv("values",e,t,n),o=r.getHashTableById(s.id);return[await o.import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=nv("tableHandle",e,t,n,r),a=nv("keys",e,t,n),i=nv("defaultValue",e,t,n),o=r.getHashTableById(s.id);return[await o.find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=nv("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":const a=tv(e.op);if(a&&a.customExecutor)return a.customExecutor(new jv(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return le(a)?a.then(e=>[].concat(e)):[].concat(a)}class t_{constructor(e={},t={},n={},r={},s){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function n_(e,t,n,r){const s=new Set,a=[];let i=null,o=null;const u=new Set,l=new Set(Object.keys(e).map(e=>ov(e)[0]));r=r||[];const c=new Set(r.map(e=>ov(e.name)[0])),h=[...t];for(;h.length>0;){const e=h.pop();(o_(e)||u_(e)||l_(e))&&null==i&&(i=e,o=i.children.map(e=>e.name).filter(e=>s.has(e))),s.add(e.name),null==n[e.name]&&(l.has(e.name)||c.has(e.name)||(0!==e.inputs.length?e.inputs.forEach(e=>{u.has(e.name)||(u.add(e.name),h.push(e))}):a.push(e.name)))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}class r_ extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}const s_=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),a_=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),i_=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function o_(e){return s_.has(e.op)}function u_(e){return a_.has(e.op)}function l_(e){return i_.has(e.op)}class c_{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new c_(e.functions[t],this)})}getCompilationKey(e,t){const n=e.map(e=>e.name).sort(),r=t.map(e=>e.name).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const n=n_(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:a}=n;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const n=t.map(e=>e.name),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${s}]. Missing the following inputs: [${r}]`)}const i=function(e,t){const{usedNodes:n,inputs:r}=t,s=Object.keys(r).map(e=>ov(e)[0]).map(t=>e.nodes[t]),a=e.initNodes||[],i=e=>n.has("string"==typeof e?e:e.name);function o(e){return[...new Map(e.map(e=>[e.name,e])).values()]}const u=o([...s,...e.weights,...a]).filter(i),l=o([...u,...Object.values(e.nodes)]).filter(i),c=new Map(l.map(e=>[e.name,e])),h={};for(const e of l){h[e.name]=h[e.name]||0;for(const t of e.children)i(t)||(h[t.name]=Number.POSITIVE_INFINITY),h[t.name]=(h[t.name]||0)+1}const d=Object.entries(h).filter(([,e])=>0===e).map(([e])=>e),p=[...d];for(;d.length>0;){const e=d.pop(),t=c.get(e);for(const e of t.children.filter(i))0===--h[e.name]&&(p.push(e.name),d.push(e.name))}const f=function(e,t){const n=new Map(e.map(e=>[e.name,e])),r=t.map(e=>e.name),s=new Set(r);for(;r.length>0;){const e=r.pop(),t=n.get(e);for(const e of t.children)n.has(e.name)&&!s.has(e.name)&&(s.add(e.name),r.push(e.name))}return e.filter(e=>s.has(e.name))}(p.map(e=>c.get(e)),u);return function(e,t){const n=new Map(e.map((e,t)=>[e.name,t])),r=new Set(t.map(e=>e.name)),s=e=>r.has("string"==typeof e?e:e.name),a=new Set(e.map(e=>e.name)),i=e=>a.has("string"==typeof e?e:e.name);for(const t of e){for(const e of t.children.filter(i)){if(!n.has(e.name))throw new r_(`Child ${e.name} of node ${t.name} is unreachable.`);if(n.get(t.name)>n.get(e.name))throw new r_(`Node ${t.name} is scheduled to run after its child ${e.name}.`)}if(!s(t))for(const e of t.inputs){if(!n.has(e.name))throw new r_(`Input ${e.name} of node ${t.name} is unreachable.`);if(n.get(e.name)>n.get(t.name))throw new r_(`Node ${t.name} is scheduled to run before its input ${e.name}.`)}}}(f,u),f}(this.graph,n),o=function(e){const t=new Map(e.map((e,t)=>[e.name,t])),n=Number.MAX_SAFE_INTEGER,r=e.map((e,t)=>o_(e)?n:t),s=e=>{const n=r[t.get(e.name)];return null==n?-1:n},a=e.map((e,t)=>e.children.map(s).reduce((e,t)=>Math.max(e,t),r[t])),i=new Map;for(let t=0;t<e.length;++t){const r=a[t];if(r===n)continue;const s=e[t],o=e[r];i.has(o.name)||i.set(o.name,[]),i.get(o.name).push(s)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return ia(t),t}cloneTensorList(e){if(!e)return null;const t=e.map(e=>this.cloneAndKeepTensor(e));return t}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([e,t])=>[e,this.cloneTensorList(t)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map(e=>this.graph.nodes[ov(e)[0]]),s=t.map(e=>ov(e)[0]),a=new Set(s);let i=s.map(e=>this.graph.nodes[e]);0===i.length&&(i=this._outputs);const o=this.getCompilationKey(r,i);let u=this.compiledMap.get(o);null==u&&(u=this.compile(e,i),this.compiledMap.set(o,u));try{this.keepIntermediateTensors=pe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}const l={},c={};return sa(()=>{const n=new t_(this.weightMap,l,c,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(t=>{const[s,a]=ov(t,n),i=[];i[a]=e[t],r[s]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[s]=this.cloneTensorList(i))});const s=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=u;for(const e of i){if(r[e.name])continue;const t=e_(e,r,n,this._resourceManager);if(le(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,s,a,o.get(e.name))}return null==this.parent&&n.dispose(s),t.map(e=>rv(e,r,n))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id)));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,a,i){if(!o_(t)&&!a.has(e)){for(const r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(const e of t.inputs){if(o_(e))continue;const t=sv(e.name,n,r);if(null!=t)for(const e of t){if(!e||e.kept||s.has(e.id))continue;const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,s,a){function i(e){return o_(e)||s.has(e.name)}if(!o_(e)&&null!=a)for(const e of a){if(i(e))continue;const s=sv(e.name,t,n);for(const e of s)!e||e.kept||r.has(e.id)||e.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,r={},s={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=pe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}const a=new t_(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,a,t,n),o=t.map(e=>rv(e,i,a)),u=o.map(e=>e.id),l=Object.keys(e).map(t=>e[t].id),c=new Set([...u,...l,...this.weightIds]);return Object.values(i).forEach(e=>{e.forEach(e=>{!e||e.isDisposed||c.has(e.id)||e.dispose()})}),null==this.parent&&a.dispose(c),o}async executeFunctionAsync(e,t,n){const r=e.reduce((e,t,n)=>(e[this.inputs[n].name]=t,e),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const s=Object.keys(e),a=s.map(e=>this.graph.nodes[ov(e)[0]]),i=n.map(e=>ov(e)[0]),o=new Set(i);let u=i.map(e=>this.graph.nodes[e]);0===u.length&&(u=this._outputs);const{usedNodes:l,missingInputs:c,dynamicNode:h,syncInputs:d}=n_(e,u,this.weightMap,this._initNodes),p=[...a,...this.graph.weights,...this._initNodes||[]].map(e=>({node:e,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{const[n,r]=ov(t),s=[];s[r]=e[t],f[n]=s});const m={},g=this.getFrozenTensorIds(f),b={};for(;p.length>0;){const e=this.processStack(a,p,t,f,b,g,o,m,l);await Promise.all(e)}null!=h||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const y=u.filter(e=>!o_(e)&&!rv(e.name,f,t)).map(e=>e.name);if(y.length>0){let e="";throw null!=h&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${y}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${e}`)}return f}processStack(e,t,n,r,s,a,i,o,u){const l=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&nv("isConstant",e.node,r,n)&&([c]=av(e.node.name,n)),null==r[e.node.name]){const h=e_(e.node,r,n,this._resourceManager);c||([c]=av(e.node.name,n));const d=n.currentContext;le(h)?l.push(h.then(l=>(r[c]=l,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(l)),n.currentContext=d,this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,u),l))):(r[c]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(h)),this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,u))}else this.processChildNodes(e.node,t,n,r,s,u)}return l}processChildNodes(e,t,n,r,s,a){e.children.forEach(e=>{const[i]=av(e.name,n);!s[i]&&a.has(e.name)&&("Merge"===e.op?e.inputNames.some(e=>!!rv(e,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every(e=>!!rv(e,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const n=e[t],[r]=ov(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const e=s.attrParams.shape.value;R(e.length===n.shape.length&&n.shape.every((t,n)=>-1===e[n]||e[n]===t),()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&R(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){var t,n;const r={};for(const s in e){const a=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[s];null!=a?r[a.name]=e[s]:r[s]=e[s]}return r}checkInputs(e){const t=Object.keys(e).filter(e=>{const[t]=ov(e);return null==this.graph.nodes[t]});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(e=>{var t,n;const r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e},{})}checkOutputs(e){e.forEach(e=>{const[t]=ov(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)})}}class h_{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class d_{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,n={},r=e){this.modelUrl=t,this.loadOptions=n,this.version="n/a",this.io=r,null==n&&(this.loadOptions={}),this.resourceManager=new h_}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return le(e)?e.then(e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await ba(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new c_($v.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=$v.Instance.transformGraph(e.modelInitializer);this.initializer=new c_(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t={};return(e instanceof ys?[e]:e).forEach((e,n)=>t[this.structuredOutputKeys[n]]=e),t}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof ys||Array.isArray(e))){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((t,n)=>{var s,a,i;const o=null===(i=null===(a=null===(s=this.signature)||void 0===s?void 0:s.inputs)||void 0===a?void 0:a[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){const s=t[n[r]];this.resourceIdToCapturedInput[s.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&aa(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function p_(e,t,n=new Map,r=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse){if(b_(e)){const s=Array.isArray(e)?[]:{};r.add(e);for(const a in e){const i=p_(e[a],t,n,r);s[a]=i}return r.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,s.value),s.value}function f_(e,t=g_){return m_(e,t)}function m_(e,t,n=new Set){const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse){if(b_(r)){const s=Array.isArray(r)?[]:{};n.add(r);for(const a in r){const r=m_(e.map(e=>e[a]),t,n);s[a]=r}return n.delete(r),s}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return s.value}function g_(e){return null===e?null:b_(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function b_(e){let t=!1;if(pe().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:n}=__webpack_require__(551);t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof ys)&&!(e instanceof Promise)&&!t)}function y_(e){return p_(e,x_)}function x_(e){return e instanceof ys?{value:e.clone(),recurse:!1}:b_(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class w_{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class v_ extends w_{constructor(){super(v_.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let e=0;e<n;e++)t[e]=this.get(this.wrap(this.begin+e));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}v_.INITIAL_CAPACITY=32;class __{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new C_(this,e)}filter(e){return new $_(this,e)}map(e){return new A_(this,e)}mapAsync(e){return new O_(this,e)}serialMapAsync(e){return new O_(this,e).serial()}flatmap(e){return new D_(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(e=>!0===e)}rowMajorBatch(e,t=!0){return new E_(this,e,t)}columnMajorBatch(e,t=!0,n=g_){return this.rowMajorBatch(e,t).map(e=>f_(e,n))}concatenate(e,t){return new F_(new k_([this,e]),t)}take(e){return e<0||null==e?this:new N_(this,e)}skip(e){return e<0||null==e?this:new I_(this,e)}prefetch(e){return new L_(this,e)}shuffle(e,t){return new z_(this,e,t)}serial(){return new S_(this)}}class k_ extends __{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:y_(e),done:!1}}}class T_ extends __{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class S_ extends __{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class I_ extends __{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;aa(e.value)}return this.upstream.next()}}class N_ extends __{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class E_ extends __{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class $_ extends __{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;aa(e.value)}}}class A_ extends __{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Rs(e.value),n=this.transform(e.value),r=Rs(n);for(const e of t)Os(e,r)||e.dispose();return{value:n,done:!1}}}class C_ extends __{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class O_ extends __{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Rs(e.value),n=await this.transform(e.value),r=Rs(n);for(const e of t)Os(e,r)||e.dispose();return{value:n,done:!1}}}class R_ extends __{constructor(){super(),this.outputQueue=new v_,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class D_ extends R_{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=Rs(e.value),n=this.transform(e.value),r=Rs(n);this.outputQueue.pushAll(n);for(const e of t)Os(e,r)||e.dispose();return!0}}class F_ extends __{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var P_,M_;(M_=P_||(P_={}))[M_.FAIL=0]="FAIL",M_[M_.SHORTEST=1]="SHORTEST",M_[M_.LONGEST=2]="LONGEST";class L_ extends __{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new w_(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class z_ extends L_{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=vc.alea(n||ts().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class B_{constructor(){this.size=null}batch(e,t=!0){const n=this;let r;return R(e>0,()=>`batchSize needs to be positive, but it is\n      ${e}`),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),U_(async()=>(await n.iterator()).columnMajorBatch(e,t,V_),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,U_(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,U_(async()=>(await t.iterator()).filter(t=>sa(()=>e(t))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return U_(async()=>(await t.iterator()).map(t=>sa(()=>e(t))),this.size)}mapAsync(e){const t=this;return U_(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return U_(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,U_(async()=>{return n=(s=async()=>({value:await t.iterator(),done:!1}),new T_(s)).take(e),new F_(n,r);var n,r,s},n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,U_(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,s=vc.alea(t||ts().toString());return U_(async()=>{let t=s.int32();return n&&(t+=s.int32()),(await r.iterator()).shuffle(e,t.toString())},this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,U_(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function U_(e,t=null){return new class extends B_{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function V_(e){if(null===e)return null;return null==(t=e[0])||null===(n=t)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(t)||"object"==typeof t&&t instanceof ys||ss(t)?{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof ys?ih(e):Qs(e)}(e),recurse:!1}:{value:null,recurse:!0};var t,n}function W_(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&R("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}B_.MAX_BUFFER_SIZE=1e4,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const j_=Ih;class G_ extends N{nextDataId(){return G_.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new I(this,na())}write(e,t,n){this.firstUse&&(this.firstUse=!1,pe().get("IS_NODE")&&Er("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&X(n[0])){const s=n.map(e=>ns(e));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);return"complex64"===t?xp(this.readSync(n.real.dataId),this.readSync(n.imag.dataId)):function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map(e=>rs(e));return ci(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return ci(e.shape,e.dtype,t)}makeOutput(e,t,n){return na().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=ts();return e(),{kernelMs:ts()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){W_([e],"where");const t=this.readSync(e.dataId);return j_(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function H_(e){return(t,n,r)=>{const s=H(n,t.length);for(let n=0;n<t.length;++n)s[n]=e(t[n],r);return s}}function q_(e,t,n){return K_(e,H_(t),n)}function K_(e,t,n){return({inputs:r,attrs:s,backend:a})=>{const{x:i}=r;W_(i,e);const o=a,u=o.data.get(i.dataId).values;let l;if("string"===i.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");l=Qp(u)}else l=u;const c=n||i.dtype,h=t(l,c,s);return o.makeTensorInfo(i.shape,c,h)}}G_.nextDataId=0,ua("cpu",()=>new G_,1);const X_=q_(mt,e=>e>=0?e:Math.exp(e)-1),Y_={kernelName:mt,backendName:"cpu",kernelFunc:X_};function Z_(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const J_={kernelName:Ot,backendName:"cpu",kernelFunc:Z_};function Q_(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;W_([s],"leakyRelu");const i=P(s.shape),o=n.data.get(s.dataId).values,u=G("float32",i);for(let e=0;e<o.length;e++)u[e]=o[e]<0?a*o[e]:o[e];return n.makeTensorInfo(s.shape,"float32",u)}const ek={kernelName:Lt,backendName:"cpu",kernelFunc:Q_};function tk(e){return(t,n,r,s,a)=>{const i=Li(t,n),o=i.length,u=ee(i),l=G(a,P(i)),c=t.length,h=n.length,d=ee(t),p=ee(n),f=Pi(t,i),m=Pi(n,i);if(f.length+m.length===0)for(let t=0;t<l.length;++t)l[t]=e(r[t%r.length],s[t%s.length]);else for(let t=0;t<l.length;++t){const n=ue(t,o,u),a=n.slice(-c);f.forEach(e=>a[e]=0);const i=oe(a,c,d),g=n.slice(-h);m.forEach(e=>g[e]=0);const b=oe(g,h,p);l[t]=e(r[i],s[b])}return[l,i]}}const nk=tk((e,t)=>e<0?t*e:e);function rk(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;W_([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,u]=nk(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(u,"float32",o)}const sk={kernelName:wn,backendName:"cpu",kernelFunc:rk},ak=q_(En,e=>Math.max(0,e)),ik={kernelName:En,backendName:"cpu",kernelFunc:ak},ok=q_(Dn,e=>Math.min(Math.max(0,e),6)),uk={kernelName:Dn,backendName:"cpu",kernelFunc:ok},lk=H_(e=>1/(1+Math.exp(-e))),ck=q_(qn,e=>1/(1+Math.exp(-e))),hk={kernelName:qn,backendName:"cpu",kernelFunc:ck};function dk(e,t,n,r,s){if("linear"===n)return Z_({inputs:{x:t},backend:e});if("relu"===n)return ak({inputs:{x:t},backend:e});if("elu"===n)return X_({inputs:{x:t},backend:e});if("relu6"===n)return ok({inputs:{x:t},backend:e});if("prelu"===n)return rk({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return Q_({inputs:{x:t},backend:e,attrs:{alpha:s}});if("sigmoid"===n)return ck({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function pk(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const fk={kernelName:je,backendName:"cpu",kernelFunc:pk};function mk(e,t,n="float32"){if("complex64"===n)return pk({inputs:{real:mk(e,t,"float32"),imag:mk(e,t,"float32")},backend:e});const r=se(P(t),n);return e.makeTensorInfo(t,n,r)}function gk(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const bk={kernelName:In,backendName:"cpu",kernelFunc:gk};function yk(e,t,n,r){if("int32"===r)return[t,"int32",Int32Array.from(e)];if("bool"===r){const r=es([0],n),[s,a]=tk((e,t)=>e!==t?1:0)(t,[],e,r,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function xk(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if("complex64"===a){if("complex64"===s.dtype)return Z_({inputs:{x:s},backend:n});const e=mk(n,s.shape,s.dtype),t=xk({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=pk({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=gk({inputs:{input:s},backend:n}),t=xk({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!q(s.dtype,a)){const e=Z_({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}const i=n.data.get(s.dataId).values,[o,u,l]=yk(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,u,l)}const wk={kernelName:Ue,backendName:"cpu",kernelFunc:xk};function vk(e,t,n,r){return null==n?({inputs:n,backend:s})=>{const{a,b:i}=n,o=s;W_([a,i],e);const u=o.data.get(a.dataId).values,l=o.data.get(i.dataId).values,c="string"===a.dtype?Qp(u):u,h="string"===a.dtype?Qp(l):l,d=r||a.dtype,[p,f]=t(a.shape,i.shape,c,h,d);return o.makeTensorInfo(f,d,p)}:({inputs:e,backend:s})=>{const{a,b:i}=e,o=s;if("complex64"===a.dtype||"complex64"===i.dtype){const e=xk({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,u=o.data.get(r.dataId).values,l=o.data.get(s.dataId).values,c=xk({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),h=o.data.get(c.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=o.data.get(d.dataId).values,m=o.data.get(p.dataId).values,[g,b,y]=n(a.shape,i.shape,u,l,f,m),x=o.makeTensorInfo(y,"float32",g),w=o.makeTensorInfo(y,"float32",b),v=pk({inputs:{real:x,imag:w},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(w),v}{const e=o.data.get(a.dataId).values,n=o.data.get(i.dataId).values,s=r||a.dtype,[u,l]=t(a.shape,i.shape,e,n,s);return o.makeTensorInfo(l,s,u)}}}function _k(e){return(t,n,r,s,a,i)=>{const o=Li(t,n),u=P(o),l=o.length,c=ee(o),h=G("float32",u),d=G("float32",u),p=Pi(t,o),f=Pi(n,o),m=xp(r,s),g=xp(a,i),b=t.length,y=ee(t),x=n.length,w=ee(n);if(p.length+f.length===0)for(let t=0;t<h.length;t++){const n=t%m.length,r=t%g.length,s=e(m[2*n],m[2*n+1],g[2*r],g[2*r+1]);h[t]=s.real,d[t]=s.imag}else for(let t=0;t<h.length;t++){const n=ue(t,l,c),r=n.slice(-b);p.forEach(e=>r[e]=0);const s=oe(r,b,y),a=n.slice(-x);f.forEach(e=>a[e]=0);const i=oe(a,x,w),o=e(m[2*s],m[2*s+1],g[2*i],g[2*i+1]);h[t]=o.real,d[t]=o.imag}return[h,d,o]}}const kk=tk((e,t)=>e+t),Tk=_k((e,t,n,r)=>({real:e+n,imag:t+r})),Sk=vk(ve,kk,Tk),Ik={kernelName:ve,backendName:"cpu",kernelFunc:Sk};function Nk(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=P(s.shape),o=V(a,i),u=P(o);R(i===u,()=>`The new shape (${o}) has ${u} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);const l=n.data.get(s.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const Ek={kernelName:$n,backendName:"cpu",kernelFunc:Nk};function $k(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;W_([s,a],"matMul");const u=s.shape.length,l=a.shape.length,c=i?s.shape[u-2]:s.shape[u-1],h=o?a.shape[l-1]:a.shape[l-2],d=i?s.shape[u-1]:s.shape[u-2],p=o?a.shape[l-2]:a.shape[l-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=P(f),b=P(m),y=Li(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([d,p]);R(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);const x=o?[b,p,h]:[b,h,p],w=Nk({inputs:{x:s},backend:n,attrs:{shape:i?[g,c,d]:[g,d,c]}}),v=Nk({inputs:{x:a},backend:n,attrs:{shape:x}}),_=i?w.shape[1]:w.shape[2],k=i?w.shape[2]:w.shape[1],T=o?v.shape[1]:v.shape[2],S=Math.max(g,b),I=n.data.get(w.dataId).values,N=n.data.get(v.dataId).values,E=ee(w.shape),$=ee(v.shape),[A,C,O]=i?[E[0],1,E[1]]:[E[0],E[1],1],[D,F,M]=o?[1,$[1],$[0]]:[$[1],1,$[0]],L=k*T,z=ci([S,k,T],w.dtype),B=z.values,U=n.blockSize;for(let e=0;e<S;e++){const t=e%g,n=e%b;for(let r=0;r<k;r+=U){const s=Math.min(r+U,k);for(let a=0;a<T;a+=U){const i=Math.min(a+U,T);for(let o=0;o<_;o+=U){const u=Math.min(o+U,_);for(let l=r;l<s;l++)for(let r=a;r<i;r++){let s=0;for(let e=o;e<u;e++)s+=I[t*A+l*C+e*O]*N[e*D+r*F+n*M];B[e*L+(l*T+r)]+=s}}}}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(v),n.makeTensorInfo(y,z.dtype,z.values)}const Ak={kernelName:Pe,backendName:"cpu",kernelFunc:$k},Ck={kernelName:Sr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=r;let d,p,f;const m=[];d=$k({inputs:{a:s,b:a},attrs:{transposeA:u,transposeB:l},backend:n}),i&&(p=Sk({inputs:{a:d,b:i},backend:n}),m.push(d),d=p),c&&(f=dk(n,d,c,o,h),m.push(d),d=f);for(const e of m)n.disposeIntermediateTensorInfo(e);return d}};function Ok(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const Rk={kernelName:ye,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;W_(t,"abs");let r=new Float32Array(P(t.shape));return r=Ok(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}},Dk=q_(xe,e=>Math.acos(e)),Fk={kernelName:xe,backendName:"cpu",kernelFunc:Dk},Pk=q_(we,e=>Math.acosh(e)),Mk={kernelName:we,backendName:"cpu",kernelFunc:Pk},Lk={kernelName:_e,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;W_(t,"addN");const s=r.map(e=>n.data.get(e.dataId).values),a=ci(r[0].shape,r[0].dtype),i=a.values;for(let e=0;e<r.length;e++){const t=s[e];for(let e=0;e<i.length;e++)i[e]+=t[e]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}};function zk(e,t,n,r,s){const a=t.length,i=P(t),o=ee(t),u=ee(s),l=G(n,P(s));for(let t=0;t<i;++t){const n=ue(t,a,o),s=new Array(n.length);for(let e=0;e<s.length;e++)s[e]=n[r[e]];l[oe(s,a,u)]=e[t]}return l}function Bk(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;W_(s,"transpose");const i=s.shape.length,o=new Array(i);for(let e=0;e<o.length;e++)o[e]=s.shape[a[e]];const u=zk(r.data.get(s.dataId).values,s.shape,s.dtype,a,o);return{dataId:r.write(u,o,s.dtype),shape:o,dtype:s.dtype}}const Uk={kernelName:yr,backendName:"cpu",kernelFunc:Bk},Vk={kernelName:ke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;W_(s,"all");const o=W(a,s.shape);let u=o;const l=sl(u,s.shape.length);let c=s;null!=l&&(c=Bk({inputs:{x:s},backend:n,attrs:{perm:l}}),u=il(u.length,s.shape.length)),rl("all",u,c.shape.length);const[h,d]=tl(c.shape,u),p=P(d),f=se(P(h),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*p;let n=m[t];for(let e=0;e<p;++e){const r=m[t+e];n=n&&r}f[e]=n}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=Nk({inputs:{x:g},backend:n,attrs:{shape:nl(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},Wk={kernelName:Te,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;W_(s,"any");const o=W(a,s.shape);let u=o;const l=sl(u,s.shape.length);let c=s;null!=l&&(c=Bk({inputs:{x:s},backend:n,attrs:{perm:l}}),u=il(u.length,s.shape.length)),rl("any",u,c.shape.length);const[h,d]=tl(c.shape,u),p=P(d),f=se(P(h),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*p;let n=m[t];for(let e=0;e<p;++e){const r=m[t+e];n=n||r}f[e]=n}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=Nk({inputs:{x:g},backend:n,attrs:{shape:nl(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},jk={kernelName:Se,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;W_(s,"argMax");let i=W(a,s.shape);const o=sl(i,s.shape.length);let u=s;const l=[];null!=o&&(u=Bk({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),i=il(i.length,u.shape.length)),i=[i[0]],rl("argMax",i,u.shape.length);const[c,h]=tl(u.shape,i),d=se(P(c),"int32"),p=P(h),f=n.data.get(u.dataId).values;for(let e=0;e<d.length;++e){const t=e*p;let n=f[t],r=0;for(let e=0;e<p;++e){const s=f[t+e];s>n&&(n=s,r=e)}d[e]=r}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(c,"int32",d)}},Gk={kernelName:Ie,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;W_(s,"argMin");let i=W(a,s.shape);const o=sl(i,s.shape.length);let u=s;const l=[];null!=o&&(u=Bk({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),i=il(i.length,u.shape.length)),i=[i[0]],rl("argMin",i,u.shape.length);const[c,h]=tl(u.shape,i),d=se(P(c),"int32"),p=P(h),f=n.data.get(u.dataId).values;for(let e=0;e<d.length;++e){const t=e*p;let n=f[t],r=0;for(let e=0;e<p;++e){const s=f[t+e];s<n&&(n=s,r=e)}d[e]=r}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(c,"int32",d)}},Hk=q_(Ne,e=>Math.asin(e)),qk={kernelName:Ne,backendName:"cpu",kernelFunc:Hk},Kk=q_(Ee,e=>Math.asinh(e)),Xk={kernelName:Ee,backendName:"cpu",kernelFunc:Kk},Yk=q_($e,e=>Math.atan(e)),Zk={kernelName:$e,backendName:"cpu",kernelFunc:Yk},Jk=tk((e,t)=>Math.atan2(e,t)),Qk=vk(Ce,Jk),eT={kernelName:Ce,backendName:"cpu",kernelFunc:Qk},tT=q_(Ae,e=>Math.atanh(e)),nT={kernelName:Ae,backendName:"cpu",kernelFunc:tT};function rT(e,t,n,r,s,a){const i=s.strideHeight,o=s.strideWidth,u=s.dilationHeight,l=s.dilationWidth,c=s.effectiveFilterHeight,h=s.effectiveFilterWidth,d=s.padInfo.top,p=s.padInfo.left,f="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=ci(s.outShape,n),g=m.values,b=s.outShape[1]*s.outShape[2]*s.outShape[3],y=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let t=0;t<s.batchSize;++t){const n=t*b,m=t*r[0];for(let t=0;t<s.inChannels;++t)for(let b=0;b<s.outHeight;++b){const w=b*i-d,v=Math.max(0,w),_=Math.min(s.inHeight,c+w),k=n+b*y;for(let n=0;n<s.outWidth;++n){const i=n*o-p,c=Math.max(0,i),d=Math.min(s.inWidth,h+i);let b=f,y=0,w=0;for(let n=v;n<_;n+=u){const s=m+n*r[1];for(let n=c;n<d;n+=l){const i=e[s+n*r[2]+t];"max"===a&&i>b?b=i:"avg"===a&&(y+=i,w++)}if(isNaN(b))break}g[k+n*x+t]="avg"===a?y/w:b}}}return m}function sT(e,t,n,r,s=!1,a=!1){const i=ci(r.outShape,"int32"),o=r.strideHeight,u=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=ci(t,n,e);for(let e=0;e<r.batchSize;++e)for(let t=0;t<r.inChannels;++t)for(let n=0;n<r.outHeight;++n){const g=n*o-p;let b=g;for(;b<0;)b+=l;const y=Math.min(r.inHeight,h+g);for(let o=0;o<r.outWidth;++o){const h=o*u-f;let p=h;for(;p<0;)p+=c;const x=Math.min(r.inWidth,d+h);let w=Number.NEGATIVE_INFINITY,v=-1;for(let n=b;n<y;n+=l){const i=n-g;for(let o=p;o<x;o+=c){const u=o-h,l=m.get(e,n,o,t);l>w&&(w=l,v=s?a?((e*r.inHeight+n)*r.inWidth+o)*r.inChannels+t:(n*r.inWidth+o)*r.inChannels+t:i*d+u)}}i.set(v,e,n,o,t)}}return i}function aT(e,t,n,r,s,a){const i=s.strideDepth,o=s.strideHeight,u=s.strideWidth,l=s.dilationDepth,c=s.dilationHeight,h=s.dilationWidth,d=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,b=s.padInfo.left,y="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=ci(s.outShape,n),w=x.values,v=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],_=s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[3]*s.outShape[4],T=s.outShape[4];for(let t=0;t<s.batchSize;++t){const n=t*v,x=t*r[0];for(let t=0;t<s.inChannels;++t)for(let v=0;v<s.outDepth;++v){const S=v*i-m;let I=S;for(;I<0;)I+=l;const N=Math.min(s.inDepth,d+S),E=n+v*_;for(let n=0;n<s.outHeight;++n){const i=n*o-g;let d=i;for(;d<0;)d+=c;const m=Math.min(s.inHeight,p+i),v=E+n*k;for(let n=0;n<s.outWidth;++n){const i=n*u-b;let o=i;for(;o<0;)o+=h;const p=Math.min(s.inWidth,f+i),g=v+n*T;let _=y,k=0,S=0;for(let n=I;n<N;n+=l){const s=x+n*r[1];for(let n=d;n<m;n+=c){const i=s+n*r[2];for(let n=o;n<p;n+=h){const s=e[i+n*r[3]+t];if("max"===a&&s>_?_=s:"avg"===a&&(k+=s,S++),isNaN(_))break}if(isNaN(_))break}if(isNaN(_))break}w[g+t]="avg"===a?k/Math.max(S,1):_}}}}return x}const iT={kernelName:Oe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;W_(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r;R(tu(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=Go(s.shape,a,i,1,o,u);let c;if(1===l.filterWidth&&1===l.filterHeight&&M(l.inShape,l.outShape))c=Z_({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=ee(s.shape),r=rT(e,s.shape,s.dtype,t,l,"avg");c=n.makeTensorInfo(l.outShape,s.dtype,r.values)}return c}},oT={kernelName:De,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:l}=r;W_(s,"avgPool3d");const c=Ho(s.shape,a,i,1,o,u,l),h=aT(n.data.get(s.dataId).values,s.shape,s.dtype,ee(s.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}},uT={kernelName:Fe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:l}=r;W_([s,a],"avgPool3DGrad");const c=Ho(a.shape,i,o,1,u,l),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,b=c.dilationDepth,y=c.dilationHeight,x=c.dilationWidth,w=c.effectiveFilterDepth,v=c.effectiveFilterHeight,_=c.effectiveFilterWidth,k=w-1-c.padInfo.front,T=_-1-c.padInfo.left,S=v-1-c.padInfo.top,I=ci(a.shape,"float32"),N=1/(f*m*g),E=n.bufferSync(s);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inDepth;++n)for(let r=0;r<c.inHeight;++r)for(let s=0;s<c.inWidth;++s){const a=n-k,i=r-S,o=s-T;let u=0;for(let n=0;n<w;n+=b){const r=(a+n)/h;if(!(r<0||r>=c.outDepth||Math.floor(r)!==r))for(let n=0;n<v;n+=y){const s=(i+n)/d;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let n=0;n<_;n+=x){const a=(o+n)/p;a<0||a>=c.outWidth||Math.floor(a)!==a||(u+=E.get(e,r,s,a,t))}}}I.set(u*N,e,n,r,s,t)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}},lT={kernelName:Re,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;W_([s,a],"avgPoolGrad");const{filterSize:o,strides:u,pad:l}=r,c=Go(i.shape,o,u,1,l),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,b=c.effectiveFilterHeight,y=c.effectiveFilterWidth,x=y-1-c.padInfo.left,w=b-1-c.padInfo.top,v=ci(i.shape,"float32"),_=1/(p*f),k=n.data.get(s.dataId).values,T=ci(s.shape,"float32",k);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=n-w,a=r-x;let i=0;for(let n=0;n<b;n+=m){const r=(s+n)/h;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let n=0;n<y;n+=g){const s=(a+n)/d;s<0||s>=c.outWidth||Math.floor(s)!==s||(i+=T.get(e,r,s,t))}}v.set(i*_,e,n,r,t)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}},cT={kernelName:Nt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:u}=t;R(o.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(null==i||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(null==a||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),W_([s,o,u,a,i],"batchNorm");let{varianceEpsilon:l}=r;null==l&&(l=.001);const c=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(u.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,b=p.length,y=d.length,x=h.length;let w=0,v=0,_=0,k=0;for(let e=0;e<c.length;++e)m[e]=f[w++]+(c[e]-h[v++])*p[_++]/Math.sqrt(d[k++]+l),w>=g&&(w=0),v>=x&&(v=0),_>=b&&(_=0),k>=y&&(k=0);return n.makeTensorInfo(s.shape,s.dtype,m)}};function hT(e,t,n,r,s){const a=No(r,t,n),i=P(n),o=ee(r);if(a){const n=Eo(t,o);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const u=ci(r,s,"string"===s?Qp(e):e),l=ci(n,s);for(let e=0;e<l.size;++e){const n=l.indexToLoc(e),r=n.map((e,n)=>e+t[n]);l.set(u.get(...r),...n)}return"string"===s?ef(l.values):l.values}function dT(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;W_(s,"slice");const[o,u]=$o(s,a,i);mo(s,o,u);const l=hT(n.data.get(s.dataId).values,o,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,l)}const pT={kernelName:Wn,backendName:"cpu",kernelFunc:dT},fT={kernelName:Me,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;W_([s],"batchToSpaceND");const o=a.reduce((e,t)=>e*t),u=ap(s.shape,a,o),l=ip(u.length,a.length),c=op(s.shape,a,o),h=up(i,a.length),d=lp(c,i,a.length),p=Nk({inputs:{x:s},backend:n,attrs:{shape:u}}),f=Bk({inputs:{x:p},backend:n,attrs:{perm:l}}),m=Nk({inputs:{x:f},backend:n,attrs:{shape:c}}),g=dT({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function mT(e,t,n,r,s){const a=P(r),i=se(s,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=s||(i[r]+=a>0?t[n]:1)}return i}function gT(e,t,n,r=!1){const s=e.shape[0],a=e.shape[1],i=ci([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<a;s++){const a=e.get(o,s);if(a<0)throw new Error("Input x must be non-negative!");a>=n||(r?i.set(1,o,a):t.size>0?i.set(i.get(o,a)+t.get(o,s),o,a):i.set(i.get(o,a)+1,o,a))}return i}const bT={kernelName:Le,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=mT(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,o)}},yT=tk((e,t)=>e&t),xT=vk(ze,yT),wT={kernelName:ze,backendName:"cpu",kernelFunc:xT},vT={kernelName:Be,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=Li(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},_T=H_(e=>Math.ceil(e)),kT=K_(Ve,_T),TT={kernelName:Ve,backendName:"cpu",kernelFunc:kT},ST=q_(We,(e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),IT={kernelName:We,backendName:"cpu",kernelFunc:ST},NT={kernelName:Ge,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(P(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values;for(let e=0;e<o.length;e++){const t=o[e],n=u[e];r[e]=Math.hypot(t,n)}return n.makeOutput(r,t.shape,"float32")}};function ET(e,t,n,r){const s=H(n,P(t));if(r&&"string"!==n){let t=0;e.forEach(e=>{const n=P(e.shape);s.set(e.vals,t),t+=n})}else{let r=0;e.forEach(e=>{const a="string"===n?Qp(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[o+t]=a[i++]}r+=e.shape[1]})}return s}function $T(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const AT={kernelName:Dt,backendName:"cpu",kernelFunc:$T};function CT(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=W(s,t[0].shape)[0];Xd(t.map(e=>e.shape),a);let i=Yd(t.map(e=>e.shape),a);if(0===P(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter(e=>P(e.shape)>0);if(1===o.length)return Z_({inputs:{x:o[0]},backend:n});if("complex64"===o[0].dtype){const e=o.map(e=>gk({inputs:{input:e},backend:n})),t=o.map(e=>$T({inputs:{input:e},backend:n})),r=CT({inputs:e,backend:n,attrs:{axis:a}}),s=CT({inputs:t,backend:n,attrs:{axis:a}}),i=pk({inputs:{real:r,imag:s},backend:n});return e.forEach(e=>n.disposeIntermediateTensorInfo(e)),t.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),i}const u=o.map(e=>{const t=P(e.shape.slice(a));return Nk({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})}),l=u.map(e=>({vals:n.data.get(e.dataId).values,shape:e.shape}));i=Yd(u.map(e=>e.shape),1);const c=1===u[0].shape[0],h=ET(l,i,t[0].dtype,c),d=Yd(o.map(e=>e.shape),a),p=n.makeTensorInfo(d,t[0].dtype,h);return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}const OT={kernelName:He,backendName:"cpu",kernelFunc:CT};function RT(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:l,dimRoundingMode:c}=r;W_([s,a],"conv2d");const h=ru(u),d=qo(s.shape,a.shape,i,l,o,c,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,b=d.padInfo.left,y=d.padInfo.top,x="channelsLast"===d.dataFormat,w=new fs(d.outShape,s.dtype),v=ee(s.shape),_=ee(a.shape),k=v[0],T=x?v[1]:v[2],S=x?v[2]:1,I=x?1:v[1],N=w.strides[0],E=x?w.strides[1]:w.strides[2],$=x?w.strides[2]:1,A=x?1:w.strides[1],C=n.data.get(s.dataId).values,O=n.data.get(a.dataId).values,R=w.values;for(let e=0;e<d.batchSize;++e){const t=e*k,n=e*N;for(let e=0;e<d.outHeight;++e){const r=n+e*E,s=e*d.strideHeight-y;for(let e=0;e<p;++e){const n=s+e*m;if(n<0||n>=d.inHeight)continue;const a=e*_[0],i=t+n*T;for(let e=0;e<d.outWidth;++e){const t=r+e*$,n=e*d.strideWidth-b;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=d.inWidth)continue;const s=i+r*S;let o=a+e*_[1];for(let e=0;e<d.inChannels;++e){const n=C[s+e*I];for(let e=0;e<d.outChannels;++e)R[t+e*A]+=n*O[o+e];o+=d.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,R)}const DT={kernelName:qe,backendName:"cpu",kernelFunc:RT},FT={kernelName:Ke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:l,filterShape:c}=r;W_([s,a],"conv2dBackpropFilter");const h=ru(u),d=qo(s.shape,c,i,1,o,l,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,b="channelsLast"===d.dataFormat,y=new fs(d.filterShape,"float32"),x=d.padInfo.left,w=d.padInfo.top,v=n.data.get(s.dataId).values,_=n.data.get(a.dataId).values,k=new fs(s.shape,s.dtype,v),T=new fs(a.shape,a.dtype,_);for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((w-e)/p)),n=Math.min(d.outHeight,(d.inHeight+w-e)/p);for(let r=0;r<g;++r){const s=Math.max(0,Math.ceil((x-r)/f)),a=Math.min(d.outWidth,(d.inWidth+x-r)/f);for(let i=0;i<d.inChannels;++i)for(let o=0;o<d.outChannels;++o){let u=0;for(let l=0;l<d.batchSize;++l)for(let c=t;c<n;++c){const t=e+c*p-w;for(let e=s;e<a;++e){const n=r+e*f-x;u+=b?k.get(l,t,n,i)*T.get(l,c,e,o):k.get(l,i,t,n)*T.get(l,o,c,e)}}y.set(u,e,r,i,o)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},PT={kernelName:Xe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=r;W_([s,a],"conv2dBackpropInput");const h=ee(a.shape),d=ee(s.shape);let p=ru(l);const f=qo(i,a.shape,o,1,u,c,!1,p),m=new fs(f.inShape,"float32"),g=m.values,b=n.data.get(s.dataId).values,y=n.data.get(a.dataId).values,[x,w,v]=h,{batchSize:_,filterHeight:k,filterWidth:T,inChannels:S,inHeight:I,inWidth:N,outChannels:E,outHeight:$,outWidth:A,strideHeight:C,strideWidth:O}=f;p=f.dataFormat;const R=k-1-f.padInfo.top,D=T-1-f.padInfo.left,F="channelsLast"===p,P=m.strides[0],M=F?m.strides[1]:m.strides[2],L=F?m.strides[2]:1,z=F?1:m.strides[1],B=d[0],U=F?d[1]:d[2],V=F?d[2]:1,W=F?1:d[1];for(let e=0;e<_;++e)for(let t=0;t<S;++t)for(let n=0;n<I;++n){const r=n-R,s=Math.max(0,Math.ceil(r/C)),a=Math.min($,(k+r)/C);for(let i=0;i<N;++i){const o=i-D,u=Math.max(0,Math.ceil(o/O)),l=Math.min(A,(T+o)/O);let c=0;for(let n=s;n<a;++n){const s=n*C-r;for(let r=u;r<l;++r){const a=B*e+U*n+V*r,i=x*(k-1-s)+w*(T-1-(r*O-o))+v*t;for(let e=0;e<E;++e)c+=b[a+W*e]*y[i+e]}}g[P*e+M*n+L*i+z*t]=c}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},MT={kernelName:Ye,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r;W_([s,a],"conv3d");const l=Ko(s.shape,a.shape,i,u,o),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=l,b=g.front,y=g.left,x=g.top,w=new fs(l.outShape,s.dtype),v=n.data.get(s.dataId).values,_=n.data.get(a.dataId).values,k=w.values,T=ee(s.shape),S=ee(a.shape);for(let e=0;e<l.batchSize;++e){const t=e*T[0],n=e*w.strides[0];for(let e=0;e<l.outDepth;++e){const r=n+e*w.strides[1],s=e*l.strideDepth-b;for(let e=0;e<c;++e){const n=s+e*p;if(n<0||n>=l.inDepth)continue;const a=e*S[0],i=t+n*T[1];for(let e=0;e<l.outHeight;++e){const t=r+e*w.strides[2],n=e*l.strideHeight-x;for(let e=0;e<h;++e){const r=n+e*f;if(r<0||r>=l.inHeight)continue;const s=a+e*S[1],o=i+r*T[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,r=e*l.strideWidth-y;for(let e=0;e<d;++e){const t=r+e*m;if(t<0||t>=l.inWidth)continue;const a=s+e*S[2],i=o+t*l.inChannels;let u=a;for(let e=0;e<l.inChannels;++e){const t=v[i+e];for(let e=0;e<l.outChannels;++e)k[n+e]+=t*_[u+e];u+=l.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},LT={kernelName:Ze,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:u}=r;W_([s,a],"conv3dBackpropFilterV2");const l=ee(s.shape),c=ee(a.shape),h=Ko(s.shape,u,i,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,b=h.filterWidth,y=new fs(h.filterShape,"float32"),x=y.values,[w,v,_,k]=y.strides,T=n.data.get(a.dataId).values,[S,I,N,E]=c,$=n.data.get(s.dataId).values,[A,C,O,R]=l,D=h.padInfo.front,F=h.padInfo.left,P=h.padInfo.top;for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((D-e)/d)),n=Math.min(h.outDepth,(h.inDepth+D-e)/d),r=e*w;for(let s=0;s<g;++s){const a=Math.max(0,Math.ceil((P-s)/p)),i=Math.min(h.outHeight,(h.inHeight+P-s)/p),o=s*v+r;for(let r=0;r<b;++r){const u=Math.max(0,Math.ceil((F-r)/f)),l=Math.min(h.outWidth,(h.inWidth+F-r)/f),c=r*_+o;for(let o=0;o<h.inChannels;++o){const m=o*k+c;for(let c=0;c<h.outChannels;++c){let g=0;for(let m=0;m<h.batchSize;++m){const h=m*A,b=m*S;for(let m=t;m<n;++m){const t=(e+m*d-D)*C+h,n=m*I+b;for(let e=a;e<i;++e){const a=(s+e*p-P)*O+t,i=e*N+n;for(let e=u;e<l;++e){const t=e*E+i;g+=$[(r+e*f-F)*R+a+o]*T[t+c]}}}}x[m+c]=g}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},zT={kernelName:Je,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:u}=r;W_([s],"conv3dBackpropInputV2");const l=ee(s.shape),c=ee(a.shape),h=Ko(u,a.shape,o,1,i),d=new fs(h.inShape,"float32"),p=d.values,[f,m,g,b]=d.strides,y=n.data.get(s.dataId).values,[x,w,v,_]=l,k=n.data.get(a.dataId).values,[T,S,I,N]=c,{batchSize:E,filterDepth:$,filterHeight:A,filterWidth:C,inChannels:O,inDepth:R,inHeight:D,inWidth:F,outChannels:P,outDepth:M,outHeight:L,outWidth:z,strideDepth:B,strideHeight:U,strideWidth:V}=h,W=$-1-h.padInfo.front,j=A-1-h.padInfo.top,G=C-1-h.padInfo.left;for(let e=0;e<E;++e)for(let t=0;t<O;++t)for(let n=0;n<R;++n){const r=n-W,s=Math.max(0,Math.ceil(r/B)),a=Math.min(M,($+r)/B);for(let i=0;i<D;++i){const o=i-j,u=Math.max(0,Math.ceil(o/U)),l=Math.min(L,(A+o)/U);for(let c=0;c<F;++c){const h=c-G,d=Math.max(0,Math.ceil(h/V)),E=Math.min(z,(C+h)/V);let O=0;for(let n=s;n<a;++n){const s=n*B-r;for(let r=u;r<l;++r){const a=r*U-o;for(let i=d;i<E;++i){const o=x*e+w*n+v*r+_*i,u=T*($-1-s)+S*(A-1-a)+I*(C-1-(i*V-h))+N*t;for(let e=0;e<P;++e)O+=y[o+e]*k[u+e]}}}p[f*e+m*n+g*i+b*c+t]=O}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},BT=q_(Qe,e=>Math.cos(e)),UT={kernelName:Qe,backendName:"cpu",kernelFunc:BT},VT=q_(et,e=>Math.cosh(e)),WT={kernelName:et,backendName:"cpu",kernelFunc:VT},jT={kernelName:rt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:l}=r,[c,h,d,p]=s.shape,f=a.shape[0],[m,g]=o,b=ci([f,m,g,p],"float32"),y=n.data.get(a.dataId).values,x=n.data.get(i.dataId).values,w=n.data.get(s.dataId).values,v=ee(s.shape),_=ee(b.shape);for(let e=0;e<f;e++){const t=4*e,n=y[t],r=y[t+1],s=y[t+2],a=y[t+3],i=x[e];if(i>=c)continue;const o=m>1?(s-n)*(h-1)/(m-1):0,f=g>1?(a-r)*(d-1)/(g-1):0;for(let t=0;t<m;t++){const c=m>1?n*(h-1)+t*o:.5*(n+s)*(h-1);if(c<0||c>h-1)for(let n=0;n<g;n++)for(let r=0;r<p;r++){const s=r+n*_[2]+t*_[1]+e*_[0];b.values[s]=l}else if("bilinear"===u){const n=Math.floor(c),s=Math.ceil(c),o=c-n;for(let u=0;u<g;u++){const c=g>1?r*(d-1)+u*f:.5*(r+a)*(d-1);if(c<0||c>d-1){for(let n=0;n<p;n++){const r=n+u*_[2]+t*_[1]+e*_[0];b.values[r]=l}continue}const h=Math.floor(c),m=Math.ceil(c),y=c-h;for(let r=0;r<p;r++){let a=r+h*v[2]+n*v[1]+i*v[0];const l=w[a];a=r+m*v[2]+n*v[1]+i*v[0];const c=w[a];a=r+h*v[2]+s*v[1]+i*v[0];const d=w[a];a=r+m*v[2]+s*v[1]+i*v[0];const p=l+(c-l)*y,f=d+(w[a]-d)*y;a=r+u*_[2]+t*_[1]+e*_[0],b.values[a]=p+(f-p)*o}}}else for(let n=0;n<g;++n){const s=g>1?r*(d-1)+n*f:.5*(r+a)*(d-1);if(s<0||s>d-1){for(let r=0;r<p;r++){const s=r+n*_[2]+t*_[1]+e*_[0];b.values[s]=l}continue}const o=Math.round(s),u=Math.round(c);for(let r=0;r<p;r++){const s=r+o*v[2]+u*v[1]+i*v[0],a=r+n*_[2]+t*_[1]+e*_[0];b.values[a]=w[s]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},GT={kernelName:tt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;W_(s,"cumprod");const u=sl([a],s.shape.length);let l=s;null!=u&&(l=Bk({inputs:{x:s},backend:n,attrs:{perm:u}}));const c=il(1,s.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const h=Ns(l.dtype,"int32"),d=re(P(l.shape),h),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<p.length;e+=f)for(let t=0;t<f;t++){const n=m(e,t);if(0===t)d[n]=i?1:p[n];else{const r=m(e,t-1);d[n]=i?p[r]*d[r]:p[n]*d[r]}}const g=n.makeTensorInfo(l.shape,h,d);if(null!=u){const e=Bk({inputs:{x:g},backend:n,attrs:{perm:al(u)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}},HT={kernelName:nt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;W_(s,"cumsum");const u=sl([a],s.shape.length);let l=s;null!=u&&(l=Bk({inputs:{x:s},backend:n,attrs:{perm:u}}));const c=il(1,s.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const h=Ns(l.dtype,"int32"),d=se(P(l.shape),h),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<p.length;e+=f)for(let t=0;t<f;t++){const n=m(e,t);if(0===t)d[n]=i?0:p[n];else{const r=m(e,t-1);d[n]=i?p[r]+d[r]:p[n]+d[r]}}const g=n.makeTensorInfo(l.shape,h,d);if(null!=u){const e=Bk({inputs:{x:g},backend:n,attrs:{perm:al(u)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}},qT={kernelName:st,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=mT(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,e)}if(2===s.shape.length){const e=gT(n.bufferSync(s),n.bufferSync(a),i,o);return n.makeTensorInfo(e.shape,a.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},KT={kernelName:at,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;R("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const o=s.shape[0],u=s.shape[1],l=s.shape[2],c=s.shape[3],h=u*a,d=l*a,p=c/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*h*d*p);let g=0;for(let e=0;e<o;++e)for(let t=0;t<h;++t){const n=Math.floor(t/a),r=t%a;for(let t=0;t<d;++t){const s=Math.floor(t/a),i=(r*a+t%a)*p;for(let t=0;t<p;++t){const r=t+i+c*(s+l*(n+u*e));m[g++]=f[r]}}}return n.makeTensorInfo([o,h,d,p],s.dtype,m)}};function XT(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:l}=r;W_([s,a],"depthwiseConv2DNative");const c=ee(s.shape),h=ee(a.shape);let d=u;null==d&&(d=[1,1]),R(tu(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);const p=qo(s.shape,a.shape,i,d,o,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=p,x=y.left,w=y.top,v=p.outChannels/p.inChannels,_=new fs(p.outShape,s.dtype),k=n.data.get(s.dataId).values,T=n.data.get(a.dataId).values,S=_.values;for(let e=0;e<p.batchSize;++e){const t=e*c[0],n=e*_.strides[0];for(let e=0;e<p.outHeight;++e){const r=n+e*_.strides[1],s=e*p.strideHeight-w;for(let e=0;e<f;++e){const n=s+e*g;if(n<0||n>=p.inHeight)continue;const a=e*h[0],i=t+n*c[1];for(let e=0;e<p.outWidth;++e){const t=r+e*_.strides[2],n=e*p.strideWidth-x;for(let e=0;e<m;++e){const r=n+e*b;if(r<0||r>=p.inWidth)continue;const s=a+e*h[1],o=i+r*p.inChannels;let u=t,l=s;for(let e=0;e<p.inChannels;++e){const t=k[o+e];for(let e=0;e<v;++e)S[u+e]+=t*T[l+e];u+=v,l+=v}}}}}}return n.makeTensorInfo(_.shape,_.dtype,_.values)}const YT={kernelName:it,backendName:"cpu",kernelFunc:XT},ZT={kernelName:ot,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,filterShape:c}=r;W_([s,a],"depthwiseConv2dNativeBackpropFilter");const h=qo(s.shape,c,i,o,u,l,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new fs(h.filterShape,"float32"),b=h.padInfo.left,y=h.padInfo.top,x=h.outChannels/h.inChannels,w=n.data.get(s.dataId).values,v=new fs(s.shape,s.dtype,w),_=n.data.get(a.dataId).values,k=new fs(a.shape,a.dtype,_);for(let e=0;e<f;++e){const t=Math.max(0,Math.ceil((y-e)/d)),n=Math.min(h.outHeight,(h.inHeight+y-e)/d);for(let r=0;r<m;++r){const s=Math.max(0,Math.ceil((b-r)/p)),a=Math.min(h.outWidth,(h.inWidth+b-r)/p);for(let i=0;i<h.outChannels;++i){const o=Math.trunc(i/x),u=i%x;let l=0;for(let u=0;u<h.batchSize;++u)for(let c=t;c<n;++c){const t=e+c*d-y;for(let e=s;e<a;++e){const n=r+e*p-b;l+=v.get(u,t,n,o)*k.get(u,c,e,i)}}g.set(l,e,r,o,u)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},JT={kernelName:ut,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,inputShape:c}=r;W_([s,a],"depthwiseConv2DNativeBackpropInput");const h=ee(s.shape),d=ee(a.shape),p=qo(c,a.shape,i,o,u,l,!0),f=new fs(p.inShape,"float32"),m=f.values,[g,b,y]=f.strides,x=n.data.get(s.dataId).values,[w,v,_]=h,k=n.data.get(a.dataId).values,[T,S,I]=d,{batchSize:N,filterHeight:E,filterWidth:$,inChannels:A,inHeight:C,inWidth:O,outChannels:R,outHeight:D,outWidth:F,strideHeight:P,strideWidth:M}=p,L=E-1-p.padInfo.top,z=$-1-p.padInfo.left,B=R/A;for(let e=0;e<N;++e)for(let t=0;t<A;++t)for(let n=0;n<C;++n){const r=n-L,s=Math.max(0,Math.ceil(r/P)),a=Math.min(D,(E+r)/P);for(let i=0;i<O;++i){const o=i-z,u=Math.max(0,Math.ceil(o/M)),l=Math.min(F,($+o)/M);let c=0;for(let n=s;n<a;++n){const s=n*P-r;for(let r=u;r<l;++r){const a=w*e+v*n+_*r,i=T*(E-1-s)+S*($-1-(r*M-o))+I*t;for(let e=0;e<B;++e)c+=x[a+(t*B+e)]*k[i+e]}}m[g*e+b*n+y*i+t]=c}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},QT={kernelName:lt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=P(r.shape),a=n.data.get(r.dataId).values,i=ci([s,s],r.dtype),o=i.values;for(let e=0;e<a.length;e++)o[e*s+e]=a[e];const u=[...r.shape,...r.shape];return n.makeTensorInfo(u,i.dtype,i.values)}},eS={kernelName:ct,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s}=e,{strides:a,pad:i,dilations:o}=n,u=t,l=u.data.get(r.dataId).values,c=r.shape.length,h=u.data.get(s.dataId).values,d=s.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:x,strideHeight:w,strideWidth:v,filterHeight:_,filterWidth:k,dilationHeight:T,dilationWidth:S,outShape:I}=jo(r.shape,s.shape,a,i,"NHWC",o),N=P(I),E=I.length,$=H(r.dtype,N);for(let e=0;e<p;++e)for(let t=0;t<b;++t){const n=t*w-x.top;for(let a=0;a<y;++a){const i=a*v-x.left;for(let o=0;o<g;++o){let u=Number.MIN_SAFE_INTEGER;for(let t=0;t<_;++t){const a=n+t*T;if(a>=0&&a<f)for(let n=0;n<k;++n){const p=i+n*S;if(p>=0&&p<m){const i=oe([e,a,p,o],c,ee(r.shape)),f=oe([t,n,o],d,ee(s.shape)),m=l[i]+h[f];m>u&&(u=m)}}}$[oe([e,t,a,o],E,ee(I))]=u}}}return{dataId:u.write(es($,r.dtype),I,r.dtype),shape:I,dtype:r.dtype}}},tS={kernelName:dt,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:u}=n,l=t,c=ne(r.shape,l.data.get(r.dataId).values),h=ne(s.shape,l.data.get(s.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:_,dilationHeight:k,dilationWidth:T,outShape:S}=jo(r.shape,s.shape,i,o,"NHWC",u);R(a.rank===S.length,()=>`Error in ${dt}, dy must have the same rank as output ${S.length}, but got ${a.rank}`);const I=ne(S,l.data.get(a.dataId).values),N=ae(s.shape,s.dtype);for(let e=0;e<d;++e)for(let t=0;t<g;++t){const n=t*x-y.top;for(let r=0;r<b;++r){const s=r*w-y.left;for(let a=0;a<m;++a){let i=Number.MIN_SAFE_INTEGER,o=0,u=0;for(let t=0;t<v;++t){const r=n+t*k;if(r>=0&&r<p)for(let n=0;n<_;++n){const l=s+n*T;if(l>=0&&l<f){const s=c[e][r][l][a]+h[t][n][a];s>i&&(i=s,o=t,u=n)}}}N[o][u][a]+=I[e][t][r][a]}}}return{dataId:l.write(es(N,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},nS={kernelName:ht,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:u}=n,l=t,c=ne(r.shape,l.data.get(r.dataId).values),h=ne(s.shape,l.data.get(s.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:x,strideWidth:w,filterHeight:v,filterWidth:_,dilationHeight:k,dilationWidth:T,outShape:S}=jo(r.shape,s.shape,i,o,"NHWC",u);R(a.rank===S.length,()=>`Error in ${ht}, dy must have the same rank as output ${S.length}, but got ${a.rank}`);const I=ne(S,l.data.get(a.dataId).values),N=ae(r.shape,r.dtype);for(let e=0;e<d;++e)for(let t=0;t<g;++t){const n=t*x-y.top;for(let r=0;r<b;++r){const s=r*w-y.left;for(let a=0;a<m;++a){let i=Number.MIN_SAFE_INTEGER,o=n<0?0:n,u=s<0?0:s;for(let t=0;t<v;++t){const r=n+t*k;if(r>=0&&r<p)for(let n=0;n<_;++n){const l=s+n*T;if(l>=0&&l<f){const s=c[e][r][l][a]+h[t][n][a];s>i&&(i=s,o=r,u=l)}}}N[e][o][u][a]+=I[e][t][r][a]}}}return{dataId:l.write(es(N,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},rS={kernelName:"Draw",backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:u}=i||{},l=(null==u?void 0:u.alpha)||1,c=(null==o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const h=a.getContext(c,(null==o?void 0:o.contextAttributes)||{});if(null==h)throw new Error(`Could not get the context with ${c} type.`);const[d,p]=s.shape.slice(0,2),f=2===s.shape.length?1:s.shape[2],m=n.data.get(s.dataId).values,g="float32"===s.dtype?255:1,b=new Uint8ClampedArray(p*d*4);for(let e=0;e<d*p;++e){const t=[0,0,0,255*l];for(let n=0;n<f;n++){const r=m[e*f+n];if("float32"===s.dtype){if(r<0||r>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${r}.`)}else if("int32"===s.dtype&&(r<0||r>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${r}.`);1===f?(t[0]=r*g,t[1]=r*g,t[2]=r*g):t[n]=r*g}const n=4*e;b[n+0]=Math.round(t[0]),b[n+1]=Math.round(t[1]),b[n+2]=Math.round(t[2]),b[n+3]=Math.round(t[3])}a.width=p,a.height=d;const y=new ImageData(b,p,d);return h.putImageData(y,0,0),s}},sS=tk((e,t)=>e*t),aS=_k((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),iS=vk(ln,sS,aS),oS={kernelName:ln,backendName:"cpu",kernelFunc:iS};function uS(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;let o;W_(s,"sum"),o="bool"===s.dtype?xk({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):Z_({inputs:{x:s},backend:n});const u=o.shape.length,l=W(a,o.shape),c=sl(l,u);let h=l,d=o;null!=c&&(d=Bk({inputs:{x:o},backend:n,attrs:{perm:c}}),h=il(h.length,u)),rl("sum",h,d.shape.length);const[p,f]=tl(d.shape,h);let m=mk(n,p,Ns(d.dtype,"int32"));const g=P(f),b=n.data.get(m.dataId).values,y=n.data.get(d.dataId).values;for(let e=0;e<b.length;++e){const t=e*g;let n=0;for(let e=0;e<g;++e)n+=y[t+e];b[e]=n}if(i){const e=m;m=Nk({inputs:{x:m},backend:n,attrs:{shape:nl(m.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(d),m}const lS={kernelName:Yn,backendName:"cpu",kernelFunc:uS},cS={kernelName:ft,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:u}=Cp(s,a.length);Rp(i.length,u,a);const{path:l,steps:c}=Dp(o,u),h=c.length;let d=null,p=i.length;const f=[];for(let e=0;e<h;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:r}=Op(p,u[t]);let s;Fp(e)?s=a[t]:(s=Bk({inputs:{x:a[t]},backend:n,attrs:{perm:e}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);M(s.shape,i)||(s=Nk({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=iS({inputs:{a:s,b:d},backend:n}),f.push(d))}e<h-1&&(l[e]>=0&&(d=uS({inputs:{x:d},backend:n,attrs:{axis:l[e]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const e of f)e!==d&&n.disposeIntermediateTensorInfo(e);return d}},hS={kernelName:gt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;W_([r,s],"eluGrad");const a=new Float32Array(P(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let e=0;e<i.length;++e){const t=i[e];a[e]=t>=0?o[e]:o[e]*(t+1)}return n.makeTensorInfo(s.shape,"float32",a)}},dS=tk((e,t)=>e===t?1:0),pS=vk(yt,dS,null,"bool"),fS={kernelName:yt,backendName:"cpu",kernelFunc:pS},mS=pp,gS=fp,bS=mp,yS=gp,xS=bp,wS=yp,vS=q_(bt,e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+mS*n);return t*(1-((((wS*r+xS)*r+yS)*r+bS)*r+gS)*r*Math.exp(-n*n))}),_S={kernelName:bt,backendName:"cpu",kernelFunc:vS},kS=H_(e=>Math.exp(e)),TS=K_(xt,kS,"float32"),SS={kernelName:xt,backendName:"cpu",kernelFunc:TS};function IS(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice();let u=a;return a<0&&(R(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+a+1),o.splice(u,0,1),Nk({inputs:{x:s},backend:n,attrs:{shape:o}})}const NS={kernelName:wt,backendName:"cpu",kernelFunc:IS},ES=H_(e=>Math.expm1(e)),$S=K_(vt,ES),AS={kernelName:vt,backendName:"cpu",kernelFunc:$S},CS=tk((e,t)=>e/t),OS=vk(pt,CS),RS={kernelName:pt,backendName:"cpu",kernelFunc:OS},DS=tk((e,t)=>e-t),FS=_k((e,t,n,r)=>({real:e-n,imag:t-r})),PS=vk(dr,DS,FS),MS={kernelName:dr,backendName:"cpu",kernelFunc:PS};function LS(e,t,n){const r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,l=[s,a],c=P(l),h=G("float32",c),d=G("float32",c);for(let e=0;e<s;e++){const r=dT({inputs:{x:o},backend:n,attrs:{begin:[e,0],size:[1,a]}}),s=dT({inputs:{x:u},backend:n,attrs:{begin:[e,0],size:[1,a]}}),i=pk({inputs:{real:r,imag:s},backend:n}),{real:l,imag:c}=zS(i,t,n),p=xp(l,c);for(let t=0;t<a;t++){const n=kp(p,t);h[e*a+t]=n.real,d[e*a+t]=n.imag}n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i)}const p=n.makeTensorInfo(l,"float32",h),f=n.makeTensorInfo(l,"float32",d),m=pk({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function zS(e,t,n){const r=P(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if((o=r)&o-1){const e=function(e,t,n){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let a=0,i=0;for(let r=0;r<t;r++){const o=Ip(s*r,t,n),u=kp(e,r);a+=u.real*o.real-u.imag*o.imag,i+=u.real*o.imag+u.imag*o.real}n&&(a/=t,i/=t),Tp(r,a,i,s)}return r}(xp(a,i),r,t);return wp(e)}{const s=BS(a,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",s.real),t=n.makeTensorInfo(o,"float32",s.imag),a=n.makeTensorInfo([],"float32",Qr(r,"float32")),i=Z_({inputs:{x:a},backend:n}),u=RS.kernelFunc({inputs:{a:e,b:a},backend:n}),l=RS.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(u.dataId).values,h=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),{real:c,imag:h}}return s}var o}function BS(e,t,n,r,s){if(1===n)return{real:e,imag:t};const a=xp(e,t),i=n/2,o=vp(a),u=o.real,l=o.imag,c=[u.length],h=s.makeTensorInfo(c,"float32",u),d=s.makeTensorInfo(c,"float32",l),p=pk({inputs:{real:h,imag:d},backend:s}),f=_p(a),m=f.real,g=f.imag,b=[m.length],y=s.makeTensorInfo(b,"float32",m),x=s.makeTensorInfo(b,"float32",g),w=pk({inputs:{real:y,imag:x},backend:s}),v=BS(u,l,i,r,s),_=v.real,k=v.imag,T=[_.length],S=s.makeTensorInfo(T,"float32",_),I=s.makeTensorInfo(T,"float32",k),N=pk({inputs:{real:S,imag:I},backend:s}),E=BS(m,g,i,r,s),$=E.real,A=E.imag,C=[$.length],O=s.makeTensorInfo(C,"float32",$),R=s.makeTensorInfo(C,"float32",A),D=pk({inputs:{real:O,imag:R},backend:s}),F=Sp(n,r),P=[F.real.length],M=s.makeTensorInfo(P,"float32",F.real),L=s.makeTensorInfo(P,"float32",F.imag),z=pk({inputs:{real:M,imag:L},backend:s}),B=iS({inputs:{a:z,b:D},backend:s}),U=Sk({inputs:{a:N,b:B},backend:s}),V=PS({inputs:{a:N,b:B},backend:s}),W=gk({inputs:{input:U},backend:s}),j=gk({inputs:{input:V},backend:s}),G=$T({inputs:{input:U},backend:s}),H=$T({inputs:{input:V},backend:s}),q=CT({inputs:[W,j],backend:s,attrs:{axis:0}}),K=CT({inputs:[G,H],backend:s,attrs:{axis:0}}),X=s.data.get(q.dataId).values,Y=s.data.get(K.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(S),s.disposeIntermediateTensorInfo(I),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(M),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}const US={kernelName:_t,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=P(r.shape),a=r.shape[r.shape.length-1],i=Nk({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=LS(i,!1,n),u=Nk({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}};function VS(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||Z(s),o=H(i,P(r));return function(e,t){e.fill(t)}(o,s),t.makeTensorInfo(r,i,o)}const WS={kernelName:kt,backendName:"cpu",kernelFunc:VS},jS={kernelName:Tt,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,s=n,a=G(r.dtype,P(r.shape)),[i,o,u,l]=r.shape,c=s.data.get(r.dataId).values;for(let e=0;e<i;e++){const t=e*u*o*l;for(let e=0;e<o;e++){const n=e*(u*l);for(let e=0;e<u;e++){const r=e*l;for(let s=0;s<l;s++){const i=Math.round(u-e-1),o=t+n+r+s;let h=c[o];i>=0&&i<u&&(h=c[t+n+i*l+s]),a[o]=h}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},GS=H_(e=>Math.floor(e)),HS=K_(St,GS),qS={kernelName:St,backendName:"cpu",kernelFunc:HS},KS=tk((e,t)=>Math.floor(e/t)),XS=vk(It,KS,null,"int32"),YS={kernelName:It,backendName:"cpu",kernelFunc:XS},ZS={kernelName:Ir,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=RT({inputs:{x:s,filter:a},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const e=Nk({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=Sk({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=Sk({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=Nk({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=dk(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=dk(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}},JS={kernelName:Nr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=XT({inputs:{x:s,filter:a},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const e=m;m=Sk({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=dk(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};function QS(e,t,n,r,s,a,i,o,u){const l=ci([r,a],n);for(let n=0;n<r;n++){const r=[];let c=0;for(let t=0;t<s;t++){const a=e[n*s+t];c+=a*i[t],r.push(a)}if(c<0||c>=u/a)throw new Error(`Invalid indices: ${r} does not index into ${o}`);for(let e=0;e<a;e++)l.values[n*a+e]=t.get(...t.indexToLoc(c*a+e))}return l}const eI={kernelName:$t,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=P(r.shape),i=s.shape,o=i[i.length-1],[u,l,c,h]=cp(r,s);if(0===l)return n.makeTensorInfo(u,r.dtype,[]);const d=QS(n.data.get(s.dataId).values,n.bufferSync(r),r.dtype,l,o,c,h,r.shape,a);return n.makeTensorInfo(u,r.dtype,d.values)}};function tI(e,t,n){const r=ci(n,e.dtype);for(let n=0;n<r.size;++n){const s=r.indexToLoc(n).slice(),a=s[0],i=s[2],o=t.locToIndex([a,i]);s[2]=t.values[o];const u=e.locToIndex(s);0<=u&&u<e.values.length&&(r.values[n]=e.values[u])}return r}const nI={kernelName:Et,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;W_([s,a],"gatherV2");const u=W(i,s.shape)[0],l=n.data.get(a.dataId).values,c=s.shape[u];for(let e=0;e<l.length;++e){const t=l[e];R(t<=c-1&&t>=0,()=>`GatherV2: the index value ${t} is not in [0, ${c-1}]`)}let h=o;null==o&&(h=0);const d=P(a.shape),p=Jp(s,a,u,h),f=Nk({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=Nk({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],b=n.bufferSync(m),y=tI(n.bufferSync(f),b,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}},rI=tk((e,t)=>e>t?1:0),sI=vk(At,rI,null,"bool"),aI={kernelName:At,backendName:"cpu",kernelFunc:sI},iI=tk((e,t)=>e>=t?1:0),oI=vk(Ct,iI,null,"bool"),uI={kernelName:Ct,backendName:"cpu",kernelFunc:oI},lI={kernelName:Rt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=P(r.shape),a=r.shape[r.shape.length-1],i=Nk({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=LS(i,!0,n),u=Nk({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}},cI=q_(Ft,e=>Number.isFinite(e)?1:0,"bool"),hI={kernelName:Ft,backendName:"cpu",kernelFunc:cI},dI=q_(Pt,e=>Math.abs(e)===1/0?1:0,"bool"),pI={kernelName:Pt,backendName:"cpu",kernelFunc:dI},fI=q_(Mt,e=>Number.isNaN(e)?1:0,"bool"),mI={kernelName:Mt,backendName:"cpu",kernelFunc:fI},gI=tk((e,t)=>e<t?1:0),bI=vk(zt,gI,null,"bool"),yI={kernelName:zt,backendName:"cpu",kernelFunc:bI},xI=tk((e,t)=>e<=t?1:0),wI=vk(Bt,xI,null,"bool"),vI={kernelName:Bt,backendName:"cpu",kernelFunc:wI};function _I(e,t,n){const r=(t-e)/(n-1),s=se(n,"float32");s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+r;return s}const kI={kernelName:Ut,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=_I(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},TI=H_(e=>Math.log(e)),SI=K_(Vt,TI),II={kernelName:Vt,backendName:"cpu",kernelFunc:SI},NI=q_(Wt,e=>Math.log1p(e)),EI={kernelName:Wt,backendName:"cpu",kernelFunc:NI},$I=tk((e,t)=>e&&t),AI=vk(jt,$I,null,"bool"),CI={kernelName:jt,backendName:"cpu",kernelFunc:AI},OI=q_(Gt,e=>e?0:1,"bool"),RI={kernelName:Gt,backendName:"cpu",kernelFunc:OI},DI=tk((e,t)=>e||t),FI=vk(Ht,DI,null,"bool"),PI={kernelName:Ht,backendName:"cpu",kernelFunc:FI},MI={kernelName:qt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=r;W_(s,"LRN");const l=s.shape[3],c=l-1,h=n.data.get(s.dataId).values,d=P(s.shape),p=new Float32Array(d);function f(e){const t=e%l;let n=e-t+Math.max(0,t-a);const r=e-t+Math.min(t+a,c);let s=0;for(;n<=r;n++){const e=h[n];s+=e*e}return s}for(let e=0;e<d;e++){const t=f(e),n=h[e]*Math.pow(i+o*t,-u);p[e]=n}return n.makeTensorInfo(s.shape,s.dtype,p)}},LI={kernelName:Kt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:l,beta:c}=r;W_(i,"LRNGrad");const h=P(i.shape),d=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(h),b=h;for(let e=0;e<b;e++){const t=e%d,n=e-t+Math.max(0,t-o),r=e-t+Math.min(d,t+o+1);let s=0;for(let e=n;e<r;e++)s+=Math.pow(f[e],2);s=l*s+u;for(let t=n;t<r;t++){let n=-2*l*c*f[t]*m[e]/s;e===t&&(n+=Math.pow(s,-c)),n*=p[e],g[t]+=n}}return n.makeTensorInfo(i.shape,s.dtype,g)}};function zI(e,t,n,r){const s=G(r,P(n));for(let n=0;n<s.length;++n){const r=n*t;let a=e[r];for(let n=0;n<t;++n){const t=e[r+n];(Number.isNaN(t)||t>a)&&(a=t)}s[n]=a}return s}function BI(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n;let u=s.shape;const l=u.length,c=W(a,u);let h=c;const d=sl(h,l);let p=o.data.get(s.dataId).values;if(null!=d){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=u[d[t]];p=zk(p,u,s.dtype,d,e),h=il(h.length,l),u=e}W_(s,"max"),rl("max",h,l);const[f,m]=tl(u,h),g=zI(p,P(m),f,s.dtype),b=o.write(g,f,s.dtype);let y=f;return i&&(y=nl(f,c)),{dataId:b,shape:y,dtype:s.dtype}}const UI={kernelName:Xt,backendName:"cpu",kernelFunc:BI},VI=tk((e,t)=>Math.max(e,t)),WI=vk(Yt,VI),jI={kernelName:Yt,backendName:"cpu",kernelFunc:WI},GI={kernelName:Zt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;W_(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r;R(tu(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=Go(s.shape,a,i,1,o,u);let c;if(1===l.filterWidth&&1===l.filterHeight&&M(l.inShape,l.outShape))c=Z_({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=ee(s.shape),r=rT(e,s.shape,s.dtype,t,l,"max");c=n.makeTensorInfo(l.outShape,s.dtype,r.values)}return c}},HI={kernelName:Qt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:l}=r;W_(s,"maxPool3d");const c=Ho(s.shape,a,i,1,o,u,l),h=aT(n.data.get(s.dataId).values,s.shape,s.dtype,ee(s.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}},qI={kernelName:en,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:l}=r;W_([s,a],"maxPool3DGrad");const c=Ho(a.shape,i,o,1,u,l),h=function(e,t){const n=ci(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){const y=b*r-d;let x=y;for(;x<0;)x+=i;const w=Math.min(t.inDepth,l+y);for(let r=0;r<t.outHeight;++r){const l=r*s-p;let d=l;for(;d<0;)d+=o;const v=Math.min(t.inHeight,c+l);for(let s=0;s<t.outWidth;++s){const p=s*a-f;let _=p;for(;_<0;)_+=u;const k=Math.min(t.inWidth,h+p);let T=Number.NEGATIVE_INFINITY,S=-1;for(let t=x;t<w;t+=i){const n=t-y;for(let r=d;r<v;r+=o){const s=r-l;for(let a=_;a<k;a+=u){const i=a-p,o=e.get(m,t,r,a,g);o>=T&&(T=o,S=n*c*h+s*c+i)}}}n.set(S,m,b,r,s,g)}}}return n}(n.bufferSync(a),c),d=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,b=c.dilationWidth,y=c.effectiveFilterDepth,x=c.effectiveFilterHeight,w=c.effectiveFilterWidth,v=y-1-c.padInfo.front,_=w-1-c.padInfo.left,k=x-1-c.padInfo.top,T=ci(a.shape,"float32"),S=n.bufferSync(s);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inDepth;++n)for(let r=0;r<c.inHeight;++r)for(let s=0;s<c.inWidth;++s){const a=n-v,i=r-k,o=s-_;let u=0;for(let n=0;n<y;n+=m){const r=(a+n)/d;if(!(r<0||r>=c.outDepth||Math.floor(r)!==r))for(let s=0;s<x;s+=g){const a=(i+s)/p;if(!(a<0||a>=c.outHeight||Math.floor(a)!==a))for(let i=0;i<w;i+=b){const l=(o+i)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const d=y*x*w-1-h.get(e,r,a,l,t)===n*x*w+s*w+i?1:0;0!==d&&(u+=S.get(e,r,a,l,t)*d)}}}T.set(u,e,n,r,s,t)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}},KI={kernelName:Jt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;W_([a,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=r,d=Go(o.shape,u,l,1,c,h),p=n.data.get(o.dataId).values,f=ci(d.outShape,o.dtype,sT(p,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,b=d.dilationHeight,y=d.dilationWidth,x=d.effectiveFilterHeight,w=d.effectiveFilterWidth,v=w-1-d.padInfo.left,_=x-1-d.padInfo.top,k=ci(o.shape,"float32"),T=n.data.get(s.dataId).values,S=ci(s.shape,"float32",T);for(let e=0;e<d.batchSize;++e)for(let t=0;t<d.inChannels;++t)for(let n=0;n<d.inHeight;++n)for(let r=0;r<d.inWidth;++r){const s=n-_,a=r-v;let i=0;for(let n=0;n<x;n+=b){const r=(s+n)/m;if(!(r<0||r>=d.outHeight||Math.floor(r)!==r))for(let s=0;s<w;s+=y){const o=(a+s)/g;if(o<0||o>=d.outWidth||Math.floor(o)!==o)continue;const u=x*w-1-f.get(e,r,o,t)===n*w+s?1:0;0!==u&&(i+=S.get(e,r,o,t)*u)}}k.set(i,e,n,r,t)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}},XI={kernelName:tn,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,u=n;W_(r,"MaxPoolWithArgmax");const l=u.data.get(r.dataId).values,c=Go(r.shape,s,a,[1,1],i),[h,d]=function(e,t,n,r,s){const a=rT(e,0,n,ee(t),s,"max"),i=sT(e,t,n,s,!0,r);return[a.values,i.values]}(l,r.shape,r.dtype,o,c),p=u.write(h,c.outShape,r.dtype),f=u.write(d,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},YI={kernelName:nn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=W(a,s.shape),u=P(tl(s.shape,o)[1]),l=[],c=n.makeTensorInfo([],"float32",new Float32Array([u]));l.push(c);const h=xk({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});l.push(h);const d=OS({inputs:{a:h,b:c},backend:n});l.push(d);const p=uS({inputs:{x:d},backend:n,attrs:{axis:a,keepDims:i}});return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}},ZI={kernelName:rn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;W_(s,"min");const o=W(a,s.shape);let u=o;const l=sl(u,s.shape.length);let c=s;null!=l&&(c=Bk({inputs:{x:s},backend:n,attrs:{perm:l}}),u=il(u.length,s.shape.length)),rl("min",u,c.shape.length);const[h,d]=tl(c.shape,u),p=P(d),f=se(P(h),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*p;let n=m[t];for(let e=0;e<p;++e){const r=m[t+e];(Number.isNaN(r)||r<n)&&(n=r)}f[e]=n}null!=l&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(i){const e=Nk({inputs:{x:g},backend:n,attrs:{shape:nl(h,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},JI=tk((e,t)=>Math.min(e,t)),QI=vk(sn,JI),eN={kernelName:sn,backendName:"cpu",kernelFunc:QI},tN={kernelName:an,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;W_(s,"mirrorPad");const o=a.map((e,t)=>e[0]+s.shape[t]+e[1]),u=a.map(e=>e[0]),l=a.map((e,t)=>e[0]+s.shape[t]),c="reflect"===i?0:1,h=n.data.get(s.dataId).values,d=s.shape.length,p=ee(s.shape),f=P(o),m=o.length,g=ee(o),b=G(s.dtype,f);for(let e=0;e<f;e++){let t=ue(e,m,g);for(let e=0;e<m;e++)t[e]<u[e]?t[e]=2*u[e]-t[e]-c:t[e]>=l[e]&&(t[e]=2*(l[e]-1)-t[e]+c);t=t.map((e,t)=>e-u[t]);const n=oe(t,d,p);b[e]=h[n]}return{dataId:n.write(b,o,s.dtype),shape:o,dtype:s.dtype}}},nN=tk((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),rN=vk(on,nN),sN={kernelName:on,backendName:"cpu",kernelFunc:rN};function aN(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length;let o=a;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const u=W([o],s.shape),l=BI({inputs:{x:s},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),c=nl(l.shape,u),h=Nk({inputs:{x:l},backend:n,attrs:{shape:c}}),d=PS({inputs:{a:s,b:h},backend:n}),p=TS({inputs:{x:d},backend:n}),f=uS({inputs:{x:p},backend:n,attrs:{axis:u,keepDims:!1}}),m=Nk({inputs:{x:f},backend:n,attrs:{shape:c}}),g=OS({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const iN={kernelName:Qn,backendName:"cpu",kernelFunc:aN},oN={kernelName:un,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;W_(s,"multinomial");const u=o?s:aN({inputs:{logits:s},backend:n,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],h=n.data.get(u.dataId).values,d=[l,a],p=se(P(d),"int32");for(let e=0;e<l;++e){const t=e*c,n=new Float32Array(c-1);n[0]=h[t];for(let e=1;e<n.length;++e)n[e]=n[e-1]+h[t+e];const r=vc.alea(i.toString()),s=e*a;for(let e=0;e<a;++e){const t=r();p[s+e]=n.length;for(let r=0;r<n.length;r++)if(t<n[r]){p[s+e]=r;break}}}return o||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(d,"int32",p)}};function uN(e,t,n){const r=Qr(-1,n);return sS([],t,r,e,n)}const lN={kernelName:cn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;W_(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=uN(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}},cN=od,hN={kernelName:dn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=r;W_(s,"NonMaxSuppression");const l=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:h}=cN(l,c,i,o,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},dN=ud,pN={kernelName:pn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:l}=r;W_(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,{selectedIndices:d,validOutputs:p}=dN(c,h,i,o,u,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},fN=ld,mN={kernelName:fn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=r;W_(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,d=i,p=o,f=u,m=l,{selectedIndices:g,selectedScores:b}=fN(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},gN=tk((e,t)=>e!==t?1:0),bN=vk(hn,gN,null,"bool"),yN={kernelName:hn,backendName:"cpu",kernelFunc:bN},xN={kernelName:gn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:u}=r;W_(s,"oneHot");const l=P(s.shape),c=new Float32Array(l*i);c.fill(u);const h=n.data.get(s.dataId).values;for(let e=0;e<l;++e)h[e]>=0&&h[e]<i&&(c[e*i+h[e]]=o);return n.makeTensorInfo([...s.shape,i],a,c)}};function wN(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=gk({inputs:{input:r},backend:n}),t=wN({inputs:{x:e},backend:n}),s=$T({inputs:{input:r},backend:n}),a=wN({inputs:{x:s},backend:n}),i=pk({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return VS({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const vN={kernelName:_r,backendName:"cpu",kernelFunc:wN},_N={kernelName:mn,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const t=gk({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=$T({inputs:{input:s},backend:r}),i=wN({inputs:{x:a},backend:r}),o=pk({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return VS({backend:r,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function kN(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return IS({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach(e=>{D(a,e.shape,"All tensors passed to stack must have matching shapes"),R(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=CT({inputs:t.map(e=>{const t=IS({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t}),backend:n,attrs:{axis:s}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}const TN={kernelName:bn,backendName:"cpu",kernelFunc:kN},SN={kernelName:yn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;W_(s,"pad");const o=a.map((e,t)=>e[0]+s.shape[t]+e[1]),u=a.map(e=>e[0]),l=n.data.get(s.dataId).values,c=P(s.shape),h=s.shape.length,d=ee(s.shape),p=P(o),f=o.length,m=ee(o),g=G(s.dtype,p);0!==i&&g.fill(i);for(let e=0;e<c;e++)g[oe(ue(e,h,d).map((e,t)=>e+u[t]),f,m)]=l[e];return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}},IN=tk((e,t)=>Math.pow(e,t)),NN=vk(xn,IN),EN={kernelName:xn,backendName:"cpu",kernelFunc:NN};function $N(e,t,n,r){const[s,a]=tl(e,r),i=Ns(t,"int32"),o=se(P(s),i),u=P(a);for(let e=0;e<o.length;++e){const t=e*u;let r=1;for(let e=0;e<u;++e)r*=n[t+e];o[e]=r}return{outVals:o,outShape:s,outDtype:i}}const AN={kernelName:vn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;W_(s,"prod");const o=s.shape.length,u=W(a,s.shape),l=sl(u,o);let c=u,h=s;const d=[];null!=l&&(h=Bk({inputs:{x:s},backend:n,attrs:{perm:l}}),d.push(h),c=il(c.length,o));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=$N(h.shape,h.dtype,p,c);let b=m;return i&&(b=nl(m,u)),d.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(b,g,f)}};function CN(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function ON(e,t,n,r,s,a,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach((e,r)=>{if(e<0||e>=n){const s=ue(r,t.length,ee(t)).join(",");throw new Error(`indices[${s}] = ${e} is not in [0, ${n})`)}})}(a,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:l,valueSlices:c,numValues:h}=function(e,t,n,r){const s=[];let a=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let u=1;for(let e=0;e<t.length-1;++e){u*=t[e];const n=t[e+1];for(let t=1;t<u+1;++t)o[e].push(t*n)}for(let r=0;r<e.length;++r){let i=e[r],u=e[r]+1;for(let e=0;e<n.length;++e){const r=n[e],s=e+t.length-1;if(s>=0){const e=o[s],t=e[e.length-1]-r[i];for(let e=i;e<u;++e)o[s].push(r[e+1]+t)}i=r[i],u=r[u]}u!==i&&(s.push([i,u]),a+=u-i)}return{outSplits:o,valueSlices:s,numValues:a}}(a,i,e,u),d=function(e){const t=[];for(let n=0;n<e.length;++n){const r=H("int32",e[n].length);t.push(r),e[n].forEach((e,t)=>r[t]=e)}return t}(l),p=function(e,t,n,r,s){const a=t.slice();a[0]=s;const i=H(n,P(a)),o=e.length;return function(e,t,n,r,s,a){const i=CN(t,2)[1],o=CN(a,2)[1];let u=0;for(const t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)s[u*o+t]=e[n*i+t];++u}}(e,t,r,0===o?0:o/t[0],i,a),[i,a]}(n,r,s,c,h);return[d,p[0],p[1]]}const RN={kernelName:_n,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,u=s.map(e=>n.data.get(e.dataId).values),l=s.map(e=>e.shape),c=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,[d,p,f]=ON(u,l,c,a.shape,a.dtype,h,i.shape),m=d.map(e=>n.makeTensorInfo([e.length],"int32",e)),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}},DN=2147483647;function FN(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,u=0===s.length,l=0===i.length,c=[];o||c.push(t[0]),u||c.push(s[0]),l||c.push(i[0]);for(let e=1;e<c.length;++e)if(c[e]!==c[e-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===c.length?1:c[0],d=H("int32",h+1);d[0]=0;for(let t=0;t<h;++t){const n=o?e[0]:e[t],s=u?r[0]:r[t],i=l?a[0]:a[t];if(0===i)throw new Error("Requires delta != 0");let c;if(i>0&&s<n||i<0&&s>n)c=0;else if(c=Math.ceil(Math.abs((s-n)/i)),c>DN)throw new Error(`Requires ((limit - start) / delta) <= ${DN}`);d[t+1]=d[t]+c}const p=H(n,d[h]);let f=0;for(let t=0;t<h;++t){const n=d[t+1]-d[t];let r=o?e[0]:e[t];const s=l?a[0]:a[t];for(let e=0;e<n;++e)p[f++]=r,r+=s}return[d,p]}const PN={kernelName:kn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[l,c]=FN(i,r.shape,r.dtype,o,s.shape,u,a.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([c.length],r.dtype,c)]}};var MN=Zd;class LN{constructor(e,t,n,r,s,a,i,o,u,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=Qd(l),this.raggedRank=ep(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===MN.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===MN.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case MN.VALUE_ROWIDS:return LN.getMaxWidthValueRowID(t);case MN.ROW_SPLITS:return LN.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${MN[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],s=0;for(let a=1;a<t;++a){const t=e[a];t!==r&&(r=t,s=Math.max(a-n,s),n=a)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return BN(e,n)}calculateOutputSize(e){const t=this.valuesShape;tp(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=Jd(this.raggedRank,n,t);r[0]<0&&(r[0]=e);for(let e=1;e<=this.raggedRank;++e)r[e]<0&&(r[e]=this.getMaxWidth(e));return r}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),s=[];let a=0;for(let e=0;e<r;++e,a+=t)s.push(a);for(let t=r;t<e;++t)s.push(-1);return R(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,n,r){const s=e.length,a=[];for(let i=0;i<s-1;++i){const s=e[i+1]-e[i];let o=Math.min(r,s),u=t[i];-1===u&&(o=0);for(let e=0;e<o;++e)a.push(u),u+=n;for(let e=0;e<s-o;++e)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,r){const s=e.length,a=[];if(0===s)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let u=t[o];a.push(u);for(let l=1;l<s;++l){const s=e[l];if(s===o)u>=0&&(++i,i<r?u+=n:u=-1);else{if(i=0,o=s,s>=t.length)throw new Error(`Got nextValueRowId=${s} which is not less than ${t.length}`);u=t[s]}a.push(u)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,r){const s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case MN.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,r);case MN.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,r);default:throw new Error(`Unsupported partition type: ${MN[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case MN.FIRST_DIM_SIZE:return e[0];case MN.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case MN.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${MN[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];const r=BN(t,!1),s=H(this.valuesDType,P(r));if(n[0]*t[0]>0){let a=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)a=this.calculateOutputIndex(e-1,a,n[e],t[e]);this.setOutput(this.raggedRank,a,s,r)}return[r,s]}setOutput(e,t,n,r){if(0===n.length)return;const s=this.values,a=n;let i=r.slice();i=i.slice(e+1);const o=P(i),u=t.length;let l=this.defaultValue;if(l.length!==o&&1!==l.length){const e=this.defaultValueShape;sa(()=>{const t=au(l,e),n=_u(t,i);l=n.dataSync()})}let c=0,h=0,d=0;for(let e=0;e<=u;++e){let r=e<u?t[e]:-1;if(r!==d){if(h<d){const e=s.subarray(c*o);zN(a.subarray(h*o),e,(d-h)*o)}if(e>=u){const e=n.length;r=Math.floor(e/o)}if(r>d)if(1===this.defaultValue.length)a.subarray(d*o,r*o).fill(this.defaultValue[0]),d=r;else for(;r>d;)zN(a.slice(d*o),l,o),++d;r<0?(c=e+1,h=d):(c=e,h=d,d=h+1)}else++d}}}function zN(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function BN(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function UN(e,t,n,r,s,a,i,o,u,l){return new LN(e,t,n,r,s,a,i,o,u,l).compute()}const VN={kernelName:Tn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=r,l=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,d=o.map(e=>n.data.get(e.dataId).values),p=o.map(e=>e.shape),[f,m]=UN(l,s.shape,c,a.shape,a.dtype,h,i.shape,d,p,u);return n.makeTensorInfo(f,a.dtype,m)}};function WN(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return se(0,r);const s=se(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+n;return s}const jN={kernelName:Sn,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=WN(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}},GN=q_(Nn,e=>1/e),HN={kernelName:Nn,backendName:"cpu",kernelFunc:GN},qN={kernelName:On,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;W_(s,"resizeBilinear");const u=ee(s.shape),[l,c]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(P([h,l,c,f])),b=[a&&l>1?d-1:d,a&&c>1?p-1:p],y=[a&&l>1?l-1:l,a&&c>1?c-1:c];let x=0;const w=b[0]/y[0],v=b[1]/y[1];for(let e=0;e<h;e++)for(let t=0;t<l;t++){let n;n=i?w*(t+.5)-.5:w*t;const r=Math.max(0,Math.floor(n)),s=n-r,a=Math.min(d-1,Math.ceil(n)),o=e*u[0]+r*u[1],l=e*u[0]+a*u[1];for(let e=0;e<c;e++){let t;t=i?v*(e+.5)-.5:v*e;const n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(p-1,Math.ceil(t)),c=o+n*u[2],h=l+n*u[2],d=o+a*u[2],b=l+a*u[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[h+e],a=t+(m[d+e]-t)*r,i=a+(n+(m[b+e]-n)*r-a)*s;g[x++]=i}}}return n.makeTensorInfo([h,l,c,f],"float32",g)}},KN={kernelName:Rn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;W_([a,s],"resizeBilinearGrad");const o=ee(s.shape),[u,l,c,h]=s.shape,[,d,p]=a.shape,f=new Float32Array(u*l*c*h),m=[i&&d>1?l-1:l,i&&p>1?c-1:c],g=[i&&d>1?d-1:d,i&&p>1?p-1:p],b=m[0]/g[0],y=m[1]/g[1],x=n.data.get(a.dataId).values;let w=0;for(let e=0;e<u;e++){const t=e*o[0];for(let e=0;e<d;e++){const n=e*b,r=Math.floor(n),s=Math.min(Math.ceil(n),l-1),a=t+r*o[1],i=t+s*o[1],u=n-r,d=1-u;for(let e=0;e<p;e++){const t=e*y,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),s=t-n,l=1-s,p=a+n*o[2],m=a+r*o[2],g=i+n*o[2],b=i+r*o[2],v=d*l,_=d*s,k=u*l,T=u*s;for(let e=0;e<h;e++){const t=x[w++];f[p+e]+=t*v,f[m+e]+=t*_,f[g+e]+=t*k,f[b+e]+=t*T}}}}return n.makeTensorInfo([u,c,l,h],"float32",f)}},XN={kernelName:An,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;W_(s,"resizeNearestNeighbor");const u=ee(s.shape),[l,c]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(h*l*c*f),b=[a&&l>1?d-1:d,a&&c>1?p-1:p],y=[a&&l>1?l-1:l,a&&c>1?c-1:c],x=b[0]/y[0],w=b[1]/y[1];let v=0;for(let e=0;e<h;e++){const t=e*u[0];for(let e=0;e<l;e++){const n=i?x*(e+.5):x*e;let r=Math.min(d-1,a?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const s=t+r*u[1];for(let e=0;e<c;e++){const t=i?w*(e+.5):w*e;let n=Math.min(p-1,a?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=s+n*u[2];for(let e=0;e<f;e++){const t=m[r+e];g[v++]=t}}}}return n.makeTensorInfo([h,l,c,f],s.dtype,g)}},YN={kernelName:Cn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;W_([a,s],"resizeNearestNeighborGrad");const o=ee(s.shape),u=ee(a.shape),[l,c,h,d]=s.shape,[,p,f]=a.shape,m=new Float32Array(l*c*h*d),g=n.data.get(a.dataId).values,b=[i&&p>1?c-1:c,i&&f>1?h-1:h],y=[i&&p>1?p-1:p,i&&f>1?f-1:f],x=b[0]/y[0],w=b[1]/y[1],v=1/x,_=1/w,k=2*Math.ceil(v)+2,T=2*Math.ceil(_)+2;for(let e=0;e<l;e++){const t=e*o[0];for(let e=0;e<c;e++){const n=t+e*o[1],r=Math.floor(e*v),s=Math.floor(r-k/2);for(let r=0;r<h;r++){const a=n+r*o[2],l=Math.floor(r*_),b=Math.floor(l-T/2);for(let n=0;n<d;n++){let o=0;for(let a=0;a<k;a++){const l=a+s;if(l<0||l>=p)continue;const d=t+l*u[1],m=l*x;if(e===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<T;e++){const t=e+b;if(t<0||t>=f)continue;const s=d+t*u[2],a=t*w;r===Math.min(h-1,i?Math.round(a):Math.floor(a))&&(o+=g[s+n])}}m[a+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}},ZN={kernelName:Fn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;W_(s,"reverse");const i=s.shape.length,o=W(a,s.shape);if(0===i)return Z_({inputs:{x:s},backend:n});const u=new fs(s.shape,s.dtype),l=n.bufferSync(s);for(let e=0;e<u.size;e++){const t=u.indexToLoc(e),n=t.slice();o.forEach(e=>n[e]=s.shape[e]-1-n[e]),u.set(l.get(...n),...t)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}},JN={kernelName:Tr,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,u=G(r.dtype,P(r.shape)),[l,c,h,d]=r.shape,[p,f]=sp(i,c,h),m=Math.sin(s),g=Math.cos(s),b=o.data.get(r.dataId).values;for(let e=0;e<l;e++){const t=e*h*c*d;for(let e=0;e<c;e++){const n=e*(h*d);for(let r=0;r<h;r++){const s=r*d;for(let i=0;i<d;i++){const o=[l,e,r,i],y=o[2],x=o[1];let w=(y-p)*g-(x-f)*m,v=(y-p)*m+(x-f)*g;w=Math.round(w+p),v=Math.round(v+f);let _=a;"number"!=typeof a&&(_=3===i?255:a[i]),w>=0&&w<h&&v>=0&&v<c&&(_=b[t+v*(h*d)+w*d+i]),u[t+n+s+i]=_}}}}return{dataId:o.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},QN=q_(Pn,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1}),eE={kernelName:Pn,backendName:"cpu",kernelFunc:QN},tE=H_(e=>1/Math.sqrt(e)),nE=K_(Mn,tE),rE={kernelName:Mn,backendName:"cpu",kernelFunc:nE};function sE(e,t,n,r,s,a,i,o,u,l){const c=[r/s,s],h=e.values,d=t.values;if(0===r)return ci(n,t.dtype);const p=u instanceof fs?u:ci(c,t.dtype);"string"==typeof u||"number"==typeof u?p.values.fill(u):"boolean"==typeof u&&p.values.fill(+u);for(let e=0;e<a;e++){const a=[];let u=0;for(let t=0;t<i;t++){const n=h[e*i+t];a.push(n),u+=n*o[t]}if(u<0||u>=r/s)throw new Error(`Invalid indices: ${a} does not index into ${n}`);for(let n=0;n<s;n++)l?p.values[u*s+n]+=d[e*s+n]:p.values[u*s+n]=0===t.rank?d[0]:d[e*s+n]}return p}const aE={kernelName:Ln,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=bh(0,s,i),d=sE(n.bufferSync(s),n.bufferSync(a),i,h,l,u,o,c,0,!0);return n.makeTensorInfo(i,d.dtype,d.values)}};function iE(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function oE(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}const uE={kernelName:Bn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=function(e,t,n,r,s,a){const i=H("int32",n*s);for(let o=0;o<n;++o){const n=e.slice(o*r,(o+1)*r),u=o*s;for(let e=0;e<s;++e)i[u+e]="left"===a?iE(n,t[e+u]):oE(n,t[e+u])}return i}(n.data.get(s.dataId).values,n.data.get(a.dataId).values,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",o)}},lE={kernelName:Un,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;W_([r,s,a],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,c=Ns(s.dtype,a.dtype),h=se(P(s.shape),c);let d=0;const p=0===i||i>1||1===s.shape.length?1:P(s.shape.slice(1));for(let e=0;e<o.length;e++)for(let t=0;t<p;t++)1===o[e]?h[d++]=u[e]:h[d++]=l[e];return n.makeTensorInfo(s.shape,c,h)}},cE=hp,hE=dp,dE=q_(Vn,e=>e>=0?hE*e:cE*(Math.exp(e)-1)),pE={kernelName:Vn,backendName:"cpu",kernelFunc:dE},fE=q_(Hn,e=>e<0?-1:e>0?1:0),mE={kernelName:Hn,backendName:"cpu",kernelFunc:fE},gE=q_(jn,e=>Math.sin(e)),bE={kernelName:jn,backendName:"cpu",kernelFunc:gE},yE=q_(Gn,e=>Math.sinh(e)),xE={kernelName:Gn,backendName:"cpu",kernelFunc:yE},wE=Math.log(1.1920928955078125e-7)+2,vE=q_(Kn,e=>{const t=e>-wE,n=e<wE,r=Math.exp(e);let s;return s=n?r:t?e:Math.log(1+r),s}),_E={kernelName:Kn,backendName:"cpu",kernelFunc:vE},kE={kernelName:Zn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;W_([s],"spaceToBatchND");const o=P(a),u=[[0,0]];u.push(...i);for(let e=1+a.length;e<s.shape.length;++e)u.push([0,0]);const l=SN.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),c=ap(l.shape,a,o,!1),h=ip(c.length,a.length,!1),d=op(l.shape,a,o,!1),p=Nk({inputs:{x:l},backend:n,attrs:{shape:c}}),f=Bk({inputs:{x:p},backend:n,attrs:{perm:h}}),m=Nk({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function TE(e,t,n,r,s,a,i){const o=t[0],u=a[0],l=new Array(u),c=new Array(o),h=t[1];if(0===u){if(0!==o)throw new Error(Lp(o));return[H(n,0),[0,h],H(s,0),l,c]}let d=!0,p=0;const f=new Array(u).fill(0);for(let t=0;t<o;++t){const n=e[t*h];if(n<0)throw new Error(zp(t,n));if(n>=u)throw new Error(Bp(t,n,u));++f[n],d=d&&n>=p,p=n}let m=!0;for(let e=0;e<u;++e){const t=0===f[e];l[e]=t,m=m&&!t,f[e]=Math.max(f[e],1),e>0&&(f[e]+=f[e-1])}if(m&&d){const t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,h],n,l,c]}{const t=f[u-1],a=H(n,t*h),d=H(s,t),p=new Array(u).fill(0);for(let t=0;t<o;++t){const n=e[t*h],s=p[n],i=(0===n?0:f[n-1])+s;p[n]++;for(let n=0;n<h;++n)a[i*h+n]=e[t*h+n];d[i]=r[t],c[t]=i}for(let e=0;e<u;++e)if(0===p[e]){const t=0===e?0:f[e-1];a[t*h+0]=e;for(let e=1;e<h;++e)a[t*h+e]=0;d[t]=i}return[a,[t,h],d,l,c]}}const SE={kernelName:er,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[h,d,p,f,m]=TE(o,r.shape,r.dtype,u,s.dtype,l,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function IE(e,t,n,r,s){const a=P(r),i=t[0],o=s.length,u=[];let l=1,c=-1;for(let e=0;e<o;++e){const t=s[e];if(-1===t){if(-1!==c)throw new Error(Up(c,e));c=e,u.push(1)}else{if(t<0)throw new Error(Vp(e,t));l*=t,u.push(t)}}if(-1!==c){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(a/l);if(l*e!==a)throw new Error(jp(r,u));u[c]=e}if(P(u)!==a)throw new Error(Gp(r,u));const h=r.length,d=[];if(h>0){d[h-1]=1;for(let e=h-2;e>=0;--e)d[e]=d[e+1]*r[e+1]}const p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*u[e+1]}const f=H(n,i*o);for(let t=0;t<i;++t){let n=0;for(let r=0;r<h;++r)n+=e[t*h+r]*d[r];for(let e=0;e<o;++e)f[t*o+e]=Math.trunc(n/p[e]),n%=p[e]}return[f,[i,o],u]}const NE={kernelName:tr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,u=Array.from(n.data.get(a.dataId).values),[l,c,h]=IE(o,r.shape,r.dtype,i,u);return[n.makeTensorInfo(c,r.dtype,l),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}};function EE(e,t,n,r,s,a=!1,i=0){const o=r.length,u=[t[0],e.length/t[0]],l=u[1],c=o>0?s[o-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=c;const d=H(n,h.reduce((e,t)=>e*t,1));if(0===o)return c>0&&d.fill(i),[d,h];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=s[p];for(;;){let t=0;if(f<o){if(t=s[f],g===t){++f;continue}if(g>=t)throw new Error(qp())}if(g<0||g>=c)throw new Error(Kp(g,c));g>m&&d.fill(i,m*l,g*l);for(let t=p;t<f;++t){const n=r[t];if(n<0||n>=u[0])throw new Error(Xp(t,r[t],u[0]));for(let t=0;t<l;t++)d[g*l+t]+=e[n*l+t]}if(a)for(let e=0;e<l;e++)d[g*l+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>o)break}return m<c&&d.fill(i,m*l,c*l),[d,h]}const $E={kernelName:nr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[l,c]=EE(i,r.shape,r.dtype,o,u,!0);return n.makeTensorInfo(c,r.dtype,l)}},AE={kernelName:rr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,[l,c]=EE(i,r.shape,r.dtype,o,u);return n.makeTensorInfo(c,r.dtype,l)}},CE={kernelName:sr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=bh(0,s,o),p=!1,f=n.bufferSync(s);let m;switch(a.dtype){case"bool":m=sE(f,n.bufferSync(a),o,d,c,l,u,h,Boolean(n.data.get(i.dataId).values[0]),p);break;case"float32":case"int32":m=sE(f,n.bufferSync(a),o,d,c,l,u,h,n.data.get(i.dataId).values[0],p);break;case"string":m=sE(f,n.bufferSync(a),o,d,c,l,u,h,rs(n.data.get(i.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}},OE={kernelName:Jn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=W(i,s.shape)[0],u=Mp(s,a,o),l=new Array(s.shape.length).fill(0),c=s.shape.slice();return u.map(e=>{const t=[...c];t[o]=e;const r=dT({inputs:{x:s},backend:n,attrs:{begin:l,size:t}});return l[o]+=e,r})}},RE=H_(e=>Math.sqrt(e)),DE=q_(Xn,e=>Math.sqrt(e)),FE={kernelName:Xn,backendName:"cpu",kernelFunc:DE},PE={kernelName:ir,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;W_(n,"square");const s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let e=0;e<s.length;++e){const t=s[e];a[e]=t*t}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},ME=tk((e,t)=>{const n=e-t;return n*n}),LE=vk(ar,ME),zE={kernelName:ar,backendName:"cpu",kernelFunc:LE},BE=H_((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)}),UE=K_(or,BE),VE={kernelName:or,backendName:"cpu",kernelFunc:UE},WE=q_(kr,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),jE={kernelName:kr,backendName:"cpu",kernelFunc:WE};function GE(e,t,n,r){const s=ci(e,t.dtype);for(let e=0;e<s.size;e++){const a=s.indexToLoc(e),i=new Array(a.length);for(let e=0;e<i.length;e++)i[e]=a[e]*n[e]+r[e];s.set(t.get(...i),...a)}return s}const HE={kernelName:ur,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r;W_(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:w}=Ao(s.shape,a,i,o,u,l,c,h,d);let v;if(m)v=Nk({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||b){R(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const e=bo(y,x,w),t=dT({inputs:{x:s},backend:n,attrs:{begin:y,size:e}});v=Nk({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=GE(p,n.bufferSync(s),w,y);v=n.makeTensorInfo(f,e.dtype,e.values)}return v}};class qE{constructor(e,t,n,r,s,a){this.separator=ns(e),this.nGramWidths=t,this.leftPad=ns(n),this.rightPad=ns(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){const o=this.getPadWidth(a),u=Math.max(0,o-i),l=Math.max(0,o-(s-(i+1))),c=a-(u+l),h=t+(u>0?0:i-o);let d=0;d+=u*this.leftPad.length;for(let t=0;t<c;++t)d+=e[h+t].length;d+=l*this.rightPad.length,d+=(u+l+c-1)*this.separator.length,n[r+i]=new Uint8Array(d);const p=n[r+i];let f=0;const m=e=>e.forEach(e=>p[f++]=e);for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[h+t]),m(this.separator);if(c>0){m(e[h+c-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let s=1;s<r;++s){let r=t[s]>=e;if(r=r&&t[s]<=n,!r)throw new Error(`Invalid split value ${t[s]}, must be in [${e}, ${n}]`);e=t[s]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const s=r-1,a=H("int32",r);if(0===n||0===r){const e=new Array(n);for(let e=0;e<=s;++e)a[e]=0;return[e,a]}a[0]=0;for(let e=1;e<=s;++e){const n=t[e]-t[e-1];let r=0;this.nGramWidths.forEach(e=>{r+=this.getNumNGrams(n,e)}),this.preserveShort&&n>0&&0===r&&(r=1),a[e]=a[e-1]+r}const i=new Array(a[s]);for(let n=0;n<s;++n){const r=t[n];let s=a[n];if(this.nGramWidths.forEach(a=>{const o=t[n+1]-t[n],u=this.getNumNGrams(o,a);this.createNGrams(e,r,i,s,u,a),s+=u}),this.preserveShort&&s===a[n]){const a=t[n+1]-t[n];if(0===a)continue;const o=a+2*this.padWidth,u=1;this.createNGrams(e,r,i,s,u,o)}}return[i,a]}}function KE(e,t,n,r,s,a,i,o){return new qE(n,r,s,a,i,o).compute(e,t)}const XE={kernelName:lr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:l}=r,{data:c,dataSplits:h}=t,d=n.data.get(c.dataId).values,p=n.data.get(h.dataId).values,[f,m]=KE(d,p,s,a,i,o,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};function YE(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let a=e.indexOf(s);for(;-1!==a;){const t=e.subarray(0,a);n&&0===t.length||r.push(t),a=(e=e.subarray(a+1)).indexOf(s)}return void(n&&0===e.length||r.push(e))}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||-1!==t.indexOf(e[a])){const t=e.subarray(s,a);n&&0===t.length||r.push(t),s=a+1}}function ZE(e,t,n){const r=e.length,s=[];let a=0,i=0;const o=new Array(r);for(let u=0;u<r;++u){const r=s.length;YE(e[u],t,n,s);const l=s.length-r;o[u]=l,a+=l,i=Math.max(i,l)}const u=H("int32",2*a),l=new Array(a),c=[r,i];let h=0;for(let e=0;e<r;++e)for(let t=0;t<o[e];++t)u[2*h]=e,u[2*h+1]=t,l[h]=s[h],++h;return[u,l,c]}const JE={kernelName:cr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values[0],[l,c,h]=ZE(o,u,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function QE(e,t){const n=H("int32",e.length);for(let r=0;r<e.length;++r)n[r]=Jr(e[r]).modulo(t).getLowBitsUnsigned();return n}const e$={kernelName:hr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=QE(n.data.get(a.dataId).values,s);return n.makeTensorInfo(a.shape,"int32",i)}},t$=q_(pr,e=>Math.tan(e)),n$={kernelName:pr,backendName:"cpu",kernelFunc:t$},r$=q_(fr,e=>Math.tanh(e)),s$={kernelName:zn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:u,strides:l,outputSize:c}=bh(0,s,r.shape),h=n.bufferSync(s),d=n.bufferSync(a),p=n.bufferSync(r),f=sE(h,d,r.shape,c,u,o,i,l,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};function a$(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=ci(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),s=new Array(e.rank);for(let t=0;t<s.length;t++)s[t]=n[t]%e.shape[t];const a=e.locToIndex(s);r.values[t]=e.values[a]}return r}const i$={kernelName:mr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;W_(s,"tile");const i=a$(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},o$=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function u$(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const s=r-n+1,a=t-n+1,i=Math.log(s),o=.5*Math.exp(2*i/3),u=.5*Math.sqrt(i*o*(s-o)/s)*Math.sign(a-s/2);u$(e,t,Math.max(n,Math.floor(t-a*o/s+u)),Math.min(r,Math.floor(t+(s-a)*o/s+u)))}const s=e[t];let a=n,i=r;for(O(e,n,t),o$(e[r],s)>0&&O(e,n,r);a<i;){for(O(e,a,i),a++,i--;o$(e[a],s)<0;)a+=1;for(;o$(e[i],s)>0;)i-=1}0===o$(e[n],s)?O(e,n,i):(i+=1,O(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function l$(e,t,n,r,s){const a=t[t.length-1],[i,o]=[e.length/a,a],u=G(n,i*r),l=G("int32",i*r);for(let t=0;t<i;t++){const n=t*o,a=e.subarray(n,n+o);let i=new Array(a.length);a.forEach((e,t)=>i[t]={value:e,index:t}),r<i.length&&(u$(i,r),i=i.slice(0,r)),s&&i.sort(o$);const c=t*r,h=u.subarray(c,c+r),d=l.subarray(c,c+r);for(let e=0;e<r;e++)h[e]=i[e].value,d[e]=i[e].index}const c=t.slice();return c[c.length-1]=r,[ci(c,n,u),ci(c,"int32",l)]}const c$={kernelName:gr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;W_(s,"topk");const o=n.data.get(s.dataId).values,[u,l]=l$(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}},h$={kernelName:br,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:l}=n,[c,h,d,p]=s.shape,[f,m]=null!=l?l:[h,d],g=[c,f,m,p],b=ee(s.shape),y=b[0],x=b[1],w=b[2],v=ee(g),_=v[0],k=v[1],T=v[2],S=G(s.dtype,P(g));S.fill(u);const I=r.data.get(s.dataId).values,N=r.data.get(a.dataId).values;for(let e=0;e<c;++e){const t=1===a.shape[0]?N:N.subarray(8*e,8*e+8);for(let n=0;n<f;++n)for(let r=0;r<m;++r)for(let s=0;s<p;++s){let a;const l=t[6]*r+t[7]*n+1;if(0===l)continue;const c=(t[0]*r+t[1]*n+t[2])/l,p=(t[3]*r+t[4]*n+t[5])/l,f=d$(c,d,o),m=d$(p,h,o);switch(i){case"nearest":a=f$(I,h,d,y,x,w,e,m,f,s,u);break;case"bilinear":a=m$(I,h,d,y,x,w,e,m,f,s,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}S[e*_+n*k+r*T+s]=a}return r.makeTensorInfo(g,s.dtype,S)}return{dataId:r.write(S,g,s.dtype),shape:s.shape,dtype:s.dtype}}};function d$(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return A(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return A(0,n,t-1)}(e,t);case"nearest":return function(e,t){return A(0,e,t-1)}(e,t);default:return e}}function p$(e,t,n,r,s,a,i,o,u,l,c){return 0<=o&&o<t&&0<=u&&u<n?e[i*r+o*s+u*a+l]:c}function f$(e,t,n,r,s,a,i,o,u,l,c){return p$(e,t,n,r,s,a,i,Math.round(o),Math.round(u),l,c)}function m$(e,t,n,r,s,a,i,o,u,l,c){const h=Math.floor(o),d=Math.floor(u),p=h+1,f=d+1;return(p-o)*((f-u)*p$(e,t,n,r,s,a,i,h,d,l,c)+(u-d)*p$(e,t,n,r,s,a,i,h,f,l,c))+(o-h)*((f-u)*p$(e,t,n,r,s,a,i,p,d,l,c)+(u-d)*p$(e,t,n,r,s,a,i,p,f,l,c))}function g$(e,t,n,r){const s=W(t,n)[0],a=[1,n[0],1];for(let e=0;e<s;e++)a[0]*=n[e];a[1]=n[s];for(let e=s+1;e<n.length;e++)a[2]*=n[e];const i=new Map,o=new Int32Array(n[s]),u=new fs(a,r,e),l=[],c=1===a[0]&&1===a[2];for(let t=0;t<n[s];t++){let n;if(c)n=e[t].toString();else{const e=[];for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)e.push(u.get(n,t,r));n=e.join(",")}const r=i.get(n);if(null!=r)o[t]=r;else{const e=i.size;i.set(n,e),o[t]=e,l.push(t)}}const h=a.slice();h[1]=i.size;const d=new fs(h,r);l.forEach((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)d.set(u.get(n,e,r),n,t,r)});const p=n.slice();return p[s]=h[1],{outputValues:d.values,outputShape:p,indices:o}}const b$={kernelName:xr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;W_(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:o,outputShape:u,indices:l}=g$(i,s,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,o),r.makeTensorInfo([l.length],"int32",l)]}},y$={kernelName:wr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],u=new Array(i-1);let l=0;for(let e=0;e<i;e++)e!==a&&(u[l++]=s.shape[e]);const c=new Array(i).fill(0),h=s.shape.slice();h[a]=1;const d=new Array(o);for(let e=0;e<d.length;e++){c[a]=e;const t=dT({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});d[e]=Nk({inputs:{x:t},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(t)}return d}},x$={kernelName:vr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;W_(s,"unsortedSegmentSum");const o=[],u=[],l=s.shape.length-a.shape.length;let c=a;for(let e=0;e<l;++e){const t=IS({inputs:{input:c},backend:n,attrs:{dim:e+1}});c=t,u.push(t)}for(let e=0;e<i;++e){const t=Qr(e,"int32"),r=n.makeTensorInfo([],"int32",t),a=pS({inputs:{a:r,b:c},backend:n}),i=xk({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),l=iS({inputs:{a:i,b:s},backend:n}),h=uS({inputs:{x:l},backend:n,attrs:{axis:0,keepDims:!1}});o.push(h),u.push(r),u.push(a),u.push(i),u.push(l),u.push(h)}const h=kN({inputs:o,backend:n,attrs:{axis:0}});return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),h}},w$=[Ck,Rk,Fk,Mk,Ik,Lk,Vk,Wk,jk,Gk,qk,Xk,Zk,eT,nT,iT,oT,uT,lT,Ak,cT,fT,bT,wT,vT,wk,TT,IT,fk,NT,OT,DT,FT,PT,MT,LT,zT,UT,WT,jT,GT,HT,qT,KT,YT,ZT,JT,QT,eS,tS,nS,rS,cS,Y_,hS,fS,_S,SS,NS,AS,US,WS,jS,qS,YS,ZS,JS,eI,nI,aI,uI,J_,lI,AT,hI,pI,mI,ek,yI,vI,kI,II,EI,CI,RI,PI,MI,LI,UI,jI,GI,HI,qI,KI,XI,YI,ZI,eN,tN,sN,oN,oS,lN,hN,pN,mN,yN,xN,_N,TN,SN,EN,sk,AN,RN,PN,VN,jN,bk,RS,HN,ik,uk,Ek,qN,KN,XN,YN,ZN,JN,eE,rE,aE,uE,lE,pE,hk,mE,bE,xE,pT,iN,_E,kE,SE,NE,$E,AE,CE,OE,FE,PE,zE,VE,jE,HE,XE,JE,e$,MS,lS,n$,{kernelName:fr,backendName:"cpu",kernelFunc:r$},s$,i$,c$,h$,Uk,b$,y$,x$,vN];for(const e of w$)Fr(e);const v$={},_$={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function k$(e,t){if(!(e in v$)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(pe().getBool("IS_SAFARI")||"undefined"==typeof OffscreenCanvas||2!==e){if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;return n.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete v$[e]},!1),pe().getBool("SOFTWARE_WEBGL_ENABLED")&&(_$.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",_$)||n.getContext("experimental-webgl",_$):n.getContext("webgl2",_$)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;v$[e]=n}const n=v$[e];return null==n||n.isContextLost()?(delete v$[e],k$(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),v$[e])}var T$,S$,I$;function N$(e,t){return[t,e]}function E$(e){const t=P(e);return z(Math.ceil(t/4))}function $$(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function A$(e,t){const n=e;let r,s,a,i,o,u,l,c,h,d;return 2===pe().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,l=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT,u=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,l=4,c=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,u=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function C$(e,t){const n=t();return pe().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}function O$(e){return!!(pe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function R$(e,t){return V$(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(T$||(T$={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(S$||(S$={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(I$||(I$={}));const D$=/ERROR: [0-9]+:([0-9]+):/g;function F$(e,t){const n=D$.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],s=e.split("\n"),a=s.length.toString().length+2,i=s.map((e,t)=>B((t+1).toString(),a)+e);let o=0;for(let e=0;e<i.length;e++)o=Math.max(i[e].length,o);const u=i.slice(0,r-1),l=i.slice(r-1,r),c=i.slice(r);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${B(l[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function P$(e,t){if(C$(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function M$(e,t,n,r,s,a,i){const o=e.getAttribLocation(t,n);return-1!==o&&(C$(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),C$(e,()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i)),C$(e,()=>e.enableVertexAttribArray(o)),!0)}function L$(e,t,n,r){C$(e,()=>function(e,t,n){(function(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(e,n),C$(e,()=>e.activeTexture(e.TEXTURE0+n)),C$(e,()=>e.bindTexture(e.TEXTURE_2D,t))}(e,t,r)),C$(e,()=>e.uniform1i(n,r))}function z$(e,t,n){C$(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),C$(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function B$(e,t){C$(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),C$(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function U$(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function V$(e,t,n){const r=C$(e,()=>t());if(null==r)throw new Error(n);return r}function W$(e,t=2){return P(e.slice(0,e.length-t))}function j$(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function G$(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[W$(e),...j$(e)]),t}function H$(e){return e%2==0}function q$(e,t){if(M(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(H$(n)&&H$(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&H$(e[0])&&H$(t[0])}let K$,X$;function Y$(e,t){return null!=e.getExtension(t)}function Z$(e){try{if(null!=k$(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function J$(e){const t=A$(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function Q$(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&R("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const eA=pe();function tA(){let e,t,n,r,s,a,i,o,u,l;return 2===pe().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=pe().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",u="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:u,defineRound:l}}function nA(e,t,n="index"){const r=ee(t);return r.map((t,s)=>`int ${e[s]} = ${n} / ${t}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`};`).join("")}function rA(e,t,n="index"){const r=ee(t);return r.map((t,s)=>`int ${e[s]} = ${n} / outShapeStrides[${s}]; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`};`).join("")}function sA(e){const t=ee(e).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}eA.registerFlag("HAS_WEBGL",()=>eA.getNumber("WEBGL_VERSION")>0),eA.registerFlag("WEBGL_VERSION",()=>Z$(2)?2:Z$(1)?1:0),eA.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),eA.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===eA.get("WEBGL_VERSION")),eA.registerFlag("WEBGL_CPU_FORWARD",()=>!0),eA.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),eA.registerFlag("WEBGL_PACK",()=>eA.getBool("HAS_WEBGL")),eA.registerFlag("WEBGL_PACK_NORMALIZATION",()=>eA.getBool("WEBGL_PACK")),eA.registerFlag("WEBGL_PACK_CLIP",()=>eA.getBool("WEBGL_PACK")),eA.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>eA.getBool("WEBGL_PACK")),eA.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>eA.getBool("WEBGL_PACK")),eA.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>eA.getBool("WEBGL_PACK")),eA.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>eA.getBool("WEBGL_PACK")),eA.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>eA.getBool("WEBGL_PACK")),eA.registerFlag("WEBGL_PACK_REDUCE",()=>eA.getBool("WEBGL_PACK")),eA.registerFlag("WEBGL_LAZILY_UNPACK",()=>eA.getBool("WEBGL_PACK")),eA.registerFlag("WEBGL_CONV_IM2COL",()=>eA.getBool("WEBGL_PACK")),eA.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>eA.getBool("WEBGL_PACK")),eA.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(e){if(null==K$){const t=k$(e);K$=t.getParameter(t.MAX_TEXTURE_SIZE)}return K$}(eA.getNumber("WEBGL_VERSION"))),eA.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(e){if(null==X$){const t=k$(e);X$=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,X$)}(eA.getNumber("WEBGL_VERSION"))),eA.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=eA.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=k$(e);return t=Y$(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:Y$(n,"EXT_disjoint_timer_query")?1:0,t}(e)}),eA.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>eA.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Us()),eA.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(e){if(0===e)return!1;const t=k$(e);if(1===e){if(!Y$(t,"OES_texture_float"))return!1}else if(!Y$(t,"EXT_color_buffer_float"))return!1;return J$(t)}(eA.getNumber("WEBGL_VERSION"))),eA.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!eA.getBool("WEBGL_FORCE_F16_TEXTURES")&&eA.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),eA.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(e){if(0===e)return!1;const t=k$(e);if(1!==e){if(Y$(t,"EXT_color_buffer_float"))return J$(t);const e="EXT_color_buffer_half_float";if(Y$(t,e)){const n=t.getExtension(e);return function(e,t){const n=A$(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),a}(t,n)}return!1}return!!Y$(t,"OES_texture_float")&&!!Y$(t,"WEBGL_color_buffer_float")&&J$(t)}(eA.getNumber("WEBGL_VERSION"))),eA.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(e=eA.getNumber("WEBGL_VERSION"))&&null!=k$(e).fenceSync;var e}),eA.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>eA.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),eA.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if("number"!=typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}),eA.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Us()?1:-1,e=>{if("number"!=typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)}),eA.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),eA.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),eA.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),eA.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),eA.registerFlag("WEBGL_EXP_CONV",()=>!1),eA.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>eA.getBool("IS_TEST")),eA.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),eA.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),eA.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),eA.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const aA="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:iA}=s;function oA(e,t,n){const r=[];if(e.forEach(e=>{const t=P(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=bA(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)});const s=r.join("\n"),a=e.map(e=>function(e,t,n=!1,r){let s="";s+=n?lA(e,r):uA(e,r);const a=e.shapeInfo.logicalShape,i=t.logicalShape;return a.length<=i.length&&(s+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=iA(e.shapeInfo.logicalShape,t.logicalShape),u=gA(i),l=i-a;let c;const h=["x","y","z","w","u","v"];c=0===a?"":i<2&&o.length>=1?"coords = 0;":o.map(e=>`coords.${h[e+l]} = 0;`).join("\n");let d="";d=i<2&&a>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${h[t+l]}`).join(", ");let p="return outputValue;";const f=1===P(e.shapeInfo.logicalShape),m=1===P(t.logicalShape);if(1!==a||f||m){if(f&&!m)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=a-2,t=a-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${d});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===u&&null==e.shapeInfo.flatOffset&&M(i,a))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const l=gA(u),c=iA(e.shapeInfo.logicalShape,t.logicalShape),h=u-o;let d;const p=["x","y","z","w","u","v"];d=0===o?"":u<2&&c.length>=1?"coords = 0;":c.map(e=>`coords.${p[e+h]} = 0;`).join("\n");let f="";return f=u<2&&o>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${p[t+h]}`).join(", "),`\n    float ${s}() {\n      ${l} coords = getOutputCoords();\n      ${d}\n      return get${r}(${f});\n    }\n  `}(e,t)),s}(e,t,n.packedInputs,n.enableShapeUniforms)).join("\n"),i=t.texShape,o=tA(),u=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let l,c,h=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${cA}\n    ${hA}\n    ${dA}\n  `}(o);return t.isPacked?(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(M(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2);let i=a,o="",u="b, r, c";for(let t=2;t<e.length-1;t++)i*=e[e.length-t-1],o=`\n      int b${t} = index / ${i};\n      index -= b${t} * ${i};\n    `+o,u=`b${t}, `+u;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${e.length}(${u});\n    }\n  `}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(o)):(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){return M(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${rA(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;const r=nA(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${rA(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=nA(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=nA(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=nA(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(h+=pA),[h,u,c,s,l,a,n.userCode].join("\n")}function uA(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,a]=e.shapeInfo.texShape;if(1===s&&1===a)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=fA(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,u]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${u}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${mA(e)}\n      }\n    `;const s=e.shapeInfo.texShape,a=s[0],i=s[1];if(1===i&&1===a)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=fA(n);return 1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===a?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(null!=a&&M(n,a)){if(t)return`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=a[0];return`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${a[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:i,keptDims:o}=j(n),u=i;if(u.length<n.length){const n=["row","col"];return`\n      ${uA(yA(e,u),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${xA(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${mA(e)}\n      }\n    `;const l=a[0],c=a[1],h=fA(r);return 1===c?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===l?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${l}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:u}=j(n),l=o;if(l.length<n.length){const n=["row","col","depth"];return`\n        ${uA(yA(e,l),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${xA(n,u)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${a}, ${i}, 1)));\n        ${mA(e)}\n      }\n    `;const c=e.shapeInfo.texShape,h=c[0],d=c[1],p=e.shapeInfo.flatOffset;if(d===a&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(d===i&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=fA(r);return t?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:u,keptDims:l}=j(n);if(u.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${uA(yA(e,u),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${xA(n,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${a}, 1)));\n        ${mA(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===a&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const b=fA(r);return t?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${b});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${a} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${p}, index + ${b});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:u,keptDims:l}=j(t);if(u.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${uA(yA(e,u))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${xA(t,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${a}, ${s})) +\n          depth3;\n        ${mA(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${a} +\n          depth2 * ${s} + depth3 + ${fA(n)};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=j(t);if(s.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${uA(yA(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${xA(t,a)});\n      }\n    `}const i=t[5],o=t[4]*i,u=t[3]*o,l=t[2]*u,c=t[1]*l;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${l}, ${u}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${mA(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];if(f===c&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${u}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${fA(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function lA(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${tA().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=tA();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],u=tA();if(null!=a&&M(n,a))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `;const l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(n[1]/2)}, ${l[0]}, ${l[1]}, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===n[0]){const r=[1,2],a=["b","row","col"];return`\n        ${lA(yA(e,n.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${xA(a,r)});\n        }\n      `}const o=tA();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const u=i[0],l=i[1],c=Math.ceil(n[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${u}, ${l}, ${c*Math.ceil(n[1]/2)}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=tA();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);\n    }\n  `;const a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=u[0],c=u[1],h=Math.ceil(a[i-1]/2);let d=h*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let e=2;e<i-1;e++)p=`int b${e}, `+p,d*=a[i-e-1],f=`b${e} * ${d} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const cA="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",hA="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",dA="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",pA="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function fA(e){return`offset${e}`}function mA(e){const t=e.name,n=P(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function gA(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function bA(e,t,n){const{newShape:r,keptDims:s}=j(t),a=t.length,i=e&&3===a&&1===t[0],o=i?t.slice(1):r,u=!e&&a>1&&!M(t,n)&&r.length<a||i;return{useSqueezeShape:u,uniformShape:u?o:t,keptDims:s}}function yA(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function xA(e,t){return t.map(t=>e[t]).join(", ")}function wA(e,t,n){const r=[],s=[];let a,i,o,u=null,l=null;l=e.getUniformLocation(n,"NAN",!1),1===pe().getNumber("WEBGL_VERSION")&&(u=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const s of t.variableNames){const a={name:s,uniform:e.getUniformLocation(n,s,c),offset:e.getUniformLocation(n,`offset${s}`,c)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,`${s}Shape`,c),a.texShape=e.getUniformLocation(n,`${s}TexShape`,c)),r.push(a)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const r of t.customUniforms)s.push(e.getUniformLocation(n,r.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:u,nanLoc:l,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function vA(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((e,n)=>{const r=e.logicalShape,s=t[n],a=s.shape;if(!M(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&s.isUniform)return;const i=e.texShape,o=s.isUniform?null:s.texData.texShape;if(!M(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)})}function _A(e){return pe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class kA{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=T$.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=tA();this.outputShape=e,this.enableShapeUniforms=_A(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?rA(["r","c","d"],e):nA(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class TA{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=T$.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=tA();this.outputShape=e,this.enableShapeUniforms=_A(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?rA(["r","c","d"],e):nA(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class SA{constructor(e){this.variableNames=["A"],this.outTexUsage=S$.DOWNLOAD;const t=tA();this.outputShape=e,this.userCode=`\n      ${aA}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class IA{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=S$.DOWNLOAD;const t=tA();this.outputShape=e,this.userCode=`\n      ${aA}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const NA={R:0,G:1,B:2,A:3};class EA{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=tA();this.outputShape=e,this.enableShapeUniforms=_A(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let e=0;e<n.length;e++){const t=n[e];a+=`\n          if(offset == ${e}) {\n            result = values[${NA[t]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":sA(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${a}\n        }\n        ${r.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class $A{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=tA();this.outputShape=e,this.enableShapeUniforms=_A(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let s=0;s<=1;s++){const a=2*t+s;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${s} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${s};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":sA(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${s};\n        }\n    `}}function AA(e,t,n,r,s,a){!function(e,t){const n=pe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return V$(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return C$(e,()=>e.bindTexture(o,i)),C$(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),C$(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),C$(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),C$(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),1===pe().getNumber("WEBGL_VERSION")?C$(e,()=>e.texImage2D(o,0,r,t,n,0,s,a,null)):C$(e,()=>e.texStorage2D(o,1,r,t,n)),C$(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function CA(e){return e.internalFormatFloat}function OA(e){return e.internalFormatHalfFloat}function RA(e){return e.downloadTextureFormat}function DA(e){return e.internalFormatPackedFloat}function FA(e){return e.internalFormatPackedHalfFloat}class PA{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=pe().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){v$[e]=t}(t,e)):this.gl=k$(t),e=this.gl,2===pe().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>C$(t,()=>t.createVertexArray()),this.bindVertexArray=e=>C$(t,()=>t.bindVertexArray(e)),this.deleteVertexArray=e=>C$(t,()=>t.deleteVertexArray(e)),this.getVertexArray=()=>C$(t,()=>t.getParameter(t.VERTEX_ARRAY_BINDING))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>C$(e,()=>t.createVertexArrayOES()),this.bindVertexArray=n=>C$(e,()=>t.bindVertexArrayOES(n)),this.deleteVertexArray=n=>C$(e,()=>t.deleteVertexArrayOES(n)),this.getVertexArray=()=>C$(e,()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===pe().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=R$(this.gl,e),Y$(this.gl,t))this.textureHalfFloatExtension=R$(this.gl,t);else if(pe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Y$(this.gl,r))this.colorBufferHalfFloatExtension=R$(this.gl,r);else if(pe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Y$(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!Y$(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function(e){return function(e,t){const n=V$(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return C$(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),C$(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(e){return function(e,t){const n=V$(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return C$(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),C$(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(e){return V$(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=A$(this.gl,this.textureHalfFloatExtension)}get debug(){return pe().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;C$(e,()=>e.finish()),C$(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),C$(e,()=>e.deleteFramebuffer(this.framebuffer)),C$(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),C$(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),C$(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=N$(t,n);return AA(e,s,a,CA(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=N$(t,n);return AA(e,s,a,OA(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=N$(t,n);return AA(e,s,a,RA(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){C$(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?2===pe().getNumber("WEBGL_VERSION")?C$(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):C$(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):2===pe().getNumber("WEBGL_VERSION")?C$(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):C$(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),C$(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,s,a){let i,o,u;C$(e,()=>e.bindTexture(e.TEXTURE_2D,t)),s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,u=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,u=a.internalFormatPackedFloat),i.set(s),2===pe().getNumber("WEBGL_VERSION")?C$(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):C$(e,()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,o,i)),C$(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=$$(t,n);return AA(e,s,a,FA(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=$$(t,n);return AA(e,s,a,DA(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(B$(this.gl,this.framebuffer),this.outputTexture=null),C$(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n,r){const[s,a]=N$(t,n),i=new Uint8Array(t*n*4);return C$(e,()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return function(e,t,n,r,s,a,i){const o=e,u=new Float32Array(function(e,t){const[n,r]=$$(e,t);return n*r*4}(a,i));return o.bindBuffer(o.PIXEL_PACK_BUFFER,t),o.getBufferSubData(o.PIXEL_PACK_BUFFER,0,u),o.bindBuffer(o.PIXEL_PACK_BUFFER,null),u}(this.gl,e,0,0,0,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n){const r=e.createBuffer();C$(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r));const s=16*t*n;return C$(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),C$(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),C$(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(pe().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n){const r=new Float32Array(t*n*4);return C$(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=function(e){const t=tA();return function(e,t){const n=V$(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(C$(e,()=>e.shaderSource(n,t)),C$(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(t));const n=function(e){return V$(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}(t);C$(t,()=>t.attachShader(n,this.vertexShader)),C$(t,()=>t.attachShader(n,e)),function(e,t){if(C$(e,()=>e.linkProgram(t)),!pe().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&P$(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;C$(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),function(e,t,n){C$(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),M$(e,t,"clipSpacePos",n,3,20,0)&&M$(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(C$(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&P$(this.gl,this.program),C$(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return V$(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),C$(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),L$(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=$$(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&P$(this.gl,this.program),U$(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}C$(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),C$(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=R$(this.gl,2===pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await U(()=>this.disposed||this.isQueryAvailable(e,pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in pe().platform&&(n=pe().platform.setTimeoutCustom.bind(pe().platform)),U(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),z$(this.gl,e,this.framebuffer),this.debug&&U$(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(z$(this.gl,this.outputTexture,this.framebuffer),this.debug&&U$(this.gl)):B$(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;z$(r,e,this.framebuffer),this.debug&&U$(r),this.outputTexture=e,C$(r,()=>r.viewport(0,0,t,n)),C$(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),C$(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:MA,XI:LA,Nk:zA,f6:BA,ct:UA,YG:VA,hH:WA,z3:jA,sG:GA,uM:HA,vS:qA,qB:KA,GG:XA,rq:YA,lg:ZA,WR:JA,cu:QA,GE:eC,px:tC,jC:nC,He:rC,hE:sC,BF:aC,Dk:iC,cl:oC,_B:uC,ub:lC,_f:cC,Ku:hC,qy:dC,Zy:pC,bu:fC,zv:mC,dH:gC,HS:bC,yH:yC,l3:xC,z9:wC,x6:vC,_m:_C,eW:kC,GK:TC,SP:SC,yr:IC,dl:NC,Dw:EC,xT:$C,_X:AC,wz:CC}=S;function OC(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>`${e}.${t}`)}function RC(e,t){return 1===t?[e]:OC(e,t)}class DC{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=_A(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=RC("rc",this.rank),t=gA(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),s=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)s=`${e[e.length-1-t]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class FC{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=_A(this.outputShape.length);let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var r,s;this.userCode=`\n      ${r=t,s=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${s?function(e,t,n="index"){const r=function(e,t){const n=e.length,r=e.map(e=>`${t}[${e}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let e=n-3;e>=0;--e)s[e]=`(${s[e+1]} * ${r[e+1]})`;return s}(e.map((e,t)=>t),t);return r.map((t,s)=>`int ${e[s]} = ${n} / ${r[s]}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${r[s]}`:`index -= ${e[s]} * ${r[s]}`};`).join("")}(["r","c","d"],"inputShape"):nA(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":sA(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class PC{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=LC(t,n),s=zC(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=MC(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[s].pop();return this.usedTextures[s].push(e),e}let i;return r===I$.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===I$.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===I$.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===I$.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===I$.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=LC(n,r),a=zC(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=MC(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=pe().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const u=this.usedTextures[a],l=u&&u.indexOf(e);if(null==l||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[l]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function MC(e,t,n,r,s){const a=function(e,t){switch(e){case I$.PACKED_2X2_FLOAT32:return DA(t);case I$.PACKED_2X2_FLOAT16:return FA(t);case I$.UNPACKED_FLOAT32:return CA(t);case I$.UNPACKED_FLOAT16:return OA(t);case I$.PACKED_4X1_UNSIGNED_BYTE:return RA(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(s){const[t,n]=$$(e[0],e[1]);i=t*n}else{const[t,n]=N$(e[0],e[1]);i=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,a);return i*o}function LC(e,t){if(e===S$.UPLOAD)return I$.PACKED_2X2_FLOAT32;if(e===S$.RENDER||null==e)return function(e){return pe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?I$.PACKED_2X2_FLOAT32:I$.UNPACKED_FLOAT32:e?I$.PACKED_2X2_FLOAT16:I$.UNPACKED_FLOAT16}(t);if(e===S$.DOWNLOAD||e===S$.PIXELS)return I$.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function zC(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class BC{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=_A(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const UC="if (isnan(x)) return x;",VC="return abs(x);",WC=UC+"\n  return (x < 0.0) ? 0.0 : x;\n",jC=UC+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",GC="return x;";class HC{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=_A(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class qC{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=_A(this.outputShape.length);const t=e.length,n=RC("rc",t),r=gA(t),s=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const KC=Ih,XC={},YC=pe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class ZC extends N{nextDataId(){return ZC.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!pe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof PA)t=e;else{const n=k$(pe().getNumber("WEBGL_VERSION"),e);t=new PA(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=k$(pe().getNumber("WEBGL_VERSION"));t=new PA(e),this.binaryCache=((n=pe().getNumber("WEBGL_VERSION"))in XC||(XC[n]={}),XC[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new PC(this.gpgpu),this.numMBBeforeWarning=null==pe().global.screen?1024:pe().global.screen.height*pe().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new I(this,na())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,s,a){const i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,s]},o.texShape=[r,s];const u=G$(t),l=new EA(u,!1,a),c=this.runWebGLProgram(l,[i],n,[[r,s]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if((pe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||pe().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:S$.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,r,s){if(pe().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:S$.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:i,isPacked:o}=t;if(null!=a){let t;t=o?new HC(i,GC):new BC(i,GC);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const u=null!=this.activeTimers;let l,c;return u&&(l=ts()),c="complex64"===r?xp(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.getValuesFromTexture(e),u&&(this.downloadWaitMs+=ts()-l),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise(e=>t.push(e))}const t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:a,complexTensorInfos:i,isPacked:o}=t;if(null!=s){let t;t=o?new HC(r,GC):new BC(r,GC);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:a}],a),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if(pe().getBool("DEBUG")&&!pe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===pe().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u,l,c=null;if("complex64"!==a&&pe().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const t=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...E$(r))}if(this.pendingRead.set(e,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);l=xp(e[0],e[1])}else if(null==c)l=this.getValuesFromTexture(e);else{const e=P(r);l=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=u&&this.disposeIntermediateTensorInfo(u),null!=c){const e=this.gpgpu.gl;C$(e,()=>e.deleteBuffer(c))}const h=this.convertAndCacheOnCPU(e,l),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(e=>e(h)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&na().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e,t={}){const n=this.texData.get(e),{values:r,shape:s,slice:a,dtype:i,isPacked:o,texture:u}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let n;n=o?new HC(s,GC):new BC(s,GC);const r=this.runWebGLProgram(n,[{dataId:e,shape:s,dtype:i}],i),a=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),a}if(null==u)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,t.customTexShape),c=na().makeTensorFromTensorInfo(l),h=this.texData.get(l.dataId);return Object.assign({tensorRef:c},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map(e=>rs(e));return ci(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return ci(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!O$(n)){if(pe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=P(t);if(pe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...E$(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),a}const a=pe().getBool("WEBGL_PACK")&&!0===r,i=a?G$(t):t,o=a?new IA(i):new SA(i),u=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),l=this.texData.get(u.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),c}timerAvailable(){return pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=as(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),a=as(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);i.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),i.getExtraProfileInfo=()=>e.map((e,t)=>({name:a[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ts(),endMs:null}}endTimer(e){return pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=ts(),e)}async getQueryTime(e){if(pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,u=this.dataRefCount.get(o);u>1?this.dataRefCount.set(o,u-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,a)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=YC){return pe().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&P(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Er("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return KC(e.shape,t)}packedUnaryOp(e,t,n){const r=new HC(e.shape,t),s=this.compileAndRun(r,[e],n);return na().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=gC(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(pe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,VC,e.dtype);const t=new BC(e.shape,VC),n=this.compileAndRun(t,[e]);return na().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&X(n[0])){const s=n.map(e=>ns(e));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return na().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new qC(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new DC(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[W$(e.shape),...j$(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[W$(t),...j$(t)],a=new FC(s,n),i=[n],o=this.runWebGLProgram(a,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:s,dtype:a}=n;null!=t&&R(P(s)<=t[0]*t[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const i=G$(s);let o;o=r?new TA(i):new kA(i);const u=[null!=t?t:E$(i)];return{dtype:a,shape:s,dataId:this.runWebGLProgram(o,[{shape:i,dtype:a,dataId:e}],a,u,!0,t).dataId}}runWebGLProgram(e,t,n,r,s=!1,a){const i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===T$.DENSE){const t=null!=a?a:E$(e.outputShape);o.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===P(i.shape))return o.values=G(i.dtype,0),i;const u=[],l=t.map(t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&P(t.shape)<=pe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),u.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!q$(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),u.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(i.dataId);const c={shape:i.shape,texData:o,isUniform:!1},h=function(e,t,n){let r="";t.concat(n).forEach(t=>{const s=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const a=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:u}=bA(e.packedInputs,t.shape,a);let l="",c="",h="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];l=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=ee(o);h=`${e[0]===a[1]}_${e[e.length-1]===a[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;const d=t.shape.length,p=2===o.length&&M(t.shape,a),f=1===P(t.shape),m=Pi(t.shape,n.shape),g=!e.packedInputs&&d===n.shape.length&&M(a,n.texData.texShape),b=e.packedInputs||o.length>2?"":`${a[0]>1}_${a[1]>1}`;r+=`${d}_${g}_${i?u:""}_${o.length}_${f}_${m}_${p}_${l}_${c}_${h}_${b}_${s}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${s}`}});const s=e.userCode;let a=e.constructor.name;return a+="_"+r+"_"+s+`${pe().getNumber("WEBGL_VERSION")}`,a}(e,l,c),d=this.getAndSaveBinary(h,()=>function(e,t,n,r){const s=n.map((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}}),a=s.map(e=>e.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=oA(s,i,t),u=function(e,t){const n=V$(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(C$(e,()=>e.shaderSource(n,t)),C$(e,()=>e.compileShader(n)),pe().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw F$(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,o),l=e.createProgram(u);return pe().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:o,webGLProgram:l,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(l),Object.assign({program:t,fragmentShader:u,source:o,webGLProgram:l,inShapeInfos:a,outShapeInfo:i},wA(e,t,l)))}(this.gpgpu,e,l,c)),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),pe().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,s){t.program.enableShapeUniforms||(vA(t.inShapeInfos,n),vA([t.outShapeInfo],[r]));const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===pe().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let r=0;r<n.length;++r){const s=n[r],{uniform:a,offset:i,shape:o,texShape:u}=t.variablesLocations[r];if(o){const{uniformShape:n}=bA(t.program.packedInputs,s.shape,s.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(o,new Int32Array(n));break;case 2:e.gl.uniform2iv(o,new Int32Array(n));break;case 3:e.gl.uniform3iv(o,new Int32Array(n));break;case 4:e.gl.uniform4iv(o,new Int32Array(n))}}if(u&&e.gl.uniform2i(u,s.texData.texShape[0],s.texData.texShape[1]),null!=a)if(s.isUniform)if(P(s.shape)<2)e.gl.uniform1f(a,s.uniformValues[0]);else{let t=s.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=s.texData.slice&&null!=i&&e.gl.uniform1i(i,s.texData.slice.flatOffset),e.setInputMatrixTexture(s.texData.texture.texture,a,r)}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=ee(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let n=0;n<t.program.customUniforms.length;++n){const r=t.program.customUniforms[n],a=t.customUniformLocations[n],i=s[n];if("float"===r.type)e.gl.uniform1fv(a,i);else if("vec2"===r.type)e.gl.uniform2fv(a,i);else if("vec3"===r.type)e.gl.uniform3fv(a,i);else if("vec4"===r.type)e.gl.uniform4fv(a,i);else if("int"===r.type)e.gl.uniform1iv(a,i);else if("ivec2"===r.type)e.gl.uniform2iv(a,i);else if("ivec3"===r.type)e.gl.uniform3iv(a,i);else{if("ivec4"!==r.type)throw Error(`uniform type ${r.type} is not supported yet.`);e.gl.uniform4iv(a,i)}}e.executeProgram()}(this.gpgpu,d,l,c,r),u.forEach(e=>this.disposeIntermediateTensorInfo(e)),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=pe().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=ts();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!pe().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===s){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(pe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=sa(()=>{if(!pe().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=pe().getBool("DEBUG");pe().set("DEBUG",!1);const t=this.abs(_i(1e-8)).dataSync()[0];if(pe().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:a,usage:i,isPacked:o}=t;if(null!=a)return;const u=null!=this.activeTimers;let l;u&&(l=ts());let c=t.texShape;if(null==c&&(c=function(e,t=!1){let n=pe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=pe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&pe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map((t,n)=>n>=e.length-2?C(e[n]):e[n])).length&&(e=[2,e[0]])),2!==e.length){const t=j(e);e=t.newShape}let s=P(e),a=null;e.length<=1&&s<=n?a=[1,s]:2===e.length&&e[0]<=n&&e[1]<=n?a=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);const i=null!=a&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(null==a||i)if(t){const t=W$(e);let n=2,r=2;e.length&&([n,r]=j$(e)),s=t*(n/2)*(r/2),a=z(s).map(e=>2*e)}else a=z(s);return a}(n,o),t.texShape=c),null!=s){const e=G$(n);let a,i=c[1],h=c[0];const d=s instanceof Uint8Array||s instanceof Uint8ClampedArray;!o&&d||([i,h]=$$(c[0],c[1])),a=o?new $A(e,d):new EA(e,d);const p=d?[h,i]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=d?S$.PIXELS:S$.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,h,s);const g=[[h,i]],b=!0,y=this.runWebGLProgram(a,[f],r,g,b),x=this.texData.get(y.dataId);t.texShape=x.texShape,t.isPacked=x.isPacked,t.usage=x.usage,pe().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=x.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),u&&(this.uploadWaitMs+=ts()-l)}else{const e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*K(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise(e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}});e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Kd(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw F$(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:s,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:o}=wA(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=s,e.outShapeLocation=a,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:s,width:a,channels:i}=e,o=na().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=o.writeTexture(r,t,n,s,a,i);return na().makeTensorFromDataId(u,t,n,o)}}ZC.nextDataId=0,Vs()&&ua("webgl",()=>new ZC,2);const JC="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class QC{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Li(t,n),this.enableShapeUniforms=_A(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const eO="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class tO{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Li(t,n);const s=this.outputShape.length;this.enableShapeUniforms=_A(s);let a="";if(r)if(0===s||1===P(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a=`\n          ${gA(s)} coords = getOutputCoords();\n        `,1===s)this.enableShapeUniforms?a+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=RC("coords",s);this.enableShapeUniforms?a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}function nO(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const rO={kernelName:Ot,backendName:"webgl",kernelFunc:nO};function sO(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=nO({inputs:{x:r},backend:n}),u=nO({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:u},a}const aO={kernelName:je,backendName:"webgl",kernelFunc:sO},iO="return (a < 0.) ? b * a : a;",oO="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",uO={kernelName:Lt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",Qr(a,"float32")),o=pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new tO(oO,s.shape,i.shape):new QC(iO,s.shape,i.shape),u=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),u}},lO="return (a < 0.) ? b * a : a;",cO="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",hO={kernelName:wn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new tO(cO,r.shape,s.shape):new QC(lO,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}},dO="if (isnan(x)) return x;";function pO({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{const{x:i}=s,o=a,u=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&null!=n){const e=o.texData.get(i.dataId),t=n(e.values,u);return o.makeTensorInfo(i.shape,u,t)}let l;return l=pe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new HC(i.shape,t):new BC(i.shape,e),o.runWebGLProgram(l,[i],u)}}function fO({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{const{a:u,b:l}=i,c=o;if(r&&"complex64"===u.dtype){const t=c.texData.get(u.dataId),n=c.texData.get(l.dataId),[r,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(t=>{const[n,r]=t,s={dataId:n.dataId,dtype:n.dtype,shape:u.shape},a={dataId:r.dataId,dtype:r.dtype,shape:l.shape},i=new QC(e,u.shape,l.shape);return c.runWebGLProgram(i,[s,a],Ns(n.dtype,r.dtype))}),a=sO({inputs:{real:r,imag:s},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(s),a}const h=a||Ns(u.dtype,l.dtype);if(("string"===u.dtype||"string"===l.dtype||c.shouldExecuteOnCPU([u,l]))&&null!=s){const e=c.texData.get(u.dataId).values,t=c.texData.get(l.dataId).values,n="string"===u.dtype?Qp(e):e,r="string"===u.dtype?Qp(t):t,[a,i]=s(u.shape,l.shape,n,r,h),o=c.makeTensorInfo(i,h);return c.texData.get(o.dataId).values=a,o}let d;return d=pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new tO(t,u.shape,l.shape,n):new QC(e,u.shape,l.shape),c.runWebGLProgram(d,[u,l],h)}}function mO(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":WC;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":jC;if("prelu"===e)return t?cO:lO;if("leakyrelu"===e)return t?oO:iO;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class gO{constructor(e,t,n,r=!1,s=!1,a=!1,i=null,o=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=_A(this.outputShape.length);const l=r?e[1]:e[2],c=Math.ceil(l/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");const b=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let y="rc.x",x="rc.x";e[0]<t[0]?y=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${y};\n        int batchB = ${x};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${d});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}class bO{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Li(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const yO="return a * b;";function xO(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=Ns(r.dtype,s.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),a=new bO("return areal * breal - aimag * bimag;",r.shape,s.shape),i=new bO("return areal * bimag + aimag * breal;",r.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],u=n.runWebGLProgram(a,o,"float32"),l=n.runWebGLProgram(i,o,"float32"),c=sO({inputs:{real:u,imag:l},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),c}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),[i,o]=aC(r.shape,s.shape,e.values,t.values,a),u=n.makeTensorInfo(o,a);return n.texData.get(u.dataId).values=i,u}let i;return i=pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new tO(yO,r.shape,s.shape):new QC(yO,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const wO={kernelName:ln,backendName:"webgl",kernelFunc:xO};function vO(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=P(s.shape),u=V(a,o),l=P(u);R(o===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return!c.isPacked||q$(s.shape,u)||null!==c.texture&&q$(c.shape,u)?(i.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype}):function(e,t,n){const r=[W$(e.shape),...j$(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[W$(t),...j$(t)],i=new FC(a,r),o=[r],u=n.runWebGLProgram(i,[s],e.dtype,o,!0);return{dataId:u.dataId,shape:t,dtype:u.dtype}}(s,u,i)}const _O={kernelName:$n,backendName:"webgl",kernelFunc:vO};class kO{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];const i=4*Math.floor(n/4),o=n%4;let u="sumValue += dot(values, ones);";if(null!=t){const e=1/t;u=`sumValue += dot(values * ${L(e)?e.toPrecision(2):e}, ones);`}let l="";s%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class TO{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const l=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===t?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}function SO(e,t,n,r){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=rp(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let a=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:u,outSize:l}=s[i];let c,h;c="mean"===n?0===i?new kO({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l},o):new kO({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l}):new TO({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:l},n),h=a,a=r.runWebGLProgram(c,[a],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return a}class IO{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const r=gA(this.rank),s=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class NO{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=gA(this.rank),s=OC("rc",this.rank),a=new Array(this.rank);for(let e=0;e<t.length;e++)a[t[e]]=s[e];const i=`vec2(${a.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${o}) {\n        result[1] = ${u};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${o}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function EO(e,t,n){const r=pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new NO(e.shape,t):new IO(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function $O(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return function(e,t,n,r){const s=t,a=e.shape.length,i=W(s,e.shape);let o=i;const u=sl(o,a),l=null!=u;let c=e;l&&(c=EO(e,u,r),o=il(o.length,a)),rl("sum",o,a);const[h,d]=tl(c.shape,o);let p=h;n&&(p=nl(h,i));const f=P(d),m=vO({inputs:{x:c},attrs:{shape:[P(e.shape)/f,f]},backend:r}),g=SO(m,Es(e.dtype),"sum",r),b=vO({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),l&&r.disposeIntermediateTensorInfo(c),b}(s,a,i,n)}const AO={kernelName:Yn,backendName:"webgl",kernelFunc:$O};function CO(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,u=new Array(o);for(let e=0;e<u.length;e++)u[e]=s.shape[a[e]];let l;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId).values,t=AC(e,s.shape,s.dtype,a,u);l=i.makeTensorInfo(u,s.dtype),i.texData.get(l.dataId).values=t}else l=EO(s,a,i);return l}const OO={kernelName:yr,backendName:"webgl",kernelFunc:CO};function RO({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:u=null}){const l=e.shape.length,c=t.shape.length,h=n?e.shape[l-2]:e.shape[l-1],d=r?t.shape[c-1]:t.shape[c-2],p=n?e.shape[l-1]:e.shape[l-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),b=P(m),y=P(g),x=Li(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);R(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);const w=n?[b,h,p]:[b,p,h],v=r?[y,f,d]:[y,d,f],_=vO({inputs:{x:e},backend:s,attrs:{shape:w}}),k=vO({inputs:{x:t},backend:s,attrs:{shape:v}}),T=[_,k],S=Math.max(b,y),I=n?_.shape[1]:_.shape[2],N=null!=a,E=null!=i,$="leakyrelu"===u,A=null!=u?mO(u,!0):null;let C;if((1===p||1===f)&&I>1e3&&!1===(N||E||$||null!=A)){let e=_,t=k;n&&(e=CO({inputs:{x:_},backend:s,attrs:{perm:[0,2,1]}}),T.push(e)),r&&(t=CO({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),T.push(t));const a=1===f;let i=e;1!==f&&(i=vO({inputs:{x:e},backend:s,attrs:{shape:[S,I,1]}}),T.push(i));const o=1===f?2:1;let u=t;a&&(u=vO({inputs:{x:t},backend:s,attrs:{shape:[S,1,I]}}),T.push(u));const l=xO({inputs:{a:i,b:u},backend:s});C=$O({inputs:{x:l},backend:s,attrs:{axis:o,keepDims:!0}}),T.push(l)}else{const u=Ns(e.dtype,t.dtype),l=new gO(w,v,[S,p,f],n,r,N,A,E,$),c=[_,k];if(null!=a&&c.push(a),E&&c.push(i),$){const e=s.makeTensorInfo([],"float32",Qr(o,"float32"));c.push(e),T.push(e)}C=s.runWebGLProgram(l,c,u)}const O=vO({inputs:{x:C},backend:s,attrs:{shape:x}});T.push(C);for(const e of T)s.disposeIntermediateTensorInfo(e);return O}const DO={kernelName:Sr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=r;return RO({a:s,b:a,transposeA:u,transposeB:l,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}},FO="return abs(x);",PO={kernelName:ye,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=gC(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let s;return s=pe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new HC(r.shape,FO):new BC(r.shape,FO),n.runWebGLProgram(s,[r],r.dtype)}},MO=pO({opSnippet:UC+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),LO={kernelName:xe,backendName:"webgl",kernelFunc:MO},zO=pO({opSnippet:UC+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),BO={kernelName:we,backendName:"webgl",kernelFunc:zO},UO="return a + b;",VO=fO({opSnippet:UO,packedOpSnippet:UO,supportsComplex:!0,cpuKernelImpl:MA}),WO={kernelName:ve,backendName:"webgl",kernelFunc:VO};class jO{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`float v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class GO{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const HO={kernelName:_e,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,s=n;if(1===s.length)return nO({inputs:{x:s[0]},backend:r});if(s.length>pe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:r}),a=e({inputs:s.slice(t),backend:r});return e({inputs:[n,a],backend:r})}const a=s.map(e=>e.dtype).reduce((e,t)=>Ns(e,t)),i=s.map(e=>e.shape),o=pe().getBool("WEBGL_PACK")?new GO(s[0].shape,i):new jO(s[0].shape,i);return r.runWebGLProgram(o,s,a)}},qO={kernelName:ke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=W(a,s.shape);let l=u;const c=sl(l,o);let h=s;null!=c&&(h=CO({inputs:{x:s},backend:n,attrs:{perm:c}}),l=il(l.length,o)),rl("all",l,o);const[d,p]=tl(h.shape,l),f=vO({inputs:{x:h},backend:n,attrs:{shape:[-1,P(p)]}}),m=SO(f,f.dtype,"all",n);let g;return g=vO(i?{inputs:{x:m},backend:n,attrs:{shape:nl(d,u)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},KO={kernelName:Te,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=W(a,s.shape);let l=u;const c=sl(l,o);let h=s;null!=c&&(h=CO({inputs:{x:s},backend:n,attrs:{perm:c}}),l=il(l.length,o)),rl("any",l,o);const[d,p]=tl(h.shape,l),f=vO({inputs:{x:h},backend:n,attrs:{shape:[-1,P(p)]}}),m=SO(f,f.dtype,"any",n);let g;return g=vO(i?{inputs:{x:m},backend:n,attrs:{shape:nl(d,u)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};class XO{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class YO{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,R(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,u=gA(o),l=RC("coords",o);let c,h;if(1===a){h=o+1;const e=gA(h);c=`\n        ${e} sourceLocR = ${e}(${l.join()}, 0);\n        ++${l[o-1]};\n        ${e} sourceLocG = ${e}(${l.join()}, 0);\n        ++${l[o-2]};\n        ${e} sourceLocA = ${e}(${l.join()}, 0);\n        --${l[o-1]};\n        ${e} sourceLocB = ${e}(${l.join()}, 0);\n        --${l[o-2]};`}else h=o,c=`\n        ${u} sourceLocR = coords;\n        ++${l[o-1]};\n        ${u} sourceLocG = coords;\n        ++${l[o-2]};\n        ${u} sourceLocA = coords;\n        --${l[o-1]};\n        ${u} sourceLocB = coords;\n        --${l[o-2]};`;const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map(e=>"int "+e),m=RC("sourceLocR",h-1).concat("inIdx.r"),g=RC("sourceLocG",h-1).concat("inIdx.g"),b=RC("sourceLocB",h-1).concat("inIdx.b"),y=RC("sourceLocA",h-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",w=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,v=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,_=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${_}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${l[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${l[o-2]} < ${i[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${v};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${v};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function ZO(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];null!=r&&(s=r.shape[0],a=r.shape[1]);const i=rp(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},u=new XO(o,n,null==r),l=[t];null!=r&&l.push(r);const c=e.runWebGLProgram(u,l,"int32");if(1===c.shape[1])return c;const h=ZO(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function JO(e,t,n,r=null){const s=null!=r?r.shape:t.shape,a=rp(s[s.length-1]),i=new YO(s,a,n,null==r),o=null==r?[t]:[t,r],u=e.runWebGLProgram(i,o,"int32");if(u.shape.length===t.shape.length){const r=JO(e,t,n,u);return e.disposeIntermediateTensorInfo(u),r}return u}function QO(e,t,n,r){const s=[n];if(rl("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!pe().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],a=e.texData.get(t.dataId);let i=t;null!==a&&a.isPacked&&(i=e.unpackTensor(t),n.push(i));const[o,u]=tl(i.shape,s),l=P(u),c=vO({inputs:{x:i},backend:e,attrs:{shape:[-1,l]}});n.push(c);const h=ZO(e,c,r);n.push(h);const d=vO({inputs:{x:h},backend:e,attrs:{shape:o}});return n.forEach(t=>e.disposeIntermediateTensorInfo(t)),d}return JO(e,t,r)}const eR={kernelName:Se,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=W(a,s.shape);const o=sl(i,s.shape.length);let u=s;const l=[];null!=o&&(u=CO({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),i=il(i.length,u.shape.length)),rl("argMax",[i[0]],u.shape.length);const c=QO(n,u,i[0],"max");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},tR={kernelName:Ie,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=W(a,s.shape);const o=sl(i,s.shape.length);let u=s;const l=[];null!=o&&(u=CO({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),i=il(i.length,u.shape.length)),rl("argMin",[i[0]],u.shape.length);const c=QO(n,u,i[0],"min");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},nR=pO({opSnippet:UC+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),rR={kernelName:Ne,backendName:"webgl",kernelFunc:nR},sR=pO({opSnippet:UC+"return log(x + sqrt(x * x + 1.0));"}),aR={kernelName:Ee,backendName:"webgl",kernelFunc:sR},iR=pO({opSnippet:UC+"\n  return atan(x);\n"}),oR={kernelName:$e,backendName:"webgl",kernelFunc:iR},uR=fO({opSnippet:JC+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+eO+"\n  return result;\n"}),lR={kernelName:Ce,backendName:"webgl",kernelFunc:uR},cR=pO({opSnippet:UC+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),hR={kernelName:Ae,backendName:"webgl",kernelFunc:cR};class dR{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(f||(b="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?m:g:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let y=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(y="avgValue / max(count, 1.0)");const x=4*Math.floor(a/4),w=a%4,v=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${v}\n          }\n\n          int xC = xCCorner + ${x};\n          if (${1===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${2===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${v}\n          } else if (${3===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${v}\n          }\n        }\n        setOutput(${y});\n      }\n    `}}class pR{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let x="0.0";if(y||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${u});\n        const ivec3 pads = ivec3(${m}, ${g}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(w="avgValue / max(count, 1.0)");const v=4*Math.floor(a/4),_=a%4,k=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${u});\n      const ivec3 pads = ivec3(${m}, ${g}, ${b});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${v}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${k}\n            }\n\n            int xC = xCCorner + ${v};\n            if (${1===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${2===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${3===_}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${k}\n            }\n          }\n        }\n        setOutput(${w});\n      }\n    `}}const fR={kernelName:Oe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Q$(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r;R(tu(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=Go(s.shape,a,i,1,o,u);if(1===l.filterWidth&&1===l.filterHeight&&M(l.inShape,l.outShape))return nO({inputs:{x:s},backend:n});const c=new dR(l,"avg",!1);return n.runWebGLProgram(c,[s],"float32")}},mR={kernelName:De,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:l}=r,c=Ho(s.shape,a,i,[1,1,1],o,u,l),h=new pR(c,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}};class gR{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=o-1-e.padInfo.top,c=u-1-e.padInfo.left,h=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${c});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class bR{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=h-1-e.padInfo.top,m=d-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${u}) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const yR={kernelName:Fe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=r,h=Ho(i.shape,o,u,[1,1,1],l,c),d=new bR(h);return n.runWebGLProgram(d,[s],i.dtype)}},xR={kernelName:Re,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;Q$([s,a],"avgPoolGrad");const{filterSize:o,strides:u,pad:l}=r,c=Go(i.shape,o,u,1,l),h=new gR(c);return n.runWebGLProgram(h,[s],i.dtype)}},wR={kernelName:Pe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return RO({a:s,b:a,transposeA:i,transposeB:o,backend:n})}};class vR{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Li(e,t),Li(e,n);let i="0.0";null!=r&&(Li(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=s&&(Li(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class _R{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Li(e,t),Li(e,n);let i="vec4(0.0)";null!=r&&(Li(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=s&&(Li(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const kR={kernelName:Nt,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:a,offset:i,scale:o}=e;R(s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(null==i||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(null==o||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;null==u&&(u=.001);const l=[r,s,a];let c=null;null!=i&&(c=i.shape,l.push(i));let h=null;null!=o&&(h=o.shape,l.push(o));const d=pe().getBool("WEBGL_PACK_NORMALIZATION")?new _R(r.shape,s.shape,a.shape,c,h,u):new vR(r.shape,s.shape,a.shape,c,h,u);return t.runWebGLProgram(d,l,l[0].dtype)}};class TR{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=gA(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return SR.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map((e,t)=>`sourceLoc.${SR[t]} = start[${t}] + coords.${SR[t]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const SR=["x","y","z","w","u","v"];class IR{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=gA(this.rank),n=RC("coords",this.rank),r=RC("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map((e,t)=>`start[${t}]`).join()});`:e.map((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}}function NR(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,u]=$o(s,a,i);if(mo(s,o,u),0===P(u))return n.makeTensorInfo(u,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=bC(e.values,o,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,t)}const{isPacked:l}=n.texData.get(s.dataId),c=No(s.shape,o,u);if(l||!c){const e=pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new IR(u):new TR(u),t=[o];return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,r){const s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Eo(t,ee(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const u=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,u+1),a}(s,o,u,n)}const ER={kernelName:Wn,backendName:"webgl",kernelFunc:NR},$R={kernelName:Me,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;R(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((e,t)=>e*t),u=ap(s.shape,a,o),l=ip(u.length,a.length),c=op(s.shape,a,o),h=up(i,a.length),d=lp(c,i,a.length),p=[],f=vO({inputs:{x:s},backend:n,attrs:{shape:u}}),m=CO({inputs:{x:f},backend:n,attrs:{perm:l}}),g=vO({inputs:{x:m},backend:n,attrs:{shape:c}}),b=NR({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(e=>n.disposeIntermediateTensorInfo(e)),b}},AR={kernelName:Le,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),u=n.readSync(a.dataId),l=LA(o,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,l)}},CR={kernelName:ze,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=pe().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=pe().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||1===i){const e=n.texData.get(r.dataId).values,t=n.texData.get(s.dataId).values,[a,i]=BA(r.shape,s.shape,e,t,r.dtype),o=n.makeTensorInfo(i,r.dtype);return n.texData.get(o.dataId).values=a,o}let o;return o=a?new tO("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,s.shape,!1):new QC("\n  return float(int(a.r) & int(b.r));\n",r.shape,s.shape),n.runWebGLProgram(o,[r,s],r.dtype)}},OR={kernelName:Be,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=Li(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},RR=fO({opSnippet:"return float(a != b);",cpuKernelImpl:oC,dtype:"bool"}),DR={kernelName:hn,backendName:"webgl",kernelFunc:RR};function FR(e){const{inputs:t,backend:n}=e,{input:r}=t;return nO({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const PR={kernelName:In,backendName:"webgl",kernelFunc:FR},MR={kernelName:Ue,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:s}=t,{x:a}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===a.dtype)return nO({inputs:{x:a},backend:r});const t=Xl(a.shape),n=e({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),s=sO({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===a.dtype){const t=FR({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!q(a.dtype,i)){const e=nO({inputs:{x:a},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([a])){const e=r.texData.get(a.dataId).values,[t,n,s]=UA(e,a.shape,a.dtype,i);return r.makeTensorInfo(t,n,s)}if("int32"===i)return function(e,t){const n=new BC(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(a,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",G("bool",1)),t=RR({inputs:{a,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}},LR="return ceil(x);",zR=pO({opSnippet:LR,packedOpSnippet:LR,cpuKernelImpl:VA}),BR={kernelName:Ve,backendName:"webgl",kernelFunc:zR};class UR{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class VR{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const WR={kernelName:We,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let o;o=pe().getBool("WEBGL_PACK_CLIP")?new VR(s.shape):new UR(s.shape);const u=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,u)}};class jR{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function GR(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const HR={kernelName:Ge,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new jR(r.shape),i=[GR(r,s.complexTensorInfos.real),GR(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}};class qR{constructor(e){this.outputShape=[],this.outputShape=Yd(e,1),this.variableNames=e.map((e,t)=>`T${t}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}const r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class KR{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Yd(e,t);const n=this.outputShape,r=n.length,s=gA(r),a=RC("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((e,t)=>`T${t}`);const o=new Array(e.length-1);o[0]=e[0][t];for(let n=1;n<o.length;n++)o[n]=o[n-1]+e[n][t];const u=i[t],l=i.slice(-2),c=i.join();let h=`if (${u} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${l.join()}));\n        }`;for(let e=1;e<o.length;e++){const t=o[e-1];h+=`\n        if (${u} < ${o[e]}  && ${u} >= ${o[e-1]}) {\n          return getChannel(\n            getT${e}(${XR(i,u,t)}),\n            vec2(${XR(l,u,t)}));\n        }`}const d=o.length,p=o[o.length-1];h+=`\n        return getChannel(\n          getT${d}(${XR(i,u,p)}),\n          vec2(${XR(l,u,p)}));`,this.userCode=`\n      float getValue(${i.map(e=>"int "+e)}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function XR(e,t,n){const r=e.indexOf(t);return e.map((e,t)=>t===r?`${e} - ${n}`:e).join()}function YR(e){const{inputs:t,backend:n}=e,{input:r}=t;return nO({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const ZR={kernelName:Dt,backendName:"webgl",kernelFunc:YR};function JR(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map(e=>FR({inputs:{input:e},backend:n})),s=e.map(e=>YR({inputs:{input:e},backend:n})),a=JR(r,t,n),i=JR(s,t,n),o=sO({inputs:{real:a,imag:i},backend:n});return r.forEach(e=>n.disposeIntermediateTensorInfo(e)),s.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),o}let s=n.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const s=e.map(e=>{const r=P(e.shape.slice(t));return vO({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})}),a=s.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),i=Yd(s.map(e=>e.shape),1),o=1===s[0].shape[0],u=WA(a,i,r,o),l=Yd(e.map(e=>e.shape),t),c=n.makeTensorInfo(l,r,u);return s.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}const a=e.filter(e=>P(e.shape)>0),i=pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(1===a.length){const t=i?new BC(e[0].shape,GC):new HC(e[0].shape,GC);return n.runWebGLProgram(t,e,r)}const o=pe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const e=[];for(let r=0;r<a.length;r+=o){const s=a.slice(r,r+o);e.push(JR(s,t,n))}const r=JR(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){const e=new KR(a.map(e=>e.shape),t);return n.runWebGLProgram(e,a,r)}const{tensors2D:u,outShape:l}=function(e,t,n){const r=Yd(e.map(e=>e.shape),t);return{tensors2D:e.map(e=>vO({inputs:{x:e},attrs:{shape:[-1,P(e.shape.slice(t))]},backend:n})),outShape:r}}(a,t,n),c=new qR(u.map(e=>e.shape)),h=n.runWebGLProgram(c,u,r);u.forEach(e=>n.disposeIntermediateTensorInfo(e));const d=vO({inputs:{x:h},attrs:{shape:l},backend:n});return n.disposeIntermediateTensorInfo(h),d}function QR(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=W(s,t[0].shape)[0];Xd(t.map(e=>e.shape),a);const i=Yd(t.map(e=>e.shape),a);if(0===P(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter(e=>P(e.shape)>0);return 1===o.length?nO({inputs:{x:o[0]},backend:n}):JR(o,a,n)}const eD={kernelName:He,backendName:"webgl",kernelFunc:QR};class tD{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,b=m?2:3,y=m?3:1;let x="",w="";n&&(x=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,w="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${o}, ${u});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${w}\n        setOutput(result);\n      }\n    `}}class nD{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${a}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class rD{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_A(this.outputShape.length);const a=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,u=e.filterHeight,l=e.filterWidth,c=l;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<l;e++)h+=`\n           vec4 xTexelC${2*e};\n           int xTexelC${2*e}Ready;\n           vec4 xTexelC${2*e+1};\n           int xTexelC${2*e+1}Ready;\n           vec4 xC${e};`;h+=`\n     for (int r = 0; r < ${u}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let e=0;e<l;e++)h+=`\n           xTexelC${2*e} = vec4(0.0);\n           xTexelC${2*e}Ready = 0;\n           xTexelC${2*e+1} = vec4(0.0);\n           xTexelC${2*e+1}Ready = 0;\n           xC${e} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let t=0;t<(c+1)/2;t++){const n=2*t;if(h+=`\n           xC = xCCorner + ${n*o};\n           `,1===i){if(n<l&&(a%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n               `,h+=1===o&&n>0?`\n                 xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                   } else {\n                     xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xC${n} = xTexelC${n};\n                 `,n+1<l)){const e=a%2==0?C(o):o;o%2==0&&a%2==1||o%2!=0&&a%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                     xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${n+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${n+1}Ready = 1;\n                   }\n                   `,h+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);\n                     } else {\n                      xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);\n                     }\n                     `:`\n                     xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                     `):h+=1===e?`\n                     xC${n+1} = xTexelC${n};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                       xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${n+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${n+1}Ready = 1;\n                     }\n\n                     xC${n+1} = xTexelC${n+1};\n                     `}}else n<l&&(a%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n               `,n+1<l&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(\n                   xTexelC${n}.xy, xTexelC${n+1}.xy);\n               `,n+1<l&&(h+=`\n                   xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                 `)));n<l&&(h+=`\n             wTexel = getW(r, ${n}, d1, d2);\n             dotProd += xC${n}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${n}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,n+1<l&&(h+=`\n               wTexel = getW(r, ${n+1}, d1, d2);\n               dotProd += xC${n+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${n+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:s?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${d}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}}class sD{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=_A(this.outputShape.length);const{dataFormat:n}=t,r=tA(),s="channelsLast"===n,a=s?1:2,i=s?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)u+=`\n          blockIndex = rc.z + ${t};\n          pos = rc.y + ${e};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${u}\n\n        ${r.output} = result;\n      }\n    `}}function aD(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function iD({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const u=e.shape,l=r.texData.get(e.dataId),c=n.inChannels,h=u[0]*u[1]*u[2],d=n.outChannels,p="channelsLast"===n.dataFormat,f=!1;let m;const g=[];if(null!=a){const e=aD(a.shape,p);null!=e&&(a=vO({inputs:{x:a},backend:r,attrs:{shape:e}}),g.push(a))}if(null!=s){const e=aD(s.shape,p);null!=e&&(s=vO({inputs:{x:s},backend:r,attrs:{shape:e}}),g.push(s))}if((1!==h&&1!==d||!(c>1e3))&&l.isPacked&&p&&null!=l.texture&&u[2]%2!=0&&M(l.shape.slice(-3),u.slice(-3))){const c=u[0]*u[1]*(u[2]+1),h={dataId:e.dataId,shape:[1,c,n.inChannels],dtype:e.dtype},d=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,R(q$(l.shape,h.shape),()=>`packed reshape ${l.shape} to ${h.shape} isn't free`);const p=vO({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});g.push(p);const b=RO({a:h,b:p,backend:r,transposeA:!1,transposeB:f,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),y=r.texData.get(b.dataId);R(y.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=d,y.shape=n.outShape,m=nO({inputs:{x:b},backend:r}),m.shape=n.outShape,g.push(b)}else{const u=n.outHeight*n.outWidth,l=vO({inputs:{x:e},backend:r,attrs:{shape:p?[n.batchSize,u,n.inChannels]:[n.batchSize,n.inChannels,u]}}),c=vO({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),h=RO({a:p?l:c,b:p?c:l,transposeA:!p,transposeB:f,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});m=vO({inputs:{x:h},backend:r,attrs:{shape:n.outShape}}),g.push(l),g.push(c),g.push(h)}for(const e of g)r.disposeIntermediateTensorInfo(e);return m}function oD({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:u,filterHeight:l,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=n,f="channelsLast"===p,m=u*l*c,g=d*h,b=[n.batchSize,m,g],y=[];if(null!=a){const e=aD(a.shape,f);null!=e&&(a=vO({inputs:{x:a},backend:r,attrs:{shape:e}}),y.push(a))}if(null!=s){const e=aD(s.shape,f);null!=e&&(s=vO({inputs:{x:s},backend:r,attrs:{shape:e}}),y.push(s))}const x=vO({inputs:{x:t},backend:r,attrs:{shape:[1,m,P(t.shape)/m]}});y.push(x);const w=new sD(b,n),v=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],_=r.runWebGLProgram(w,[e],"float32",v),k=vO({inputs:{x:_},backend:r,attrs:{shape:b}});y.push(_),y.push(k);const T=null!=s,S=null!=a,I="leakyrelu"===o,N=o?mO(o,!0):null,E=new gO(f?k.shape:x.shape,f?x.shape:k.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],!0,!1,T,N,S,I),$=f?[k,x]:[x,k];if(s&&$.push(s),S&&$.push(a),I){const e=r.makeTensorInfo([],"float32",Qr(i,"float32"));$.push(e),y.push(e)}const A=r.runWebGLProgram(E,$,"float32"),C=vO({inputs:{x:A},backend:r,attrs:{shape:n.outShape}});y.push(A);for(const e of y)r.disposeIntermediateTensorInfo(e);return C}const uD={kernelName:qe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:l,dimRoundingMode:c}=r,h=ru(u),d=qo(s.shape,a.shape,i,l,o,c,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&pe().getBool("WEBGL_EXP_CONV")){const e=new rD(d),t=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(e,[s,a],"float32",t)}else if(pe().getBool("WEBGL_CONV_IM2COL"))p=oD({x:s,filter:a,convInfo:d,backend:n});else{const e=new tD(d);p=n.runWebGLProgram(e,[s,a],"float32")}else p=iD({x:s,filter:a,convInfo:d,backend:n});const f=vO({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class lD{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${a?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class cD{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,u=a?1:2,l=a?2:3,c=a?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class hD{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${s};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${a};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class dD{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,u=n-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${u}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${s}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const pD={kernelName:Ke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:l,filterShape:c}=r,h=ru(u),d=qo(s.shape,c,i,1,o,l,!1,h),p=new lD(d);return n.runWebGLProgram(p,[s,a],"float32")}};class fD{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=_A(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const mD={kernelName:Xe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:u,dataFormat:l,dimRoundingMode:c}=r,h=ru(l),d=qo(i,a.shape,o,1,u,c,!1,h);if(pe().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const e=[[d.strideHeight,d.strideWidth]],t=new fD(d);return n.runWebGLProgram(t,[s,a],"float32",e)}{const e=new cD(d);return n.runWebGLProgram(e,[s,a],"float32")}}},gD={kernelName:Ye,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r,l=Ko(s.shape,a.shape,i,u,o),c=new nD(l);return n.runWebGLProgram(c,[s,a],"float32")}},bD={kernelName:Ze,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:u}=r,l=Ko(s.shape,u,i,1,o),c=new hD(l);return n.runWebGLProgram(c,[s,a],"float32")}},yD={kernelName:Je,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:u}=r,l=Ko(u,a.shape,o,1,i),c=new dD(l);return n.runWebGLProgram(c,[s,a],"float32")}},xD=pO({opSnippet:dO+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${eO}\n  return result;\n`}),wD={kernelName:Qe,backendName:"webgl",kernelFunc:xD},vD=pO({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),_D={kernelName:et,backendName:"webgl",kernelFunc:vD};class kD{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,o,u]=e,[l]=t,[c,h]=n;this.outputShape=[l,c,h,u];const d="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,b]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[y,x,w]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${x};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const TD={kernelName:rt,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:l}=r,c=new kD(s.shape,a.shape,o,u,l);return n.runWebGLProgram(c,[s,a,i],"float32")}};var SD;!function(e){e.Prod="*",e.Sum="+"}(SD||(SD={}));class ID{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,a=this.op===SD.Prod?"1.0":"0.0",i=n?a:`getX(${ND(s,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let u="",l="";n?(u=r?"end != "+(o-1):"end != 0",l=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${o}`:"end >= pow2",l=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${gA(s)} coords = getOutputCoords();\n        int end = ${ED(s,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${u}) {\n          int idx = ${l};\n          ${ED(s,"coords",this.op)} = idx;\n          val ${this.op}= getX(${ND(s,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function ND(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function ED(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function $D(e,t,n,r,s,a){const i=t.shape.length,o=sl([r],i);let u=t;null!=o&&(u=CO({inputs:{x:t},backend:n,attrs:{perm:o}}));const l=il(1,i)[0];if(l!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=u.shape[l];let h=nO({inputs:{x:u},backend:n});for(let t=0;t<=Math.ceil(Math.log2(c))-1;t++){const r=new ID(e,u.shape,!1,a),s=[[t]],i=h;h=n.runWebGLProgram(r,[h],h.dtype,s),n.disposeIntermediateTensorInfo(i)}if(s){const t=new ID(e,u.shape,s,a),r=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){const e=CO({inputs:{x:h},backend:n,attrs:{perm:al(o)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(u),e}return h}const AD={kernelName:tt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return $D(SD.Prod,s,n,a,i,o)}},CD={kernelName:nt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return $D(SD.Sum,s,n,a,i,o)}},OD={kernelName:st,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(a.dataId),r=LA(e,t,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(a),r=zA(e,t,i,o);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class RD{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const DD={kernelName:at,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],u=("NHWC"===i?s.shape[1]:s.shape[2])*a,l=("NHWC"===i?s.shape[2]:s.shape[3])*a,c=("NHWC"===i?s.shape[3]:s.shape[1])/(a*a),h=new RD("NHWC"===i?[o,u,l,c]:[o,c,u,l],a,i);return n.runWebGLProgram(h,[s],s.dtype)}};class FD{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_A(this.outputShape.length);const a=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let u="",l="";n&&(u=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,l="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${a}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${l}\n        setOutput(result);\n      }\n    `}}class PD{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_A(this.outputShape.length);const a=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,u=e.dilationWidth,l=e.filterHeight,c=e.filterWidth,h=c;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<c;e++)d+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;d+=`\n    for (int r = 0; r < ${l}; r++) {\n      `;for(let e=0;e<c;e++)d+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(h+1)/2;e++){const t=2*e;if(d+=`\n          xC = xCCorner + ${t*u};\n          `,1===o){if(t<c&&(i%2==1?(d+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,d+=1===u&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):d+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<c)){const e=i%2==0?C(u):u;u%2==0&&i%2==1||u%2!=0&&i%2!=1?(d+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,d+=u>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                    } else {\n                     xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                    }\n                    `:`\n                    xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                    `):d+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<c&&(i%2==1?(d+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<c&&(d+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(d+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<c&&(d+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<c&&(d+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<c&&(d+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${a};\n        int q = d2 - d1 * ${a};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${d}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}const MD={kernelName:it,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:l}=r;let c=u;null==c&&(c=[1,1]),R(tu(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=qo(s.shape,a.shape,i,c,o,l,!0);let d;d=pe().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new PD(h):new FD(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[s,a],"float32",p)}};class LD{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${a} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class zD{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const BD={kernelName:ot,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,filterShape:c}=r,h=qo(s.shape,c,i,o,u,l,!0),d=new LD(h);return n.runWebGLProgram(d,[s,a],"float32")}},UD={kernelName:ut,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,inputShape:c}=r,h=qo(c,a.shape,i,o,u,l,!0),d=new zD(h);return n.runWebGLProgram(d,[s,a],"float32")}};class VD{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const WD={kernelName:lt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=P(r.shape),i=vO({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new VD(a),u=n.runWebGLProgram(o,[i],i.dtype),l=vO({inputs:{x:u},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}};class jD{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:u,dilationWidth:l}=e,{top:c,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${a});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const GD={kernelName:ct,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r,l=jo(s.shape,a.shape,i,o,"NHWC",u);let c;const h=new jD(l);c=n.runWebGLProgram(h,[s,a],"float32");const d=vO({inputs:{x:c},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(c),d}},HD={kernelName:ft,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:u}=Cp(s,a.length);Rp(i.length,u,a);const{path:l,steps:c}=Dp(o,u),h=c.length;let d=null,p=i.length;const f=[];for(let e=0;e<h;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:r}=Op(p,u[t]);let s;Fp(e)?s=a[t]:(s=CO({inputs:{x:a[t]},backend:n,attrs:{perm:e}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);M(s.shape,i)||(s=vO({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=xO({inputs:{a:s,b:d},backend:n}),f.push(d))}e<h-1&&(l[e]>=0&&(d=$O({inputs:{x:d},backend:n,attrs:{axis:l[e]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const e of f)e!==d&&n.disposeIntermediateTensorInfo(e);return d}},qD=pO({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),KD={kernelName:mt,backendName:"webgl",kernelFunc:qD},XD={kernelName:gt,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new tO("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new QC("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)}},YD=fO({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:jA}),ZD={kernelName:yt,backendName:"webgl",kernelFunc:YD},JD=pO({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${pp};\n  float a1 = ${fp};\n  float a2 = ${mp};\n  float a3 = ${gp};\n  float a4 = ${bp};\n  float a5 = ${yp};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),QD={kernelName:bt,backendName:"webgl",kernelFunc:JD},eF=pO({opSnippet:dO+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:GA,dtype:"float32"}),tF={kernelName:xt,backendName:"webgl",kernelFunc:eF};function nF(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let u=s;return s<0&&(R(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),o.splice(u,0,1),vO({inputs:{x:a},backend:r,attrs:{shape:o}})}const rF={kernelName:wt,backendName:"webgl",kernelFunc:nF},sF="return exp(x) - 1.0;",aF=pO({opSnippet:sF,packedOpSnippet:sF,cpuKernelImpl:HA}),iF={kernelName:vt,backendName:"webgl",kernelFunc:aF};class oF{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function uF(e,t,n){const r=n.texData.get(e.dataId),s=P(e.shape),a=e.shape[e.shape.length-1],i=vO({inputs:{x:e},backend:n,attrs:{shape:[s/a,a]}}),o=i.shape,u=new oF("real",o,t),l=new oF("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],h=n.runWebGLProgram(u,c,"float32"),d=n.runWebGLProgram(l,c,"float32"),p=sO({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=vO({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const lF={kernelName:_t,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return uF(r,!1,n)}};class cF{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function hF(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||Z(s),"string"===a){const e=H(a,P(r));return e.fill(s),t.makeTensorInfo(r,a,e)}{const e=new cF(r,s),n=[[s]];return t.runWebGLProgram(e,[],a,n)}}const dF={kernelName:kt,backendName:"webgl",kernelFunc:hF};class pF{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const fF={kernelName:Tt,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new pF(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},mF="return floor(x);",gF=pO({opSnippet:mF,packedOpSnippet:mF,cpuKernelImpl:qA}),bF={kernelName:St,backendName:"webgl",kernelFunc:gF},yF=fO({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),xF={kernelName:It,backendName:"webgl",kernelFunc:yF};class wF{constructor(e){this.variableNames=["A"];const t=tA(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class vF{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=tA(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const _F={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[u,l]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[l,u],h=[l,u,a];if(o||i){const e=pe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=kF&&e===TF||(TF=e,kF=document.createElement("canvas").getContext("2d",{willReadFrequently:TF})),kF.canvas.width=u,kF.canvas.height=l,kF.drawImage(s,0,0,u,l),s=kF.canvas}const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=S$.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const p=pe().getBool("WEBGL_PACK")?new vF(h):new wF(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let kF,TF=pe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const SF={kernelName:Ir,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=ru(c),g=qo(s.shape,a.shape,u,h,l,d,!1,m);let b;const y=[],x=null!=i,w=null!=o,v="leakyrelu"===p,_=()=>{const e=[s,a],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=vO({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return y.push(t),t}return e};if(x&&e.push(t(i,c)),w&&e.push(t(o,c)),v){const t=n.makeTensorInfo([],"float32",Qr(f,"float32"));e.push(t),y.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&pe().getBool("WEBGL_EXP_CONV")){const e=p?mO(p,!0):null,t=new rD(g,x,e,w,v),r=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],s=_();b=n.runWebGLProgram(t,s,"float32",r)}else if(pe().getBool("WEBGL_CONV_IM2COL"))b=oD({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=p?mO(p,!1):null,t=new tD(g,x,e,w,v),r=_();b=n.runWebGLProgram(t,r,"float32")}else b=iD({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const k=vO({inputs:{x:b},backend:n,attrs:{shape:g.outShape}});return y.push(b),y.forEach(e=>n.disposeIntermediateTensorInfo(e)),k}},IF={kernelName:Nr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),R(tu(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);const g=qo(s.shape,a.shape,u,m,l,h,!0),b=pe().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,y=d?mO(d,b):null,x=[s,a],w=null!=i,v=null!=o,_="leakyrelu"===d;if(w&&x.push(i),v&&x.push(o),_){const e=n.makeTensorInfo([],"float32",Qr(p,"float32"));x.push(e),f.push(e)}let k;k=b?new PD(g,w,y,v,_):new FD(g,w,y,v,_);const T=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],S=n.runWebGLProgram(k,x,"float32",T);return f.forEach(e=>n.disposeIntermediateTensorInfo(e)),S}};class NF{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const s=gA(n.length);let a="\n    int index;";for(let e=0;e<this.sliceDim;e++)a+=`\n          index = round(getIndices(coords[0], ${e}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[e]};\n          flattenIndex += index * ${this.strides[e]};`;this.userCode=`\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${a}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const EF={kernelName:$t,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=P(r.shape),[u,l,c,h]=cp(r,s),d=vO({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),p=vO({inputs:{x:r},backend:n,attrs:{shape:[P(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(r),a=KA(e,t,r.dtype,l,i,c,h,r.shape,o);return n.makeTensorInfo(u,r.dtype,a.values)}const f=new NF(i,h,[l,c],r.shape),m=n.runWebGLProgram(f,[p,d],p.dtype),g=vO({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class $F{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=gA(this.rank),r=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function AF(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,u=W(i,s.shape)[0];if(pe().get("DEBUG")){const e=n.readSync(a.dataId),t=s.shape[u];for(let n=0;n<e.length;++n){const r=e[n];R(r<=t-1&&r>=0,()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`)}}const l=Jp(s,a,u,o),c=P(a.shape),h=[],d=vO({inputs:{x:s},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=vO({inputs:{x:a},backend:n,attrs:{shape:[l.batchSize,c/l.batchSize]}});h.push(d),h.push(p);const f=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([s,a])||"string"===s.dtype){const e=n.bufferSync(p),t=n.bufferSync(d),r=XA(t,e,f);return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(l.outputShape,r.dtype,r.values)}const m=new $F(d.shape,f),g=n.runWebGLProgram(m,[d,p],d.dtype);h.push(g);const b=vO({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),b}const CF={kernelName:Et,backendName:"webgl",kernelFunc:AF},OF=fO({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:YA,dtype:"bool"}),RF={kernelName:At,backendName:"webgl",kernelFunc:OF},DF=fO({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:ZA}),FF={kernelName:Ct,backendName:"webgl",kernelFunc:DF},PF={kernelName:Rt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return uF(r,!0,n)}},MF=pO({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),LF={kernelName:Ft,backendName:"webgl",kernelFunc:MF},zF=pO({opSnippet:"return float(isinf(x));",dtype:"bool"}),BF={kernelName:Pt,backendName:"webgl",kernelFunc:zF},UF=pO({opSnippet:"return float(isnan(x));",dtype:"bool"}),VF={kernelName:Mt,backendName:"webgl",kernelFunc:UF},WF=fO({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:JA,dtype:"bool"}),jF={kernelName:zt,backendName:"webgl",kernelFunc:WF},GF=fO({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:QA,dtype:"bool"}),HF={kernelName:Bt,backendName:"webgl",kernelFunc:GF},qF={kernelName:Ut,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=eC(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},KF=pO({opSnippet:dO+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:tC}),XF={kernelName:Vt,backendName:"webgl",kernelFunc:KF},YF=pO({opSnippet:dO+"\n  return log(1.0 + x);\n"}),ZF={kernelName:Wt,backendName:"webgl",kernelFunc:YF},JF=fO({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),QF={kernelName:jt,backendName:"webgl",kernelFunc:JF},eP=pO({opSnippet:"return float(!(x >= 1.0));"}),tP={kernelName:Gt,backendName:"webgl",kernelFunc:eP},nP=fO({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),rP={kernelName:Ht,backendName:"webgl",kernelFunc:nP};class sP{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;let o;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${u})`:1===s?`1.0/(${u})`:`exp(log(${u}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class aP{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;let o;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${u})`:1===s?`1.0/(${u})`:`exp(log(${u}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const iP={kernelName:qt,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=r,l=pe().getBool("WEBGL_PACK_NORMALIZATION")?new aP(s.shape,a,i,o,u):new sP(s.shape,a,i,o,u);return n.runWebGLProgram(l,[s],s.dtype)}};class oP{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const uP={kernelName:Kt,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:l,beta:c}=r,h=new oP(s.shape,o,u,l,c);return n.runWebGLProgram(h,[s,a,i],s.dtype)}};function lP(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,u=W(a,s.shape);let l=u;const c=sl(l,o),h=null!=c,d=n.shouldExecuteOnCPU([s]);let p=s;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let e=0;e<t.length;e++)t[e]=s.shape[c[e]];const r=AC(e,s.shape,s.dtype,c,t);p=n.makeTensorInfo(t,s.dtype),n.texData.get(p.dataId).values=r}else p=EO(s,c,n);l=il(l.length,o)}rl("max",l,o);const[f,m]=tl(p.shape,l);let g,b=f;if(i&&(b=nl(f,u)),d){const e=n.texData.get(p.dataId).values,t=nC(e,P(m),b,s.dtype);g=n.makeTensorInfo(b,s.dtype),n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const s=P(t),a=vO({inputs:{x:e},attrs:{shape:[P(e.shape)/s,s]},backend:r}),i=SO(a,e.dtype,"max",r),o=vO({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(p,m,b,n);return h&&n.disposeIntermediateTensorInfo(p),g}const cP={kernelName:Xt,backendName:"webgl",kernelFunc:lP},hP=fO({opSnippet:JC+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+eO+"\n  return result;\n",cpuKernelImpl:rC}),dP={kernelName:Yt,backendName:"webgl",kernelFunc:hP},pP={kernelName:Zt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Q$(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r;R(tu(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=Go(s.shape,a,i,1,o,u);if(1===l.filterWidth&&1===l.filterHeight&&M(l.inShape,l.outShape))return nO({inputs:{x:s},backend:n});const c=new dR(l,"max",!1);return n.runWebGLProgram(c,[s],s.dtype)}},fP={kernelName:Qt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:u,dimRoundingMode:l}=r,c=Ho(s.shape,a,i,[1,1,1],o,l,u),h=new pR(c,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}};class mP{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=a-1-e.padInfo.left,u=s*a-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class gP{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=o-1-e.padInfo.front,h=u-1-e.padInfo.top,d=l-1-e.padInfo.left,p=o*u*l-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${h}, ${d});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${l} +\n                  wR * ${l} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const bP={kernelName:en,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:u,pad:l,dimRoundingMode:c}=r,h=Ho(i.shape,o,u,[1,1,1],l,c),d=new pR(h,"max",!0),p=n.runWebGLProgram(d,[i],i.dtype),f=new gP(h),m=n.runWebGLProgram(f,[s,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}},yP={kernelName:Jt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;Q$([a,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=r,d=Go(o.shape,u,l,1,c,h),p=new dR(d,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new mP(d),g=n.runWebGLProgram(m,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}},xP={kernelName:tn,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,u=n;R(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const l=[1,1];R(tu(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);const c=Go(r.shape,s,a,l,i),[h,d]=function(e,t,n,r){let s=new dR(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");return s=new dR(n,"max",!0,!0,t),[a,r.runWebGLProgram(s,[e],"float32")]}(r,o,c,u);return[h,d]}},wP={kernelName:nn,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:a}=t,i=n,o=r.shape.length,u=W(a,r.shape);let l=u;const c=sl(l,o),h=null!=c,d=i.shouldExecuteOnCPU([r]),p=[];let f=r;if(h){if(d){const e=i.texData.get(f.dataId).values,t=new Array(o);for(let e=0;e<t.length;e++)t[e]=r.shape[c[e]];const n=AC(e,r.shape,r.dtype,c,t);f=i.makeTensorInfo(t,r.dtype),i.texData.get(f.dataId).values=n}else f=EO(r,c,i);p.push(f),l=il(l.length,o)}rl("sum",l,o);const[m,g]=tl(f.shape,l);let b=m;s&&(b=nl(m,u));const y=function(e,t,n,r){const s=P(t),a=vO({inputs:{x:e},attrs:{shape:[P(e.shape)/s,s]},backend:r}),i=SO(a,"float32","mean",r),o=vO({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(f,g,b,i);for(const e of p)i.disposeIntermediateTensorInfo(e);return y}},vP={kernelName:rn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=W(a,s.shape);let l=u;const c=sl(l,o);let h=s;null!=c&&(h=CO({inputs:{x:s},backend:n,attrs:{perm:c}}),l=il(l.length,s.shape.length)),rl("min",l,o);const[d,p]=tl(h.shape,l),f=vO({inputs:{x:h},backend:n,attrs:{shape:[-1,P(p)]}}),m=SO(f,f.dtype,"min",n);let g;return g=vO(i?{inputs:{x:m},backend:n,attrs:{shape:nl(d,u)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},_P=fO({opSnippet:JC+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+eO+"\n  return result;\n",cpuKernelImpl:sC}),kP={kernelName:sn,backendName:"webgl",kernelFunc:_P};class TP{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=gA(r),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class SP{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=gA(r),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=RC("rc",r),u=RC("source",r),l=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===r){const e=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n      `}else{const e=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${u.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${u.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const IP={kernelName:an,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:a}=n,i=pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SP(r.shape,s,a):new TP(r.shape,s,a);return t.runWebGLProgram(i,[r],r.dtype)}},NP=fO({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+eO+"\n  return result;\n"}),EP={kernelName:on,backendName:"webgl",kernelFunc:NP};class $P{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const AP=fO({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),CP={kernelName:pt,backendName:"webgl",kernelFunc:AP},OP="return a - b;",RP=fO({opSnippet:OP,packedOpSnippet:OP,supportsComplex:!0,cpuKernelImpl:NC}),DP={kernelName:dr,backendName:"webgl",kernelFunc:RP};function FP(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=W([a],s.shape),o=lP({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),u=nl(o.shape,i),l=vO({inputs:{x:o},backend:n,attrs:{shape:u}}),c=RP({inputs:{a:s,b:l},backend:n}),h=eF({inputs:{x:c},backend:n}),d=$O({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),p=vO({inputs:{x:d},backend:n,attrs:{shape:u}}),f=AP({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const PP={kernelName:Qn,backendName:"webgl",kernelFunc:FP},MP={kernelName:un,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,u=o?s:FP({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),l=u.shape[0],c=u.shape[1],h=new $P(l,c,a),d=[[i]],p=n.runWebGLProgram(h,[u],"int32",d);return o||n.disposeIntermediateTensorInfo(u),p}},LP=UC+"\n  return -x;\n",zP={kernelName:cn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,s]=iC(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}let s;return s=pe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new HC(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new BC(r.shape,LP),n.runWebGLProgram(s,[r],r.dtype)}},BP=od,UP={kernelName:dn,backendName:"webgl",kernelFunc:function(e){Er("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=r,l=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:h}=BP(l,c,i,o,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},VP=ud,WP={kernelName:pn,backendName:"webgl",kernelFunc:function(e){Er("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:l}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),{selectedIndices:d,validOutputs:p}=VP(c,h,i,o,u,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},jP=ld,GP={kernelName:fn,backendName:"webgl",kernelFunc:function(e){Er("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),d=i,p=o,f=u,m=l,{selectedIndices:g,selectedScores:b}=jP(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class HP{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const qP={kernelName:gn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:u}=r,l=P(s.shape),c=new HP(l,i,o,u),h=vO({inputs:{x:s},backend:n,attrs:{shape:[l]}}),d=n.runWebGLProgram(c,[h],a);n.disposeIntermediateTensorInfo(h);const p=vO({inputs:{x:d},backend:n,attrs:{shape:[...s.shape,i]}});return n.disposeIntermediateTensorInfo(d),p}};function KP(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=FR({inputs:{input:r},backend:n}),t=KP({inputs:{x:e},backend:n}),s=YR({inputs:{input:r},backend:n}),a=KP({inputs:{x:s},backend:n}),i=sO({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return hF({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const XP={kernelName:_r,backendName:"webgl",kernelFunc:KP},YP={kernelName:mn,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=FR({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=YR({inputs:{input:s},backend:r}),i=KP({inputs:{x:a},backend:r}),o=sO({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return hF({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}},ZP={kernelName:bn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return nF({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach(e=>{D(a,e.shape,"All tensors passed to stack must have matching shapes"),R(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],u=QR({inputs:t.map(e=>{const t=nF({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t}),backend:n,attrs:{axis:s}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}};class JP{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=gA(r),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class QP{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=gA(r),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=RC("rc",r),u=RC("source",r),l=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,h=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${l}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${l}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let e=0,t=1===r?2:4;e<t;e++)p+=`\n        ${h[e]}\n        if (${d}) {\n          result[${e}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${e}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const eM=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(0===P(s.shape)){const e=a.map((e,t)=>e[0]+s.shape[t]+e[1]);return hF({backend:n,attrs:{shape:e,value:i,dtype:s.dtype}})}const o=pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new QP(s.shape,a,i):new JP(s.shape,a,i),u=[[i]];return n.runWebGLProgram(o,[s],s.dtype,u)},tM={kernelName:yn,backendName:"webgl",kernelFunc:eM},nM=fO({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+eO+"\n  return result;\n"}),rM={kernelName:xn,backendName:"webgl",kernelFunc:nM},sM={kernelName:vn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,u=[],l=W(a,s.shape);let c=l;const h=sl(c,o);let d,p=s;if(null!=h&&(p=CO({inputs:{x:s},backend:n,attrs:{perm:h}}),c=il(c.length,o),u.push(p)),rl("prod",c,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:s}=uC(p.shape,p.dtype,e,c);d=n.makeTensorInfo(r,s,t)}else{const[e,t]=tl(p.shape,c),r=P(t),a=vO({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=SO(a,Es(s.dtype),"prod",n);d=vO({inputs:{x:i},backend:n,attrs:{shape:e}}),u.push(a),u.push(i)}if(i){u.push(d);const e=nl(d.shape,l);d=vO({inputs:{x:d},backend:n,attrs:{shape:e}})}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}},aM={kernelName:_n,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,u=s.map(e=>n.readSync(e.dataId)),l=s.map(e=>e.shape),c=n.readSync(a.dataId),h=n.readSync(i.dataId),[d,p,f]=lC(u,l,c,a.shape,a.dtype,h,i.shape,o),m=d.map(e=>n.makeTensorInfo([e.length],"int32",e)),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}},iM={kernelName:kn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),u=n.readSync(a.dataId),[l,c]=cC(i,r.shape,r.dtype,o,s.shape,u,a.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([c.length],r.dtype,c)]}},oM={kernelName:Tn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=r,l=n.readSync(s.dataId),c=n.readSync(a.dataId),h=n.readSync(i.dataId),d=o.map(e=>n.readSync(e.dataId)),p=o.map(e=>e.shape),[f,m]=hC(l,s.shape,c,a.shape,a.dtype,h,i.shape,d,p,u);return n.makeTensorInfo(f,a.dtype,m)}},uM=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=dC(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},lM={kernelName:Sn,backendName:"webgl",kernelFunc:uM},cM=pO({opSnippet:"return 1.0 / x;"}),hM={kernelName:Nn,backendName:"webgl",kernelFunc:cM},dM=pO({opSnippet:UC+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),pM={kernelName:En,backendName:"webgl",kernelFunc:dM},fM=pO({opSnippet:UC+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),mM={kernelName:Dn,backendName:"webgl",kernelFunc:fM};class gM{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,u]=e;this.outputShape=[a,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class bM{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,u]=e;this.outputShape=[a,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const yM={kernelName:On,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,l]=o,c=pe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new bM(s.shape,u,l,a,i):new gM(s.shape,u,l,a,i);return n.runWebGLProgram(c,[s],"float32")}};class xM{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],u=[n&&a>1?a-1:a,n&&i>1?i-1:i],l=o[0]/u[0],c=o[1]/u[1],h=1/l,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const wM={kernelName:Rn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new xM(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class vM{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,u]=e;this.outputShape=[a,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class _M{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,u]=e;this.outputShape=[a,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const kM={kernelName:An,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,l]=o,c=pe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new _M(s.shape,u,l,a,i):new vM(s.shape,u,l,a,i);return n.runWebGLProgram(c,[s],s.dtype)}};class TM{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],u=[n&&a>1?a-1:a,n&&i>1?i-1:i],l=o[0]/u[0],c=o[1]/u[1],h=1/l,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const SM={kernelName:Cn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new TM(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class IM{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r)).join(","),s=gA(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class NM{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=RC("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=gA(n);function o(n){const r=e.map((r,s)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(s,n));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${s}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const EM={kernelName:Fn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=W(a,s.shape);if(0===i)return nO({inputs:{x:s},backend:n});const u=pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new NM(s.shape,o):new IM(s.shape,o);return n.runWebGLProgram(u,[s],s.dtype)}};class $M{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let s="";s="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const AM={kernelName:Tr,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,u=new $M(r.shape,a),[l,c]=sp(i,r.shape[1],r.shape[2]),h=[[l,c,Math.sin(s),Math.cos(s)]];return o.runWebGLProgram(u,[r],r.dtype,h)}},CM=pO({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),OM={kernelName:Pn,backendName:"webgl",kernelFunc:CM},RM=pO({opSnippet:"return inversesqrt(x);",cpuKernelImpl:pC}),DM={kernelName:Mn,backendName:"webgl",kernelFunc:RM};class FM{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const u=gA(s.length),l=gA(a.length);let c="";1===n?c="i":2===n&&(c="i, j");const h=`getIndices(${c})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const p=`getUpdates(${d})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides";this.userCode=`\n        ${u} strides = ${u}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${h});\n              flattenedIndex += index * ${g};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(${m}, sum, float(found)));\n        }\n      `}}class PM{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const u=gA(s.length),l=gA(a.length);let c="";1===n?c="i":2===n&&(c="i, j");const h=`getIndices(${c})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const p=`getUpdates(${d})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides",b=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${u} strides = ${u}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${h});\n              flattenedIndex += index.xz * ${g};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${b};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${p};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${m}, sum, found));\n        }\n      `}}const MM={kernelName:Ln,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=bh(0,s,i),d=[h/l,l];if(0===h)return n.makeTensorInfo(i,s.dtype);const p=vO({inputs:{x:s},backend:n,attrs:{shape:[u,o]}}),f=vO({inputs:{x:a},backend:n,attrs:{shape:[u,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=pe().getBool("WEBGL_PACK")?new PM(u,o,p.shape.length,f.shape.length,c,d):new FM(u,o,p.shape.length,f.shape.length,c,d);const b=n.runWebGLProgram(g,[f,p,m],f.dtype),y=vO({inputs:{x:b},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(m),y}};class LM{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=2===pe().getNumber("WEBGL_VERSION")?"while (left < right) {":s,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const zM={kernelName:Bn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new LM(s.shape[0],s.shape[1],a.shape[1],i),u=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",u)}};class BM{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&a.push(`${n[r]}`);r=a.join(),s=i.join()}const a=gA(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const UM={kernelName:Un,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new BM(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],Ns(s.dtype,a.dtype))}},VM=pO({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${hp};\n  float scale = ${dp};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),WM={kernelName:Vn,backendName:"webgl",kernelFunc:VM},jM=pO({opSnippet:dO+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:mC}),GM={kernelName:qn,backendName:"webgl",kernelFunc:jM},HM=pO({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),qM={kernelName:Hn,backendName:"webgl",kernelFunc:HM},KM=pO({opSnippet:dO+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${eO}\n  return result;\n`}),XM={kernelName:jn,backendName:"webgl",kernelFunc:KM},YM=pO({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),ZM={kernelName:Gn,backendName:"webgl",kernelFunc:YM},JM=pO({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),QM={kernelName:Kn,backendName:"webgl",kernelFunc:JM},eL={kernelName:Zn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;R(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((e,t)=>e*t),u=[[0,0]];u.push(...i);for(let e=1+a.length;e<s.shape.length;++e)u.push([0,0]);const l=[],c=eM({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),h=ap(c.shape,a,o,!1),d=ip(h.length,a.length,!1),p=op(c.shape,a,o,!1),f=vO({inputs:{x:c},backend:n,attrs:{shape:h}}),m=CO({inputs:{x:f},backend:n,attrs:{perm:d}}),g=vO({inputs:{x:m},backend:n,attrs:{shape:p}});return l.push(c),l.push(f),l.push(m),l.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}},tL={kernelName:er,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.readSync(r.dataId),u=n.readSync(s.dataId),l=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[h,d,p,f,m]=yC(o,r.shape,r.dtype,u,s.dtype,l,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},nL={kernelName:tr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),u=Array.from(n.readSync(a.dataId)),[l,c,h]=xC(o,r.shape,r.dtype,i,u);return[n.makeTensorInfo(c,r.dtype,l),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}},rL={kernelName:nr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),u=n.readSync(a.dataId),[l,c]=wC(i,r.shape,r.dtype,o,u,!0);return n.makeTensorInfo(c,r.dtype,l)}},sL={kernelName:rr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),u=n.readSync(a.dataId),[l,c]=wC(i,r.shape,r.dtype,o,u);return n.makeTensorInfo(c,r.dtype,l)}},aL={kernelName:sr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=bh(0,s,o),p=!1;if("string"===a.dtype){const e=n.bufferSync(s),t=n.bufferSync(a),r=rs(n.readSync(i.dataId)[0]),f=fC(e,t,o,d,c,l,u,h,r,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=new FM(l,u,s.shape.length,a.shape.length,h,[d,1],p),m=n.runWebGLProgram(f,[a,s,i],a.dtype),g=vO({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}},iL={kernelName:Jn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=W(i,s.shape)[0],u=Mp(s,a,o),l=s.shape.length,c=new Array(l).fill(0),h=s.shape.slice();return u.map(e=>{const t=[...h];t[o]=e;const r=NR({inputs:{x:s},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r})}},oL="return sqrt(x);",uL=pO({opSnippet:oL,packedOpSnippet:oL,cpuKernelImpl:vC}),lL={kernelName:Xn,backendName:"webgl",kernelFunc:uL},cL={kernelName:ir,backendName:"webgl",kernelFunc:pO({opSnippet:"return x * x;"})},hL="return (a - b) * (a - b);",dL=fO({opSnippet:hL,packedOpSnippet:hL}),pL={kernelName:ar,backendName:"webgl",kernelFunc:dL},fL={kernelName:or,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const a=Qp(n.readSync(s.dataId)),i=_C(a,"string",r);return n.makeTensorInfo(s.shape,"string",i)}},mL={kernelName:kr,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=UC+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,a=new BC(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}};class gL{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=gA(n.length),a=gA(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`)).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const bL={kernelName:ur,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:b,begin:y,end:x,strides:w}=Ao(s.shape,a,i,o,u,l,c,h,d);let v;if(m)v=vO({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||b){R(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const e=bo(y,x,w),t=NR({inputs:{x:s},backend:n,attrs:{begin:y,size:e}});v=vO({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=ci(s.shape,s.dtype,e),r=kC(p,t,w,y);v=n.makeTensorInfo(f,s.dtype,r.values)}else{const e=new gL(y,w,p);v=n.runWebGLProgram(e,[s],s.dtype)}const _=vO({inputs:{x:v},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(v),_}},yL={kernelName:lr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:l}=r,{data:c,dataSplits:h}=t,d=n.readSync(c.dataId),p=n.readSync(h.dataId),[f,m]=TC(d,p,s,a,i,o,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},xL={kernelName:cr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),u=n.readSync(i.dataId)[0],[l,c,h]=SC(o,u,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}},wL={kernelName:hr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=IC(i,s);return n.makeTensorInfo(a.shape,"int32",o)}},vL=pO({opSnippet:"return tan(x);"}),_L={kernelName:pr,backendName:"webgl",kernelFunc:vL},kL=pO({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),TL={kernelName:fr,backendName:"webgl",kernelFunc:kL},SL={kernelName:zn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{}=r,{sliceRank:o,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=bh(0,a,s.shape),d=[h/l,l];if(0===h)return n.makeTensorInfo(s.shape,a.dtype);const p=vO({inputs:{x:a},backend:n,attrs:{shape:[u,o]}}),f=vO({inputs:{x:i},backend:n,attrs:{shape:[u,l]}}),m=vO({inputs:{x:s},backend:n,attrs:{shape:d}}),g=new FM(u,o,p.shape.length,f.shape.length,c,d,!1,!0),b=n.runWebGLProgram(g,[f,p,m],m.dtype),y=vO({inputs:{x:b},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),y}};class IL{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const r=gA(this.rank),s=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function NL(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map(e=>rs(e)):e,r=ci(s.shape,s.dtype,t),i=EC(r,a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new IL(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}const EL={kernelName:mr,backendName:"webgl",kernelFunc:NL};class $L{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class AL{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function CL(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function OL(e){let t=1;for(;t<e;)t*=2;return t}const RL={kernelName:gr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=pe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=pe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=s.shape,c=l[l.length-1];if(n.shouldExecuteOnCPU([s])||c<o||a>u){const e=n.readSync(s.dataId),[t,r]=$C(e,l,s.dtype,a,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===a)return l[l.length-1]=0,[n.makeTensorInfo(l,s.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(1===c)return[s,hF({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const h=n.texData.get(s.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(s):s,f=P(l)/c,m=vO({inputs:{x:p},attrs:{shape:[f,c]},backend:n});d&&CL(n,p);const g=OL(a),b=OL(c);let y=null;const x=()=>null===y?[m,m]:[m,y],w=(e,t,r)=>{const s=x(),a=new $L(r),i=[[c],[null===y?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=y;y=n.runWebGLProgram(a,s,"int32",i),CL(n,o)};for(let e=1;e<g;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)w(t,n,[f,b])}for(let e=b;e>g;e/=2){const t=x(),r=new AL([f,e/2]),s=[[c],[null===y?1:0],[g]],a=y;y=n.runWebGLProgram(r,t,"int32",s),CL(n,a);const i=g/2,o=2*i;for(let e=i;e>=1;e/=2)w(o,e,y.shape)}let v=y;y=NR({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,a]}}),CL(n,v);let _=AF({inputs:{x:m,indices:y},backend:n,attrs:{axis:1,batchDims:1}});CL(n,m);const k=l.slice(0,-1);k.push(a),v=y,y=vO({inputs:{x:y},attrs:{shape:k},backend:n}),CL(n,v);const T=_;return _=vO({inputs:{x:_},attrs:{shape:k},backend:n}),CL(n,T),[_,y]}};class DL{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const FL={kernelName:br,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:l}=r,[c,h,d,p]=s.shape,[f,m]=null!=l?l:[h,d],g=new DL(h,d,i,o,u,[c,f,m,p]);return n.runWebGLProgram(g,[s,a],"float32")}},PL={kernelName:xr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;Q$(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:o,outputShape:u,indices:l}=CC(i,s,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,o),r.makeTensorInfo([l.length],"int32",l)]}},ML={kernelName:wr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,u=s.shape[a],l=new Array(o-1);let c=0;for(let e=0;e<o;e++)e!==a&&(l[c++]=i.shape[e]);const h=[],d=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(u);for(let e=0;e<f.length;e++){d[a]=e;const t=NR({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),r=vO({inputs:{x:t},backend:n,attrs:{shape:l}});f[e]=r,h.push(t)}return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}};class LL{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];const o=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let h="";s%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}const zL={kernelName:vr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,u=[];let l=0;const c=sl([l],o);let h=s;null!=c&&(h=CO({inputs:{x:s},backend:n,attrs:{perm:c}}),u.push(h),l=il(1,o)[0]);const d=Zp(h.shape,l,i),p=P([h.shape[l]]),f=vO({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});u.push(f);const m=Es(s.dtype),g=(e,t,r,s,a)=>{const i=e.shape[0],o=e.shape[1],l=Yp(o,a),c=new LL({windowSize:l,inSize:o,batchSize:i,numSegments:a},t),h=n.compileAndRun(c,[e,r],s);if(u.push(h),h.shape[1]===a)return h;const d=uM({backend:n,attrs:{start:0,stop:a,step:1,dtype:"float32"}}),p=NL({inputs:{x:d},backend:n,attrs:{reps:[o/l]}});return u.push(d),u.push(p),g(h,t,p,s,a)},b=vO({inputs:{x:g(f,"unsortedSegmentSum",a,m,i)},backend:n,attrs:{shape:d}});let y=b;if(null!=c){u.push(b);const e=al(c);y=CO({inputs:{x:y},backend:n,attrs:{perm:e}})}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}},BL=[DO,PO,LO,BO,WO,HO,qO,KO,eR,tR,rR,aR,oR,lR,hR,fR,mR,yR,xR,wR,kR,$R,AR,CR,OR,MR,BR,WR,aO,HR,eD,uD,pD,mD,gD,bD,yD,wD,_D,TD,AD,CD,OD,DD,MD,BD,UD,WD,GD,HD,KD,XD,ZD,QD,tF,rF,iF,lF,dF,fF,bF,xF,_F,SF,IF,EF,CF,RF,FF,rO,PF,ZR,LF,BF,VF,uO,jF,HF,qF,XF,ZF,QF,tP,rP,iP,uP,cP,dP,pP,fP,bP,yP,xP,wP,vP,kP,IP,EP,MP,wO,zP,UP,WP,GP,DR,qP,YP,ZP,tM,rM,hO,sM,aM,iM,oM,lM,PR,CP,hM,pM,mM,_O,yM,wM,kM,SM,EM,AM,OM,DM,MM,zM,UM,WM,GM,qM,XM,ZM,ER,PP,QM,eL,tL,nL,rL,sL,aL,iL,lL,cL,pL,fL,mL,bL,yL,xL,wL,DP,AO,_L,TL,SL,EL,RL,FL,OO,PL,ML,zL,XP];for(const e of BL)Fr(e);function UL(e,t){null!==e&&e(t)}function VL(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}const WL=class{constructor(){let e=function(...t){return e._call(...t)};return Object.setPrototypeOf(e,new.target.prototype)}_call(...e){throw Error("Must implement _call method in subclass")}};function jL(e){return Number.isInteger(e)||"bigint"==typeof e}function GL(...e){return Array.prototype.concat.apply([],e)}var HL=__webpack_require__(143),qL=__webpack_require__(603),KL=__webpack_require__(853),XL=__webpack_require__(9),YL=__webpack_require__(837),ZL=__webpack_require__(499),JL=__webpack_require__(52),QL=__webpack_require__.t(JL,2),ez=__webpack_require__(264),tz=__webpack_require__.t(ez,2);let nz;const rz=["wasm"];"undefined"!=typeof process&&"node"===process?.release?.name?(nz=JL??QL,rz.unshift("cpu")):(nz=ez??tz,"undefined"!=typeof navigator&&/iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent)&&(nz.env.wasm.simd=!1));const{env:sz}=nz,az="2.5.1",iz="undefined"!=typeof self&&"caches"in self,oz=!mz(XL),uz=!mz(YL),lz=oz&&uz,cz=lz?YL.dirname(YL.dirname(ZL.fileURLToPath("file:///Users/tpercival/Scripts/Fun/full%20stack/test%20-%20extension/aletheia_main/node_modules/@xenova/transformers/src/env.js"))):"./",hz=lz?YL.join(cz,"/.cache/"):null,dz="/models/",pz=lz?YL.join(cz,dz):dz;sz.wasm.wasmPaths=lz?YL.join(cz,"/dist/"):`https://cdn.jsdelivr.net/npm/@xenova/transformers@${az}/dist/`;const fz={backends:{onnx:sz,tfjs:{}},__dirname:cz,version:az,allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!0,localModelPath:pz,useFS:oz,useBrowserCache:iz,useFSCache:oz,cacheDir:hz,useCustomCache:!1,customCache:null};function mz(e){return 0===Object.keys(e).length}globalThis.ReadableStream||(globalThis.ReadableStream=KL.ReadableStream);class gz{_CONTENT_TYPE_MAP={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};constructor(e){if(this.filePath=e,this.headers=new Headers,this.exists=HL.existsSync(e),this.exists){this.status=200,this.statusText="OK";let t=HL.statSync(e);this.headers.set("content-length",t.size.toString()),this.updateContentType();let n=this;this.body=new ReadableStream({start(e){n.arrayBuffer().then(t=>{e.enqueue(new Uint8Array(t)),e.close()})}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const e=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",this._CONTENT_TYPE_MAP[e]??"application/octet-stream")}clone(){let e=new gz(this.filePath);return e.exists=this.exists,e.status=this.status,e.statusText=this.statusText,e.headers=new Headers(this.headers),e}async arrayBuffer(){return(await HL.promises.readFile(this.filePath)).buffer}async blob(){const e=await HL.promises.readFile(this.filePath);return new Blob([e],{type:this.headers.get("content-type")})}async text(){return await HL.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function bz(e,t=null){let n;try{n=new URL(e)}catch(e){return!1}return!(t&&!t.includes(n.hostname)||"http:"!==n.protocol&&"https:"!==n.protocol)}async function yz(e){if(fz.useFS&&!bz(e))return new gz(e);if("undefined"!=typeof process&&"node"===process?.release?.name){const t=!!process.env?.TESTING_REMOTELY,n=fz.version,r=new Headers;if(r.set("User-Agent",`transformers.js/${n}; is_ci/${t};`),bz(e,["huggingface.co","hf.co"])){const e=process.env?.HF_ACCESS_TOKEN;e&&r.set("Authorization",`Bearer ${e}`)}return fetch(e,{headers:r})}return fetch(e)}const xz={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};class wz{constructor(e){this.path=e}async match(e){let t=qL.join(this.path,e),n=new gz(t);return n.exists?n:void 0}async put(e,t){const n=Buffer.from(await t.arrayBuffer());let r=qL.join(this.path,e);try{await HL.promises.mkdir(qL.dirname(r),{recursive:!0}),await HL.promises.writeFile(r,n)}catch(e){console.warn("An error occurred while writing the file to cache:",e)}}}async function vz(e,t,n=!0,r={}){if(!fz.allowLocalModels){if(r.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!fz.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}let s;if(UL(r.progress_callback,{status:"initiate",name:e,file:t}),!s&&fz.useBrowserCache){if("undefined"==typeof caches)throw Error("Browser cache is not available in this environment.");try{s=await caches.open("transformers-cache")}catch(e){console.warn("An error occurred while opening the browser cache:",e)}}if(!s&&fz.useFSCache&&(s=new wz(r.cache_dir??fz.cacheDir)),!s&&fz.useCustomCache){if(!fz.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!fz.customCache.match||!fz.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");s=fz.customCache}const a=r.revision??"main";let i,o,u,l=kz(e,t),c=kz(fz.localModelPath,l),h=kz(fz.remoteHost,fz.remotePathTemplate.replaceAll("{model}",e).replaceAll("{revision}",a),t),d="main"===a?l:kz(e,a,t),p=s instanceof wz?d:h;if(s&&(u=await async function(e,...t){for(let n of t)try{let t=await e.match(n);if(t)return t}catch(e){continue}}(s,c,p)),void 0===u){if(fz.allowLocalModels)if(bz(l)){if(r.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${l}.`);if(!fz.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${l}.`)}else try{u=await yz(c),i=c}catch(e){console.warn(`Unable to load from local path "${c}": "${e}"`)}if(void 0===u||404===u.status){if(r.local_files_only||!fz.allowRemoteModels){if(n)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${c}".`);return null}if(u=await yz(h),200!==u.status)return function(e,t,n){if(!n)return null;throw Error(`${xz[e]??`Error (${e}) occurred while trying to load file`}: "${t}".`)}(u.status,h,n);i=p}s&&u instanceof Response&&200===u.status&&(o=u.clone())}UL(r.progress_callback,{status:"download",name:e,file:t});const f=await async function(n){const s=n.headers.get("Content-Length");null===s&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let a=parseInt(s??"0"),i=new Uint8Array(a),o=0;const u=n.body.getReader();return await async function n(){const{done:s,value:l}=await u.read();if(s)return;let c=o+l.length;if(c>a){a=c;let e=new Uint8Array(a);e.set(i),i=e}return i.set(l,o),o=c,(n=>{UL(r.progress_callback,{status:"progress",...n,name:e,file:t})})({progress:o/a*100,loaded:o,total:a}),n()}(),i}(u);return o&&i&&void 0===await s.match(i)&&await s.put(i,o).catch(e=>{console.warn(`Unable to add response to browser cache: ${e}.`)}),UL(r.progress_callback,{status:"done",name:e,file:t}),f}async function _z(e,t,n=!0,r={}){let s=await vz(e,t,n,r);if(null===s)return{};let a=new TextDecoder("utf-8").decode(s);return JSON.parse(a)}function kz(...e){return(e=e.map((t,n)=>(n&&(t=t.replace(new RegExp("^/"),"")),n!==e.length-1&&(t=t.replace(new RegExp("/$"),"")),t))).join("/")}function Tz(e){const t=Iz(e)[0],n=e.map(e=>Math.exp(e-t)),r=n.reduce((e,t)=>e+t,0);return n.map(e=>e/r)}function Sz(e,t=0){return e=Array.from(e).map((e,t)=>[t,e]).sort((e,t)=>t[1]-e[1]),t>0&&(e=e.slice(0,t)),e}function Iz(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],n=0;for(let r=1;r<e.length;++r)e[r]>t&&(t=e[r],n=r);return[t,n]}function Nz(e,t){if(t%2==0||t<=0)throw new Error("Window size must be a positive odd number");const n=new e.constructor(e.length),r=new e.constructor(t),s=Math.floor(t/2);for(let t=0;t<e.length;++t){let a=0;for(let n=-s;n<=s;++n){let s=t+n;s<0?s=Math.abs(s):s>=e.length&&(s=2*(e.length-1)-s),r[a++]=e[s]}r.sort(),n[t]=r[s]}return n}function Ez(e,t){const n=Math.pow(10,t);return Math.round(e*n)/n}const $z=nz.Tensor;class Az extends $z{constructor(...e){return e[0]instanceof nz.Tensor?super(e[0].type,e[0].data,e[0].dims):super(...e),new Proxy(this,{get:(e,t)=>{if("string"==typeof t){let n=Number(t);if(Number.isInteger(n))return e._getitem(n)}return e[t]},set:(e,t,n)=>e[t]=n})}*[Symbol.iterator](){const[e,...t]=this.dims;if(t.length>0){const n=t.reduce((e,t)=>e*t);for(let r=0;r<e;++r)yield this._subarray(r,n,t)}else yield*this.data}_getitem(e){const[t,...n]=this.dims;if(e=Rz(e,t),n.length>0){const t=n.reduce((e,t)=>e*t);return this._subarray(e,t,n)}return new Az(this.type,[this.data[e]],n)}indexOf(e){for(let t=0;t<this.data.length;++t)if(this.data[t]==e)return t;return-1}_subarray(e,t,n){let r=this.data.subarray(e*t,(e+1)*t);return new Az(this.type,r,n)}item(){if(1!==this.data.length)throw new Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);return this.data[0]}tolist(){return function(e,t){const n=e.length;if(n!==t.reduce((e,t)=>e*t))throw Error(`cannot reshape array of size ${n} into shape (${t})`);let r=e;for(let e=t.length-1;e>=0;e--)r=r.reduce((n,r)=>{let s=n[n.length-1];return s.length<t[e]?s.push(r):n.push([r]),n},[[]]);return r[0]}(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){for(let e=0;e<this.data.length;++e)this.data[e]=1/(1+Math.exp(-this.data[e]));return this}clone(){return new Az(this.type,this.data.slice(),this.dims.slice())}slice(...e){let t=[],n=[];for(let r=0;r<this.dims.length;++r){let s=e[r];if(null==s)n.push([0,this.dims[r]]),t.push(this.dims[r]);else if("number"==typeof s)s=Rz(s,this.dims[r],r),n.push([s,s+1]);else{if(!Array.isArray(s)||2!==s.length)throw new Error(`Invalid slice: ${s}`);{if(s[0]>s[1])throw new Error(`Invalid slice: ${s}`);let e=[Math.max(s[0],0),Math.min(s[1],this.dims[r])];n.push(e),t.push(e[1]-e[0])}}}let r=n.map(([e,t])=>t-e),s=r.reduce((e,t)=>e*t),a=new this.data.constructor(s);const i=this.stride();for(let e=0;e<s;++e){let t=0;for(let s=r.length-1,a=e;s>=0;--s){const e=r[s];t+=(a%e+n[s][0])*i[s],a=Math.floor(a/e)}a[e]=this.data[t]}return new Az(this.type,a,t)}transpose(...e){return function(e,t){const[n,r]=function(e,t,n){const r=new Array(n.length),s=new Array(n.length);for(let e=n.length-1,a=1;e>=0;--e)s[e]=a,r[e]=t[n[e]],a*=r[e];const a=n.map((e,t)=>s[n.indexOf(t)]),i=new e.constructor(e.length);for(let n=0;n<e.length;++n){let r=0;for(let e=t.length-1,s=n;e>=0;--e)r+=s%t[e]*a[e],s=Math.floor(s/t[e]);i[r]=e[n]}return[i,r]}(e.data,e.dims,t);return new Az(e.type,n,r)}(this,e)}sum(e=null,t=!1){return this.norm(1,e,t)}norm(e="fro",t=null,n=!1){if("fro"===e)e=2;else if("string"==typeof e)throw Error(`Unsupported norm: ${e}`);if(null===t){let t=this.data.reduce((t,n)=>t+n**e,0)**(1/e);return new Az(this.type,[t],[])}t=Rz(t,this.dims.length);const r=this.dims.slice();r[t]=1;const s=new this.data.constructor(this.data.length/this.dims[t]);for(let n=0;n<this.data.length;++n){let a=0;for(let e=this.dims.length-1,s=n,i=1;e>=0;--e){const n=this.dims[e];e!==t&&(a+=s%n*i,i*=r[e]),s=Math.floor(s/n)}s[a]+=this.data[n]**e}if(1!==e)for(let t=0;t<s.length;++t)s[t]=s[t]**(1/e);return n||r.splice(t,1),new Az(this.type,s,r)}normalize_(e=2,t=1){t=Rz(t,this.dims.length);const n=this.norm(e,t,!0);for(let e=0;e<this.data.length;++e){let r=0;for(let n=this.dims.length-1,s=e,a=1;n>=0;--n){const e=this.dims[n];n!==t&&(r+=s%e*a,a*=this.dims[n]),s=Math.floor(s/e)}this.data[e]/=n.data[r]}return this}normalize(e=2,t=1){return this.clone().normalize_(e,t)}stride(){return function(e){const t=new Array(e.length);for(let n=e.length-1,r=1;n>=0;--n)t[n]=r,r*=e[n];return t}(this.dims)}squeeze(e=null){return new Az(this.type,this.data,Cz(this.dims,e))}squeeze_(e=null){return this.dims=Cz(this.dims,e),this}unsqueeze(e=null){return new Az(this.type,this.data,Oz(this.dims,e))}unsqueeze_(e=null){return this.dims=Oz(this.dims,e),this}flatten_(e=0,t=-1){t=(t+this.dims.length)%this.dims.length;let n=this.dims.slice(0,e),r=this.dims.slice(e,t+1),s=this.dims.slice(t+1);return this.dims=[...n,r.reduce((e,t)=>e*t,1),...s],this}flatten(e=0,t=-1){return this.clone().flatten_(e,t)}view(...e){let t=-1;for(let n=0;n<e.length;++n)if(-1===e[n]){if(-1!==t)throw new Error("Only one dimension can be inferred");t=n}if(-1!==t){const n=e.reduce((e,n,r)=>r!==t?e*n:e,1);e[t]=this.data.length/n}return new Az(this.type,this.data,e)}neg_(){for(let e=0;e<this.data.length;++e)this.data[e]=-this.data[e];return this}neg(){return this.clone().neg_()}}function Cz(e,t){return e=e.slice(),null===t?e=e.filter(e=>1!==e):"number"==typeof t?1===e[t]&&e.splice(t,1):Array.isArray(t)&&(e=e.filter((e,n)=>1!==e||!t.includes(n))),e}function Oz(e,t){return t=Rz(t,e.length+1),(e=e.slice()).splice(t,0,1),e}function Rz(e,t,n=null){if(e<-t||e>=t)throw new Error(`IndexError: index ${e} is out of bounds for dimension${null===n?"":" "+n} with size ${t}`);return e<0&&(e=(e%t+t)%t),e}function Dz(e,t=0){t=Rz(t,e[0].dims.length);const n=e[0].dims.slice();n[t]=e.reduce((e,n)=>e+n.dims[t],0);const r=n.reduce((e,t)=>e*t,1),s=new e[0].data.constructor(r),a=e[0].type;if(0===t){let t=0;for(let n of e)s.set(n.data,t),t+=n.data.length}else{let r=0;for(let a=0;a<e.length;++a){let i=e[a];for(let e=0;e<i.data.length;++e){let a=0;for(let s=i.dims.length-1,o=e,u=1;s>=0;--s){const e=i.dims[s];let l=o%e;s===t&&(l+=r),a+=l*u,u*=n[s],o=Math.floor(o/e)}s[a]=i.data[e]}r+=i.dims[t]}}return new Az(a,s,n)}function Fz(e,t=null,n=!1){if(null===t){let t=e.data.reduce((e,t)=>e+t,0);return new Az(e.type,[t/e.data.length],[])}t=Rz(t,e.dims.length);const r=e.dims.slice();r[t]=1;const s=new e.data.constructor(e.data.length/e.dims[t]);for(let n=0;n<e.data.length;++n){let a=0;for(let s=e.dims.length-1,i=n,o=1;s>=0;--s){const n=e.dims[s];s!==t&&(a+=i%n*o,o*=r[s]),i=Math.floor(i/n)}s[a]+=e.data[n]}if(1!==e.dims[t])for(let n=0;n<s.length;++n)s[n]=s[n]/e.dims[t];return n||r.splice(t,1),new Az(e.type,s,r)}function Pz(e){const[t,n]=e.dims,r=[t+1,n+1],s=new Az("float32",new Float32Array(r[0]*r[1]).fill(1/0),r),a=new Az("float32",new Float32Array(r[0]*r[1]).fill(-1),r);s[0].data[0]=0;for(let r=1;r<n+1;++r)for(let n=1;n<t+1;++n){const t=s[n-1][r-1].item(),i=s[n-1][r].item(),o=s[n][r-1].item();let u,l;t<i&&t<o?(u=t,l=0):i<t&&i<o?(u=i,l=1):(u=o,l=2),s[n].data[r]=e[n-1][r-1].item()+u,a[n].data[r]=l}let i=t,o=n;a.data.fill(2,0,r[1]);for(let e=0;e<r[0];++e)a[e].data[0]=1;let u=[],l=[];for(;i>0||o>0;)switch(u.push(i-1),l.push(o-1),a[i][o].item()){case 0:--i,--o;break;case 1:--i;break;case 2:--o;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${i}, ${o}]. Please file a bug report.`)}return u.reverse(),l.reverse(),[u,l]}class Mz{constructor(e=(e,t)=>e>t){this._heap=[],this._comparator=e}get size(){return this._heap.length}isEmpty(){return 0===this.size}peek(){return this._heap[0]}push(...e){return this.extend(e)}extend(e){for(const t of e)this._heap.push(t),this._siftUp();return this.size}pop(){const e=this.peek(),t=this.size-1;return t>0&&this._swap(0,t),this._heap.pop(),this._siftDown(),e}replace(e){const t=this.peek();return this._heap[0]=e,this._siftDown(),t}_parent(e){return(e+1>>>1)-1}_left(e){return 1+(e<<1)}_right(e){return e+1<<1}_greater(e,t){return this._comparator(this._heap[e],this._heap[t])}_swap(e,t){const n=this._heap[e];this._heap[e]=this._heap[t],this._heap[t]=n}_siftUp(){let e=this.size-1;for(;e>0&&this._greater(e,this._parent(e));)this._swap(e,this._parent(e)),e=this._parent(e)}_siftDown(){let e=0;for(;this._left(e)<this.size&&this._greater(this._left(e),e)||this._right(e)<this.size&&this._greater(this._right(e),e);){const t=this._right(e)<this.size&&this._greater(this._right(e),this._left(e))?this._right(e):this._left(e);this._swap(e,t),e=t}}}class Lz{constructor(){this.root=zz.default()}extend(e){for(let t of e)this.push(t)}push(e){let t=this.root;for(let n of e){let e=t.children.get(n);void 0===e&&(e=zz.default(),t.children.set(n,e)),t=e}t.isLeaf=!0}*commonPrefixSearch(e){let t=this.root,n="";for(let r=0;r<e.length&&void 0!==t;++r){const s=e[r];n+=s,t=t.children.get(s),void 0!==t&&t.isLeaf&&(yield n)}}}class zz{constructor(e,t){this.isLeaf=e,this.children=t}static default(){return new zz(!1,new Map)}}class Bz{constructor(e,t,n){this.sentence=e,this.len=e.length,this.bosTokenId=t,this.eosTokenId=n,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const r=new Uz(this.bosTokenId,0,0,0,0),s=new Uz(this.eosTokenId,1,this.len,0,0);this.nodes.push(r.clone()),this.nodes.push(s.clone()),this.beginNodes[this.len].push(s),this.endNodes[0].push(r)}insert(e,t,n,r){const s=this.nodes.length,a=new Uz(r,s,e,t,n);this.beginNodes[e].push(a),this.endNodes[e+t].push(a),this.nodes.push(a)}viterbi(){const e=this.len;let t=0;for(;t<=e;){if(0==this.beginNodes[t].length)return[];for(let e of this.beginNodes[t]){e.prev=null;let n=0,r=null;for(let s of this.endNodes[t]){const t=s.backtraceScore+e.score;(null===r||t>n)&&(r=s.clone(),n=t)}if(null===r)return[];e.prev=r,e.backtraceScore=n}++t}const n=[],r=this.beginNodes[e][0].prev;if(null===r)return[];let s=r.clone();for(;null!==s.prev;){n.push(s.clone());const e=s.clone();s=e.prev.clone()}return n.reverse(),n}piece(e){return this.sentence.slice(e.pos,e.pos+e.length)}tokens(){return this.viterbi().map(e=>this.piece(e))}tokenIds(){return this.viterbi().map(e=>e.tokenId)}}class Uz{constructor(e,t,n,r,s){this.tokenId=e,this.nodeId=t,this.pos=n,this.length=r,this.score=s,this.prev=null,this.backtraceScore=0}clone(){const e=new Uz(this.tokenId,this.nodeId,this.pos,this.length,this.score);return e.prev=this.prev,e.backtraceScore=this.backtraceScore,e}}async function Vz(e,t){return await Promise.all([_z(e,"tokenizer.json",!0,t),_z(e,"tokenizer_config.json",!0,t)])}function Wz(e,t=!0){return e.Regex?new RegExp(t?e.Regex:`(${e.Regex})`,"gu"):e.String?e.String:(console.warn("Unknown pattern type:",e),null)}function jz(e){return e.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}const Gz="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E";class Hz extends WL{constructor(e){super(),this.config=e,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=!1}static fromConfig(e,...t){switch(e.type){case"WordPiece":return new qz(e);case"Unigram":return new Kz(e,...t);case"BPE":return new Jz(e,...t);default:throw new Error(`Unknown TokenizerModel type: ${e.type}`)}}_call(e){return this.encode(e)}encode(e){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(e){let t=e.map(e=>this.tokens_to_ids.get(e)??this.unk_token_id);return this.fuse_unk&&(t=function(e,t){let n=[],r=0;for(;r<e.length;)if(n.push(e[r]),e[r]===t)for(;r<e.length&&e[r]===t;)++r;else++r;return n}(t,this.unk_token_id)),t}convert_ids_to_tokens(e){return e.map(e=>this.vocab[e]??this.unk_token)}}class qz extends Hz{constructor(e){super(e),this.tokens_to_ids=e.vocab,this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e}encode(e){let t=[];for(let n of e){let e=[...n],r=!1,s=0,a=[];for(;s<e.length;){let t=e.length,n=null;for(;s<t;){let r=e.slice(s,t).join("");if(s>0&&(r=this.config.continuing_subword_prefix+r),this.tokens_to_ids.has(r)){n=r;break}--t}if(null===n){r=!0;break}a.push(n),s=t}r?t.push(this.unk_token):t.push(...a)}return t}}class Kz extends Hz{constructor(e,t){super(e),this.vocab=new Array(e.vocab.size),this.scores=new Array(e.vocab.size);let n=0;e.vocab.forEach((e,t)=>{this.vocab[n]=t,this.scores[n]=e,++n}),this.unk_token_id=e.unk_id,this.unk_token=this.vocab[e.unk_id],this.tokens_to_ids=new Map(this.vocab.map((e,t)=>[e,t])),this.bosToken=" ",this.bosTokenId=this.tokens_to_ids.get(this.bosToken),this.eosToken=t.eos_token,this.eosTokenId=this.tokens_to_ids.get(this.eosToken),this.unkToken=this.vocab[this.unk_token_id],this.minScore=function(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],n=0;for(let r=1;r<e.length;++r)e[r]<t&&(t=e[r],n=r);return[t,n]}(this.scores)[0],this.unkScore=this.minScore-10,this.scores[this.unk_token_id]=this.unkScore,this.trie=new Lz,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(e){const t=e.sentence,n=t.length;let r=0;for(;r<n;){const n=1;let s=!1;const a=[];for(let i of this.trie.commonPrefixSearch(t.slice(r))){a.push(i);const t=this.tokens_to_ids.get(i),o=this.scores[t],u=i.length;e.insert(r,u,o,t),s||u!==n||(s=!0)}s||e.insert(r,n,this.unkScore,this.unk_token_id),r+=n}}tokenize(e){const t=new Bz(e,this.bosTokenId,this.eosTokenId);return this.populateNodes(t),t.tokens()}encode(e){let t=[];for(let n of e){const e=this.tokenize(n);t.push(...e)}return t}}const Xz=(()=>{const e=[...Array.from({length:"~".charCodeAt(0)-"!".charCodeAt(0)+1},(e,t)=>t+"!".charCodeAt(0)),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},(e,t)=>t+"".charCodeAt(0)),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},(e,t)=>t+"".charCodeAt(0))];let t=e.slice(),n=0;for(let r=0;r<256;++r)e.includes(r)||(e.push(r),t.push(256+n),n+=1);let r=t.map(e=>String.fromCharCode(e));return Object.fromEntries(e.map((e,t)=>[e,r[t]]))})(),Yz=(Zz=Xz,Object.fromEntries(Object.entries(Zz).map(([e,t])=>[t,e])));var Zz;class Jz extends Hz{constructor(e){super(e),this.BPE_SPLIT_TOKEN=" ",this.tokens_to_ids=e.vocab,this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e;this.bpe_ranks=new Map(e.merges.map((e,t)=>[e,t])),this.merges=e.merges.map(e=>e.split(this.BPE_SPLIT_TOKEN)),this.end_of_word_suffix=e.end_of_word_suffix,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.cache=new Map,this.fuse_unk??=this.config.fuse_unk}bpe(e){if(0===e.length)return[];const t=this.cache.get(e);if(void 0!==t)return t;const n=Array.from(e);this.end_of_word_suffix&&(n[n.length-1]+=this.end_of_word_suffix);let r=[];if(n.length>1){const e=new Mz((e,t)=>e.score<t.score);let t={token:n[0],bias:0,prev:null,next:null},s=t;for(let t=1;t<n.length;++t){const r={bias:t/n.length,token:n[t],prev:s,next:null};s.next=r,this._add_node(e,s),s=r}for(;!e.isEmpty();){const n=e.pop();if(n.deleted||!n.next||n.next.deleted)continue;if(n.deleted=!0,n.next.deleted=!0,n.prev){const e={...n.prev};n.prev.deleted=!0,n.prev=e,e.prev?e.prev.next=e:t=e}const r={token:n.token+n.next.token,bias:n.bias,prev:n.prev,next:n.next.next};r.prev?(r.prev.next=r,this._add_node(e,r.prev)):t=r,r.next&&(r.next.prev=r,this._add_node(e,r))}for(let e=t;null!==e;e=e.next)r.push(e.token)}else r=n;return this.cache.set(e,r),r}_add_node(e,t){const n=this.bpe_ranks.get(t.token+this.BPE_SPLIT_TOKEN+t.next.token);void 0!==n&&(t.score=n+t.bias,e.push(t))}encode(e){let t=[];for(let n of e){let e=this.bpe(n);for(let n of e)this.tokens_to_ids.has(n)?t.push(n):this.byte_fallback?t.push(...Array.from(this.text_encoder.encode(n)).map(e=>`<0x${e.toString(16).toUpperCase().padStart(2,"0")}>`)):t.push(this.unk_token)}return t}}class Qz extends WL{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"BertNormalizer":return new uB(e);case"Precompiled":return new $B(e);case"Sequence":return new oB(e);case"Replace":return new eB(e);case"NFC":return new tB(e);case"NFKD":return new nB(e);case"Strip":return new rB(e);case"StripAccents":return new sB(e);case"Lowercase":return new aB(e);case"Prepend":return new iB(e);default:throw new Error(`Unknown Normalizer type: ${e.type}`)}}normalize(e){throw Error("normalize should be implemented in subclass.")}_call(e){return this.normalize(e)}}class eB extends Qz{normalize(e){let t=Wz(this.config.pattern);return null===t?e:e=e.replaceAll(t,this.config.content)}}class tB extends Qz{normalize(e){return e.normalize("NFC")}}class nB extends Qz{normalize(e){return e.normalize("NFKD")}}class rB extends Qz{normalize(e){return this.config.strip_left&&this.config.strip_right?e=e.trim():(this.config.strip_left&&(e=e.trimStart()),this.config.strip_right&&(e=e.trimEnd())),e}}class sB extends Qz{normalize(e){return e.replace(/[\u0300-\u036f]/g,"")}}class aB extends Qz{normalize(e){return e.toLowerCase()}}class iB extends Qz{normalize(e){return this.config.prepend+e}}class oB extends Qz{constructor(e){super(e),this.normalizers=e.normalizers.map(e=>Qz.fromConfig(e))}normalize(e){return this.normalizers.reduce((e,t)=>t.normalize(e),e)}}class uB extends Qz{_tokenize_chinese_chars(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n],s=r.charCodeAt(0);this._is_chinese_char(s)?(t.push(" "),t.push(r),t.push(" ")):t.push(r)}return t.join("")}_is_chinese_char(e){return e>=19968&&e<=40959||e>=13312&&e<=19903||e>=131072&&e<=173791||e>=173824&&e<=177983||e>=177984&&e<=178207||e>=178208&&e<=183983||e>=63744&&e<=64255||e>=194560&&e<=195103}stripAccents(e){return e.normalize("NFD").replace(/[\u0300-\u036f]/g,"")}normalize(e){return this.config.handle_chinese_chars&&(e=this._tokenize_chinese_chars(e)),this.config.lowercase?(e=e.toLowerCase(),!1!==this.config.strip_accents&&(e=this.stripAccents(e))):this.config.strip_accents&&(e=this.stripAccents(e)),e}}class lB extends WL{static fromConfig(e){if(null===e)return null;switch(e.type){case"BertPreTokenizer":return new cB(e);case"Sequence":return new AB(e);case"WhitespaceSplit":return new CB(e);case"Metaspace":return new NB(e);case"ByteLevel":return new hB(e);case"Split":return new dB(e);case"Punctuation":return new pB(e);case"Digits":return new fB(e);default:throw new Error(`Unknown PreTokenizer type: ${e.type}`)}}pre_tokenize_text(e){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(e){let t=[];return t=Array.isArray(e)?e.map(e=>this.pre_tokenize_text(e)):this.pre_tokenize_text(e),t.flat()}_call(e){return this.pre_tokenize(e)}}class cB extends lB{constructor(e){super(),this.pattern=new RegExp(`[^\\s${Gz}]+|[${Gz}]`,"gu")}pre_tokenize_text(e){return e.trim().match(this.pattern)||[]}}class hB extends lB{constructor(e){super(),this.config=e,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=/'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu,this.byte_encoder=Xz,this.text_encoder=new TextEncoder}pre_tokenize_text(e){return(this.use_regex?e.match(this.pattern)||[]:[e]).map(e=>(this.add_prefix_space&&!e.startsWith(" ")&&(e=" "+e),Array.from(this.text_encoder.encode(e),e=>this.byte_encoder[e]).join("")))}}class dB extends lB{constructor(e){super(),this.config=e,this.pattern=Wz(this.config.pattern,this.config.invert)}pre_tokenize_text(e){return null===this.pattern?[]:this.config.invert?e.match(this.pattern)||[]:e.split(this.pattern).filter(e=>e)}}class pB extends lB{constructor(e){super(),this.config=e,this.pattern=new RegExp(`[^${Gz}]+|[${Gz}]+`,"gu")}pre_tokenize_text(e){return e.match(this.pattern)||[]}}class fB extends lB{constructor(e){super(),this.config=e;const t="[^\\d]+|\\d"+(this.config.individual_digits?"":"+");this.pattern=new RegExp(t,"gu")}pre_tokenize_text(e){return e.match(this.pattern)||[]}}class mB extends WL{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"TemplateProcessing":return new bB(e);case"ByteLevel":return new yB(e);case"RobertaProcessing":return new gB(e);default:throw new Error(`Unknown PostProcessor type: ${e.type}`)}}post_process(e,...t){throw Error("post_process should be implemented in subclass.")}_call(e,...t){return this.post_process(e,...t)}}class gB extends mB{constructor(e){super(e),this.cls=e.cls[0],this.sep=e.sep[0]}post_process(e,t=null){return e=GL([this.cls],e,[this.sep]),null!==t&&(e=GL(e,[this.sep],t,[this.sep])),e}}class bB extends mB{constructor(e){super(e),this.single=e.single,this.pair=e.pair}post_process(e,t=null){let n=null===t?this.single:this.pair,r=[];for(let s of n)"SpecialToken"in s?r.push(s.SpecialToken.id):"Sequence"in s&&("A"===s.Sequence.id?r=GL(r,e):"B"===s.Sequence.id&&(r=GL(r,t)));return r}}class yB extends mB{post_process(e){return e}}class xB extends WL{constructor(e){super(),this.config=e,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=e.trim_offsets}static fromConfig(e){switch(e.type){case"WordPiece":return new TB(e);case"Metaspace":return new EB(e);case"ByteLevel":return new SB(e);case"Replace":return new wB(e);case"ByteFallback":return new vB(e);case"Fuse":return new _B(e);case"Strip":return new kB(e);case"Sequence":return new IB(e);default:throw new Error(`Unknown Decoder type: ${e.type}`)}}_call(e){return this.decode(e)}decode(e){return this.decode_chain(e).join("")}decode_chain(e){throw Error("`decode_chain` should be implemented in subclass.")}}class wB extends xB{constructor(e){super(e)}decode_chain(e){let t=Wz(this.config.pattern);return null===t?e:e.map(e=>e.replaceAll(t,this.config.content))}}class vB extends xB{constructor(e){super(e),this.text_decoder=new TextDecoder}decode_chain(e){let t=[],n=[];for(let r of e){let e=null;if(6===r.length&&r.startsWith("<0x")&&r.endsWith(">")){let t=parseInt(r.slice(3,5),16);isNaN(t)||(e=t)}if(null!==e)n.push(e);else{if(n.length>0){let e=this.text_decoder.decode(Uint8Array.from(n));t.push(e),n=[]}t.push(r)}}if(n.length>0){let e=this.text_decoder.decode(Uint8Array.from(n));t.push(e),n=[]}return t}}class _B extends xB{constructor(e){super(e)}decode_chain(e){return[e.join("")]}}class kB extends xB{constructor(e){super(e),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(e){return e.map(e=>{let t=0;for(let n=0;n<this.start&&e[n]===this.content;++n)t=n+1;let n=e.length;for(let t=0;t<this.stop;++t){const r=e.length-t-1;if(e[r]!==this.content)break;n=r}return e.slice(t,n)})}}class TB extends xB{constructor(e){super(e),this.cleanup=e.cleanup}decode_chain(e){return e.map((e,t)=>(0!==t&&(e=e.startsWith(this.config.prefix)?e.replace(this.config.prefix,""):" "+e),this.cleanup&&(e=jz(e)),e))}}class SB extends xB{constructor(e){super(e),this.byte_decoder=Yz,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(e){let t=e.join(""),n=new Uint8Array([...t].map(e=>this.byte_decoder[e]));return this.text_decoder.decode(n)}decode_chain(e){let t=[],n=[];for(let r of e)this.added_tokens.includes(r)?(n.length>0&&(t.push(this.convert_tokens_to_string(n)),n=[]),t.push(r)):n.push(r);return n.length>0&&t.push(this.convert_tokens_to_string(n)),t}}class IB extends xB{constructor(e){super(e),this.decoders=e.decoders.map(e=>xB.fromConfig(e))}decode_chain(e){return this.decoders.reduce((e,t)=>t.decode_chain(e),e)}}class NB extends lB{constructor(e){super(),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement,this.strRep=e.str_rep||this.replacement}pre_tokenize(e){"string"==typeof e&&(e=e.trimStart().split(/\s+/));const t=[];for(let n of e){let e=n.replaceAll(" ",this.strRep);this.addPrefixSpace&&!e.startsWith(this.replacement)&&(e=this.strRep+e),t.push(e)}return t}}class EB extends xB{constructor(e){super(e),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement}decode_chain(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].replaceAll(this.replacement," ");this.addPrefixSpace&&0==n&&r.startsWith(" ")&&(r=r.substring(1)),t.push(r)}return t}}class $B extends Qz{constructor(e){super(e),this.charsmap=e.precompiled_charsmap}normalize(e){if((e=(e=e.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,"")).replace(/[\u0009\u000A\u000C\u000D\u1680\u200B\u200C\u200E\u200F\u2028\u2029\u2581\uFEFF\uFFFD]/gm," ")).includes("")){const t=e.split("");e=t.map(e=>e.normalize("NFKC")).join("")}else e=e.normalize("NFKC");return e}}class AB extends lB{constructor(e){super(),this.tokenizers=e.pretokenizers.map(e=>lB.fromConfig(e))}pre_tokenize_text(e){return"string"==typeof e&&(e=[e]),this.tokenizers.reduce((e,t)=>t.pre_tokenize(e),e)}}class CB extends lB{constructor(e){super()}pre_tokenize_text(e){return function(e){return e.match(/\S+/g)||[]}(e)}}class OB extends WL{constructor(e,t){super(),this.normalizer=Qz.fromConfig(e.normalizer),this.pre_tokenizer=lB.fromConfig(e.pre_tokenizer),e.model.vocab&&(Array.isArray(e.model.vocab)||(e.model.vocab=Object.entries(e.model.vocab)),e.model.vocab=new Map(e.model.vocab)),this.model=Hz.fromConfig(e.model,t),this.post_processor=mB.fromConfig(e.post_processor),this.decoder=xB.fromConfig(e.decoder),this.decoder.end_of_word_suffix=this.model.end_of_word_suffix,this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(let t of e.added_tokens){let e=t.id,n=t.content;this.added_tokens.push(n),this.model.tokens_to_ids.set(n,e),this.model.vocab[e]=n,t.special&&(this.special_tokens.push(n),this.all_special_ids.push(e))}this.decoder.added_tokens=this.added_tokens,this.added_tokens_regex=new RegExp("("+this.added_tokens.map(VL).join("|")+")"),this.mask_token=this.getToken(t,"mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken(t,"pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken(t,"sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.model_max_length=t.model_max_length,this.remove_space=t.remove_space,this.clean_up_tokenization_spaces=t.clean_up_tokenization_spaces??!0,this.padding_side="right"}getToken(e,...t){for(let n of t){let t=e[n];if(t){if("object"==typeof t){if("AddedToken"===t.__type)return t.content;throw Error(`Unknown token: ${t}`)}return t}}return null}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:a="main"}={}){return new this(...await Vz(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:a}))}prepare_model_inputs(e){return e}_call(e,{text_pair:t=null,padding:n=!1,truncation:r=null,max_length:s=null,return_tensor:a=!0}={}){let i;if(Array.isArray(e)){if(0===e.length)throw Error("text array must be non-empty");if(null!==t){if(!Array.isArray(t))throw Error("text_pair must also be an array");if(e.length!==t.length)throw Error("text and text_pair must have the same length");i=e.map((e,n)=>this.encode(e,t[n]))}else i=e.map(e=>this.encode(e))}else{if(null===e)throw Error("text may not be null");if(Array.isArray(t))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");i=[this.encode(e,t)]}let o=Iz(i.map(e=>e.length))[0];null===s&&(s=o),s=Math.min(s,this.model_max_length);let u=[];if(n||r)for(let e=0;e<i.length;++e)if(i[e].length!==s)if(i[e].length>s)r&&(i[e]=i[e].slice(0,s)),u.push(new Array(i[e].length).fill(1));else if(n){let t=s-i[e].length;"right"===this.padding_side?(u.push(new Array(i[e].length).fill(1).concat(new Array(t).fill(0))),i[e].push(...new Array(t).fill(this.pad_token_id))):(u.push(new Array(t).fill(0).concat(new Array(i[e].length).fill(1))),i[e].unshift(...new Array(t).fill(this.pad_token_id)))}else u.push(new Array(i[e].length).fill(1));else u.push(new Array(i[e].length).fill(1));else u=i.map(e=>new Array(e.length).fill(1));if(a){if((!n||!r)&&i.some(e=>e.length!==i[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");let e=[i.length,i[0].length];i=new Az("int64",BigInt64Array.from(i.flat().map(BigInt)),e),u=new Az("int64",BigInt64Array.from(u.flat().map(BigInt)),e)}else Array.isArray(e)||(i=i[0],u=u[0]);let l={input_ids:i,attention_mask:u};return l=this.prepare_model_inputs(l),l}_encode_text(e){return null===e?null:e.split(this.added_tokens_regex).filter(e=>e).map(e=>{if(this.added_tokens.includes(e))return e;{!0===this.remove_space&&(e=e.trim().split(/\s+/).join(" ")),null!==this.normalizer&&(e=this.normalizer(e));let t=null!==this.pre_tokenizer?this.pre_tokenizer(e):[e];return this.model(t)}}).flat()}encode(e,t=null){let n=this._encode_text(e),r=this._encode_text(t),s=null!==this.post_processor?this.post_processor(n,r):GL(n??[],r??[]);return this.model.convert_tokens_to_ids(s)}batch_decode(e,t={}){return e.map(e=>this.decode(e,t))}decode(e,t={}){if(!Array.isArray(e)||0===e.length||!jL(e[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(e,t)}decode_single(e,{skip_special_tokens:t=!1,clean_up_tokenization_spaces:n=null}){let r=this.model.convert_ids_to_tokens(e);t&&(r=r.filter(e=>!this.special_tokens.includes(e)));let s=this.decoder(r);return this.decoder.end_of_word_suffix&&(s=s.replaceAll(this.decoder.end_of_word_suffix," "),t&&(s=s.trim())),(n??this.clean_up_tokenization_spaces)&&(s=jz(s)),s}}function RB(e){if(e.input_ids instanceof Az)e.token_type_ids=new Az("int64",new BigInt64Array(e.input_ids.data.length),e.input_ids.dims);else{if(!Array.isArray(e.input_ids))throw new Error("Input ids must be a Tensor or an Array");Array.isArray(e.input_ids[0])?e.token_type_ids=e.input_ids.map(e=>new Array(e.length).fill(0)):e.token_type_ids=new Array(e.input_ids.length).fill(0)}return e}class DB extends OB{prepare_model_inputs(e){return RB(e)}}class FB extends OB{prepare_model_inputs(e){return RB(e)}}class PB extends OB{prepare_model_inputs(e){return RB(e)}}class MB extends OB{prepare_model_inputs(e){return RB(e)}}class LB extends OB{prepare_model_inputs(e){return RB(e)}}class zB extends OB{prepare_model_inputs(e){return RB(e)}}class BB extends OB{}class UB extends OB{}class VB extends OB{}class WB extends OB{}class jB extends OB{}class GB extends OB{}class HB extends OB{}class qB extends OB{}class KB extends OB{}class XB extends OB{prepare_model_inputs(e){return RB(e)}}class YB extends OB{}class ZB extends OB{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(e=>this.languageRegex.test(e))}_build_translation_inputs(e,t,n){if(!this.language_codes.includes(n.tgt_lang))throw new Error(`Target language code "${n.tgt_lang}" is not valid. Must be one of: {${this.language_codes.join(", ")}}`);if(void 0!==n.src_lang){if(!this.language_codes.includes(n.src_lang))throw new Error(`Source language code "${n.src_lang}" is not valid. Must be one of: {${this.language_codes.join(", ")}}`);for(let e of this.post_processor.config.single)if("SpecialToken"in e&&this.languageRegex.test(e.SpecialToken.id)){e.SpecialToken.id=n.src_lang;break}}return n.forced_bos_token_id=this.model.convert_tokens_to_ids([n.tgt_lang])[0],this._call(e,t)}}const JB=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],QB=new Map(JB),eU=new Map([...JB.map(([e,t])=>[t,e]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);class tU extends OB{_decode_asr(e,{return_timestamps:t=!1,return_language:n=!1,time_precision:r=null,force_full_sequences:s=!0}={}){if(null===r)throw Error("Must specify time_precision");let a=null;const i="word"===t;function o(){return{language:a,timestamp:[null,null],text:""}}const u=[];let l=o(),c=0;const h=this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1;let d=[],p=[],f=!1,m=null;const g=new Set(this.all_special_ids);for(let n of e){const e=n.tokens,s=i?n.token_timestamps:null;let b=null,y=h;if("stride"in n){const[t,s,a]=n.stride;if(c-=s,m=t-a,s&&(y=s/r+h),a)for(let t=e.length-1;t>=0;--t){const n=e[t];if(n>=h){if(null!==b&&(n-h)*r<m)break;b=n}}}let x=[],w=[];for(let n=0;n<e.length;++n){const m=e[n];if(g.has(m)){const e=this.decode([m]);if("["===e[0]&&"]"===e[e.length-1]){const n=QB.get(e.slice(1,-1));if(void 0!==n){if(null!==a&&n!==a&&!t){d.push(x);const e=this.findLongestCommonSequence(d)[0],t=this.decode(e);l.text=t,u.push(l),d=[],x=[],l=o()}a=l.language=n}}}else if(m>=h){const e=Ez((m-h)*r+c,2);if(null!==b&&m>=b)f=!0;else if(f||d.length>0&&m<y)f=!1;else if(null===l.timestamp[0])l.timestamp[0]=e;else if(e===l.timestamp[0]);else{l.timestamp[1]=e,d.push(x),i&&p.push(w);const[t,n]=this.findLongestCommonSequence(d,p),r=this.decode(t);l.text=r,i&&(l.words=this.collateWordTimestamps(t,n,a)),u.push(l),d=[],x=[],p=[],w=[],l=o()}}else if(x.push(m),i){let e,t=Ez(s[n]+c,2);e=n+1<s.length?Ez(s[n+1]+c,2):null,w.push([t,e])}}if("stride"in n){const[e,t,r]=n.stride;c+=e-r}x.length>0?(d.push(x),i&&p.push(w)):d.every(e=>0===e.length)&&(l=o(),d=[],x=[],p=[],w=[])}if(d.length>0){if(s&&t)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[e,n]=this.findLongestCommonSequence(d,p),r=this.decode(e);l.text=r,i&&(l.words=this.collateWordTimestamps(e,n,a)),u.push(l)}let b=Object.create(null);const y=u.map(e=>e.text).join("");if(t||n){for(let e=0;e<u.length;++e){const r=u[e];t||delete r.timestamp,n||delete r.language}if(i){let e=[];for(let t of u)for(let n of t.words)e.push(n);b={chunks:e}}else b={chunks:u}}return[y,b]}findLongestCommonSequence(e,t=null){let n=e[0],r=n.length,s=[];const a=Array.isArray(t)&&t.length>0;let i=a?[]:null,o=a?t[0]:null;for(let u=1;u<e.length;++u){const l=e[u];let c=0,h=[r,r,0,0];const d=l.length;for(let e=1;e<r+d;++e){const t=e/1e4,s=Math.max(0,r-e),a=Math.min(r,r+d-e),i=n.slice(s,a),o=Math.max(0,e-r),u=Math.min(d,e),p=l.slice(o,u);if(i.length!==p.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");const f=i.filter((e,t)=>e===p[t]).length,m=f/e+t;f>1&&m>c&&(c=m,h=[s,a,o,u])}const[p,f,m,g]=h,b=Math.floor((f+p)/2),y=Math.floor((g+m)/2);s.push(...n.slice(0,b)),n=l.slice(y),r=n.length,a&&(i.push(...o.slice(0,b)),o=t[u].slice(y))}return s.push(...n),a?(i.push(...o),[s,i]):[s,[]]}collateWordTimestamps(e,t,n){let[r,s,a]=this.combineTokensIntoWords(e,n),i=[];for(let e=0;e<r.length;++e){const n=a[e];i.push({text:r[e],timestamp:[t[n.at(0)][0],t[n.at(-1)][1]]})}return i}combineTokensIntoWords(e,t,n="\"'([{-",r="\"'.,!?:)]}"){let s,a,i;return["chinese","japanese","thai","lao","myanmar"].includes(t=t??"english")?[s,a,i]=this.splitTokensOnUnicode(e):[s,a,i]=this.splitTokensOnSpaces(e),this.mergePunctuations(s,a,i,n,r)}decode(e,t){let n;return n=t&&t.decode_with_timestamps?this.decodeWithTimestamps(e,t):super.decode(e,t),n}decodeWithTimestamps(e,t){const n=t?.time_precision??.02,r=Array.from(this.all_special_ids).at(-1)+1;let s=[[]];for(let t of e)if(t>=r){let e=(t-r)*n;e=Ez(e,2),s.push(`<|${e}|>`),s.push([])}else s[s.length-1].push(t);return s=s.map(e=>"string"==typeof e?e:super.decode(e,t)),s.join("")}splitTokensOnUnicode(e){const t=this.decode(e,{decode_with_timestamps:!0});let n=[],r=[],s=[],a=[],i=[],o=0;for(let u=0;u<e.length;++u){const l=e[u];a.push(l),i.push(u);const c=this.decode(a,{decode_with_timestamps:!0});c.includes("")&&""!==t[o+c.indexOf("")]||(n.push(c),r.push(a),s.push(i),a=[],i=[],o+=c.length)}return[n,r,s]}splitTokensOnSpaces(e){let[t,n,r]=this.splitTokensOnUnicode(e),s=[],a=[],i=[];const o=new RegExp(`[${Gz}]`);for(let e=0;e<t.length;++e){const u=t[e],l=n[e],c=r[e],h=l[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),d=u.startsWith(" "),p=u.trim(),f=o.test(p);if(h||d||f||0===s.length)s.push(u),a.push(l),i.push(c);else{const e=s.length-1;s[e]+=u,a[e].push(...l),i[e].push(...c)}}return[s,a,i]}mergePunctuations(e,t,n,r,s){let a=structuredClone(e),i=structuredClone(t),o=structuredClone(n),u=a.length-2,l=a.length-1;for(;u>=0;)a[u].startsWith(" ")&&r.includes(a[u].trim())?(a[l]=a[u]+a[l],i[l]=GL(i[u],i[l]),o[l]=GL(o[u],o[l]),a[u]="",i[u]=[],o[u]=[]):l=u,--u;for(u=0,l=1;l<a.length;)!a[u].endsWith(" ")&&s.includes(a[l])?(a[u]+=a[l],i[u]=GL(i[u],i[l]),o[u]=GL(o[u],o[l]),a[l]="",i[l]=[],o[l]=[]):u=l,++l;return[a.filter(e=>e),i.filter(e=>e.length>0),o.filter(e=>e.length>0)]}get_decoder_prompt_ids({language:e=null,task:t=null,no_timestamps:n=!0}={}){let r=[];if(e){e=e.toLowerCase();let t=eU.get(e);if(void 0===t){if(!QB.has(e)){const t=2===e.length?QB.keys():QB.values();throw new Error(`Language "${e}" is not supported. Must be one of: ${JSON.stringify(t)}`)}t=e}let n=this.model.tokens_to_ids.get(`<|${t}|>`);if(void 0===n)throw new Error(`Unable to find language "${t}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);r.push(n)}else r.push(null);if(t){if("transcribe"!==(t=t.toLowerCase())&&"translate"!==t)throw new Error(`Task "${t}" is not supported. Must be one of: ["transcribe", "translate"]`);let e=this.model.tokens_to_ids.get(`<|${t}|>`);if(void 0===e)throw new Error(`Unable to find task "${t}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`);r.push(e)}else r.push(null);if(n){let e=this.model.tokens_to_ids.get("<|notimestamps|>");if(void 0===e)throw new Error('Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.');r.push(e)}return r.map((e,t)=>[t+1,e]).filter(e=>null!==e[1])}}class nU extends OB{}class rU extends OB{}class sU extends OB{constructor(e,t){super(e,t),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(e=>this.languageRegex.test(e)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(e){if(null===e)return null;let[t,...n]=e.trim().split(this.languageRegex);if(0===n.length)return super._encode_text(t);if(2===n.length){let[e,t]=n;return this.supported_language_codes.includes(e)||console.warn(`Unsupported language code "${e}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),GL([e],super._encode_text(t))}}}class aU{constructor(e){this.model_type=null,this.is_encoder_decoder=!1,Object.assign(this,e)}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:a="main"}={}){let i=n??await async function(e,t){return await _z(e,"config.json",!0,t)}(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:a});return new this(i)}}class iU{static async from_pretrained(...e){return aU.from_pretrained(...e)}}class oU extends WL{constructor(){super(),this.processors=[]}push(e){this.processors.push(e)}extend(e){this.processors.push(...e)}_call(e,t){for(let n of t)this.processors.forEach(t=>t(e,n))}[Symbol.iterator](){return this.processors.values()}}class uU extends WL{_call(e,t){throw Error("`_call` should be implemented in a subclass")}}class lU extends uU{constructor(e){super(),this.force_token_map=Object.fromEntries(e??[])}_call(e,t){let n=this.force_token_map[e.length];return null!=n&&(t.data.fill(-1/0),t.data[n]=0),t}}class cU extends uU{constructor(e){super(),this.bos_token_id=e}_call(e,t){return 1===e.length&&(t.data.fill(-1/0),t.data[this.bos_token_id]=0),t}}class hU extends uU{constructor(e,t){super(),this.max_length=e,this.forced_eos_token_id=t}_call(e,t){}}class dU extends uU{constructor(e,t){super(),this.begin_suppress_tokens=e,this.begin_index=t}_call(e,t){if(e.length===this.begin_index)for(let e of this.begin_suppress_tokens)t.data[e]=-1/0;return t}}class pU extends uU{constructor(e){super(),this.eos_token_id=e.eos_token_id,this.no_timestamps_token_id=e.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=(e.forced_decoder_ids||[]).length+2,e.forced_decoder_ids.slice(-1)[0][1]===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=e.max_initial_timestamp_index}_call(e,t){if(t.data[this.no_timestamps_token_id]=-1/0,e.length===this.begin_index-1)return t.data.fill(-1/0),t.data[this.timestamp_begin]=0,t;const n=e.slice(this.begin_index),r=n.length>=1&&n[n.length-1]>=this.timestamp_begin,s=n.length<2||n[n.length-2]>=this.timestamp_begin;if(r&&(s?t.data.subarray(this.timestamp_begin).fill(-1/0):t.data.subarray(0,this.eos_token_id).fill(-1/0)),e.length===this.begin_index&&null!==this.max_initial_timestamp_index){const e=this.timestamp_begin+this.max_initial_timestamp_index;t.data.subarray(e+1).fill(-1/0)}const a=Tz(t.data).map(e=>Math.log(e));return Math.log(a.subarray(this.timestamp_begin).map(Math.exp).reduce((e,t)=>e+t))>Iz(a.subarray(0,this.timestamp_begin))[0]&&t.data.subarray(0,this.timestamp_begin).fill(-1/0),t}}class fU extends uU{constructor(e){super(),this.no_repeat_ngram_size=e}getNgrams(e){const t=e.length,n=[];for(let r=0;r<t+1-this.no_repeat_ngram_size;++r){const t=[];for(let n=0;n<this.no_repeat_ngram_size;++n)t.push(e[r+n]);n.push(t)}const r=new Map;for(const e of n){const t=e.slice(0,e.length-1),n=JSON.stringify(t),s=r.get(n)??[];s.push(e[e.length-1]),r.set(n,s)}return r}getGeneratedNgrams(e,t){const n=t.slice(t.length+1-this.no_repeat_ngram_size,t.length);return e.get(JSON.stringify(n))??[]}calcBannedNgramTokens(e){if(e.length+1<this.no_repeat_ngram_size)return[];{const t=this.getNgrams(e);return this.getGeneratedNgrams(t,e)}}_call(e,t){const n=this.calcBannedNgramTokens(e);for(const e of n)t.data[e]=-1/0;return t}}class mU extends uU{constructor(e){super(),this.penalty=e}_call(e,t){for(const n of e)t.data[n]<0?t.data[n]*=this.penalty:t.data[n]/=this.penalty;return t}}class gU{constructor(e={}){this.max_length=e.max_length??20,this.max_new_tokens=e.max_new_tokens??null,this.min_length=e.min_length??0,this.min_new_tokens=e.min_new_tokens??null,this.early_stopping=e.early_stopping??!1,this.max_time=e.max_time??null,this.do_sample=e.do_sample??!1,this.num_beams=e.num_beams??1,this.num_beam_groups=e.num_beam_groups??1,this.penalty_alpha=e.penalty_alpha??null,this.use_cache=e.use_cache??!0,this.temperature=e.temperature??1,this.top_k=e.top_k??50,this.top_p=e.top_p??1,this.typical_p=e.typical_p??1,this.epsilon_cutoff=e.epsilon_cutoff??0,this.eta_cutoff=e.eta_cutoff??0,this.diversity_penalty=e.diversity_penalty??0,this.repetition_penalty=e.repetition_penalty??1,this.encoder_repetition_penalty=e.encoder_repetition_penalty??1,this.length_penalty=e.length_penalty??1,this.no_repeat_ngram_size=e.no_repeat_ngram_size??0,this.bad_words_ids=e.bad_words_ids??null,this.force_words_ids=e.force_words_ids??null,this.renormalize_logits=e.renormalize_logits??!1,this.constraints=e.constraints??null,this.forced_bos_token_id=e.forced_bos_token_id??null,this.forced_eos_token_id=e.forced_eos_token_id??null,this.remove_invalid_values=e.remove_invalid_values??!1,this.exponential_decay_length_penalty=e.exponential_decay_length_penalty??null,this.suppress_tokens=e.suppress_tokens??null,this.begin_suppress_tokens=e.begin_suppress_tokens??null,this.forced_decoder_ids=e.forced_decoder_ids??null,this.num_return_sequences=e.num_return_sequences??1,this.output_attentions=e.output_attentions??!1,this.output_hidden_states=e.output_hidden_states??!1,this.output_scores=e.output_scores??!1,this.return_dict_in_generate=e.return_dict_in_generate??!1,this.pad_token_id=e.pad_token_id??null,this.bos_token_id=e.bos_token_id??null,this.eos_token_id=e.eos_token_id??null,this.encoder_no_repeat_ngram_size=e.encoder_no_repeat_ngram_size??0,this.decoder_start_token_id=e.decoder_start_token_id??null,this.generation_kwargs=e.generation_kwargs??{}}}class bU extends WL{constructor(e){super(),this.generation_config=e}_call(e,t=-1){return this.sample(e,t)}sample(e,t){throw Error("sample should be implemented in subclasses.")}getLogits(e,t){let n=e.dims.at(-1),r=e.data;if(-1===t)r=r.slice(-n);else{let e=t*n;r=r.slice(e,e+n)}return this.generation_config.temperature>0&&(r=r.map(e=>e/this.generation_config.temperature)),r}randomSelect(e){let t=e.reduce((e,t)=>e+t,0),n=Math.random()*t;for(let t=0;t<e.length;++t)if(n-=e[t],n<=0)return t;return 0}static getSampler(e){if(e.do_sample)return new xU(e);if(e.num_beams>1)return new wU(e);if(e.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${e.num_return_sequences}.`);return new yU(e)}}class yU extends bU{sample(e,t=-1){return[[Iz(this.getLogits(e,t))[1],0]]}}class xU extends bU{sample(e,t=-1){let n=e.dims.at(-1);this.generation_config.top_k>0&&(n=Math.min(this.generation_config.top_k,n));const r=Sz(this.getLogits(e,t),n),s=Tz(r.map(e=>e[1]));return Array.from({length:this.generation_config.num_beams},()=>{const e=this.randomSelect(s);return[r[e][0],Math.log(s[e])]})}}class wU extends bU{sample(e,t=-1){let n=e.dims.at(-1);this.generation_config.top_k>0&&(n=Math.min(this.generation_config.top_k,n));const r=Sz(this.getLogits(e,t),n),s=Tz(r.map(e=>e[1]));return Array.from({length:this.generation_config.num_beams},(e,t)=>[r[t][0],Math.log(s[t])])}}const{InferenceSession:vU,Tensor:_U}=nz;class kU{}class TU extends kU{}class SU extends kU{}class IU extends SU{}class NU extends kU{}const EU=new Map([["CLIPTextModelWithProjection",TU],["CLIPVisionModelWithProjection",TU]]);async function $U(e,t,n){let r=`onnx/${t}${n.quantized?"_quantized":""}.onnx`,s=await vz(e,r,!0,n);try{return await vU.create(s,{executionProviders:rz})}catch(e){if(1===rz.length&&"wasm"===rz[0])throw e;return console.warn(e),console.warn("Something went wrong during model construction (most likely a missing operation). Using `wasm` as a fallback. "),await vU.create(s,{executionProviders:["wasm"]})}}async function AU(e,t){const n=await async function(e,t){const n={},r=[];for(let s of e.inputNames)void 0===t[s]?r.push(s):n[s]=t[s];if(r.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${r.join(", ")}.`);const s=Object.keys(t).length,a=e.inputNames.length;if(s>a){let n=Object.keys(t).filter(t=>!e.inputNames.includes(t));console.warn(`WARNING: Too many inputs were provided (${s} > ${a}). The following inputs will be ignored: "${n.join(", ")}".`)}return n}(e,t);try{let t=await e.run(n);return t=CU(t),t}catch(e){throw console.error(`An error occurred during model execution: "${e}".`),console.error("Inputs given to model:",n),e}}function CU(e){for(let t in e)e[t]instanceof _U?e[t]=new Az(e[t]):"object"==typeof e[t]&&CU(e[t]);return e}function OU(e){if(e instanceof Az)return e;if(0===e.length)throw Error("items must be non-empty");if(Array.isArray(e[0])){if(e.some(t=>t.length!==e[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new Az("int64",BigInt64Array.from(e.flat().map(e=>BigInt(e))),[e.length,e[0].length])}return new Az("int64",BigInt64Array.from(e.map(e=>BigInt(e))),[1,e.length])}function RU(e,t){let n=e.config.pad_token_id??null,r=e.config.eos_token_id??null;jL(r)&&(r=[r]);let s=-1!==t.indexOf(n),a=null===r||!r.includes(n);if(s&&a){let e=BigInt64Array.from(t.data.map(e=>e!=n));return new Az("int64",e,t.dims)}return new Az("int64",new BigInt64Array(t.data.length).fill(1n),t.dims)}function DU(e){return new Az("bool",[e],[1])}async function FU(e,t,{add_decoder_pkv:n=!0}={}){let{encoder_outputs:r,past_key_values:s}=t;r||(r=(await LU(e,t)).last_hidden_state);let a={input_ids:t.decoder_input_ids,encoder_hidden_states:r,use_cache_branch:DU(!!s)};e.decoder_merged_session.inputNames.includes("encoder_attention_mask")&&(a.encoder_attention_mask=t.attention_mask),e.addPastKeyValues(a,s,n);const i=await AU(e.decoder_merged_session,a);let o=i.logits;s=e.getPastKeyValues(i,s);const u=e.getAttentions(i);return new PV({logits:o,past_key_values:s,encoder_outputs:r,...u})}function PU(e,t,n,r=!0){let s=[],a=0,i=e.config.decoder_start_token_id;Array.isArray(i)||(i=[i]);for(let n of t){n.dims=[1,...n.dims];let t={inputs:n,encoder_outputs:null,prev_model_outputs:null,output_token_ids:i,done:!1,score:0,id:a++};r&&(t.attention_mask=RU(e,n)),s.push(t)}return s}async function MU(e,t,{input_name:n="input_ids"}={}){let r={[n]:t.inputs,decoder_input_ids:OU(t.output_token_ids.slice(-1)),encoder_outputs:t.encoder_outputs,past_key_values:t.prev_model_outputs?.past_key_values};t.attention_mask&&(r.attention_mask=t.attention_mask);let s=await e.forward(r);return t.prev_model_outputs=s,t.encoder_outputs=s.encoder_outputs,s}async function LU(e,t){let n={};for(let r of e.session.inputNames)n[r]=t[r];return await AU(e.session,n)}async function zU(e,t){let{input_ids:n,past_key_values:r,attention_mask:s}=t,a={input_ids:n,attention_mask:s??RU(e,n),use_cache_branch:DU(null!==r)};e.addPastKeyValues(a,r);let i=await AU(e.session,a),o=i.logits;return r=e.getPastKeyValues(i,r),{logits:o,past_key_values:r}}function BU(e,t,n,r){let s=[],a=0;for(let i of t){let t,o=i.tolist().map(Number);i.dims=[1,...i.dims],r?(t=r[a],t.dims=[1,...t.dims]):t=RU(e,i);let u={input:i,model_input_ids:i,attention_mask:t,prev_model_outputs:null,output_token_ids:o,num_output_tokens:n,done:!1,score:0,id:a++};s.push(u)}return s}async function UU(e,t){let n=new BigInt64Array(t.output_token_ids.length).fill(1n),r={input_ids:t.model_input_ids,attention_mask:new Az("int64",n,[1,n.length]),past_key_values:t.prev_model_outputs?.past_key_values},s=await e.forward(r);return t.prev_model_outputs=s,s}function VU(e,t){e.output_token_ids=[...e.output_token_ids,t],e.model_input_ids=new Az("int64",[BigInt(t)],[1,1])}class WU extends WL{constructor(e,t){super(),this.config=e,this.session=t}async dispose(){let e=[];for(let t of Object.keys(this)){let n=this[t];n instanceof vU&&e.push(n.handler.dispose())}return await Promise.all(e)}static async from_pretrained(e,{quantized:t=!0,progress_callback:n=null,config:r=null,cache_dir:s=null,local_files_only:a=!1,revision:i="main",model_file_name:o=null}={}){let u,l={quantized:t,progress_callback:n,config:r,cache_dir:s,local_files_only:a,revision:i,model_file_name:o},c=EU.get(this.name);if(c===NU)u=await Promise.all([iU.from_pretrained(e,l),$U(e,l.model_file_name??"decoder_model_merged",l)]);else if(c===IU)u=await Promise.all([iU.from_pretrained(e,l),$U(e,"encoder_model",l),$U(e,"decoder_model_merged",l),_z(e,"generation_config.json",!1,l)]);else if(c===SU)u=await Promise.all([iU.from_pretrained(e,l),$U(e,"encoder_model",l),$U(e,"decoder_model_merged",l)]);else{if(c!==TU)throw console.warn("Malformed class definition.",this),Error(`Unable to load model: ${e}. Please report this bug at https://github.com/xenova/transformers.js/issues/new/choose.`);u=await Promise.all([iU.from_pretrained(e,l),$U(e,l.model_file_name??"model",l)])}return new this(...u)}async _call(e){return await this.forward(e)}async forward(e){return await async function(e,t){return EU.get(e.constructor.name)===NU?await zU(e,t):await LU(e,t)}(this,e)}_get_logits_processor(e,t,n=null){const r=new oU;if(null!==e.repetition_penalty&&1!==e.repetition_penalty&&r.push(new mU(e.repetition_penalty)),null!==e.no_repeat_ngram_size&&e.no_repeat_ngram_size>0&&r.push(new fU(e.no_repeat_ngram_size)),null!==e.forced_bos_token_id&&r.push(new cU(e.forced_bos_token_id)),null!==e.forced_eos_token_id&&r.push(new hU(e.max_length,e.forced_eos_token_id)),null!==e.begin_suppress_tokens){let n=t>1||null===e.forced_bos_token_id?t:t+1;null!==e.forced_decoder_ids&&(n+=e.forced_decoder_ids[e.forced_decoder_ids.length-1][0]),r.push(new dU(e.begin_suppress_tokens,n))}return null!==e.forced_decoder_ids&&r.push(new lU(e.forced_decoder_ids)),null!==n&&r.extend(n),r}_get_generation_config(e){let t=new gU;return"generation_config"in this&&Object.assign(t,this.generation_config),null!==e&&Object.assign(t,e),t}async generate(e,t=null,n=null,{inputs_attention_mask:r=null}={}){if(!(e instanceof Az||(s=e,"TypedArray"===s?.prototype?.__proto__?.constructor?.name)||Array.isArray(e)))throw Error(`\`inputs\` must be a Tensor, TypedArray, or Array, but is "${e.constructor.name}".`);var s;let a;if(this.config.is_encoder_decoder)a=0;else if(a=e instanceof Az?e.dims[0]:e.length,0===a)throw Error("Must supply a non-empty array of input token ids.");t=this._get_generation_config(t),n=n??new oU,n=this._get_logits_processor(t,a,n);let i=1;const o=i+(t.max_new_tokens??1/0),u=Number.isInteger(t.max_length)&&null===(t.max_new_tokens??null);let l=bU.getSampler(t),c=this.getStartBeams(e,i,r);for(;c.some(e=>!e.done)&&i<o;){let e=[];for(let r of c){if(r.done){e.push(r);continue}if(u&&r.output_token_ids.length>=t.max_length){r.done=!0,e.push(r);continue}let s=await this.runBeam(r);t.output_attentions&&this.addAttentionsToBeam(r,s),t.output_scores;let a=s.logits.slice(null,-1,null);n(r.output_token_ids,a);let i=l(a);for(let[t,n]of i){let s={...r};this.updateBeam(s,t),s.score+=n,t===this.config.eos_token_id&&(s.done=!0),e.push(s)}}++i,e=this.groupBeams(e).map(e=>e.sort((e,t)=>t.score-e.score).slice(0,t.num_beams)),c=e.flat(),t.callback_function&&t.callback_function(c)}const h=this.groupBeams(c),d=e=>h.map(n=>t.num_return_sequences>1?n.slice(0,t.num_return_sequences).map(t=>t[e]):[n[0][e]]).flat(),p=d("output_token_ids");return t.return_dict_in_generate?{sequences:p,decoder_attentions:d("decoder_attentions"),cross_attentions:d("cross_attentions")}:p}addAttentionsToBeam(e,t){if(this.config.is_encoder_decoder){if(!t.cross_attentions||0===t.cross_attentions.length)throw Error("`output_attentions` is true, but the model did not produce cross-attentions. This is most likely because the model was not exported with `output_attentions=True`.");e.cross_attentions||(e.cross_attentions=[]),e.cross_attentions.push(t.cross_attentions)}if(!t.decoder_attentions||0===t.decoder_attentions.length)throw Error("`output_attentions` is true, but the model did not produce decoder-attentions. This is most likely because the model was not exported with `output_attentions=True`.");e.decoder_attentions||(e.decoder_attentions=[]),e.decoder_attentions.push(t.decoder_attentions)}groupBeams(e){const t=Object.create(null);for(const n of e)void 0===t[n.id]?t[n.id]=[n]:t[n.id].push(n);return Object.values(t)}getPastKeyValues(e,t){const n=Object.create(null);for(const r in e)if(r.startsWith("present")){let s=r.replace("present","past_key_values");t&&r.includes("encoder")?n[s]=t[s]:n[s]=e[r]}return n}getAttentions(e){const t=Object.create(null);for(const n of["cross_attentions","decoder_attentions"]){const r=[];for(const t in e)t.startsWith(n)&&(r[t.split(".").pop()]=e[t]);t[n]=r}return t}addPastKeyValues(e,t,n=!1){if(t)Object.assign(e,t);else if(n){let t=[1,this.num_encoder_heads,0,this.encoder_dim_kv];for(let n=0;n<this.num_encoder_layers;++n)e[`past_key_values.${n}.encoder.key`]=new Az("float32",[],t),e[`past_key_values.${n}.encoder.value`]=new Az("float32",[],t);let n=[1,this.num_decoder_heads,0,this.decoder_dim_kv];for(let t=0;t<this.num_decoder_layers;++t)e[`past_key_values.${t}.decoder.key`]=new Az("float32",[],n),e[`past_key_values.${t}.decoder.value`]=new Az("float32",[],n)}else if(this.config.multi_query){let t=[1,0,2*this.dim_kv];for(let n=0;n<this.num_layers;++n)e[`past_key_values.${n}.key_value`]=new Az("float32",[],t)}else{let t=[1,this.num_heads,0,this.dim_kv];for(let n=0;n<this.num_layers;++n)e[`past_key_values.${n}.key`]=new Az("float32",[],t),e[`past_key_values.${n}.value`]=new Az("float32",[],t)}}}class jU{}class GU extends WU{}class HU extends WU{}class qU extends WU{}class KU extends WU{}class XU extends WU{}class YU extends WU{}class ZU extends WU{}class JU extends WU{}class QU extends WU{}class eV extends WU{}class tV extends WU{}class nV extends WU{}class rV extends WU{}class sV extends WU{}class aV extends WU{}class iV extends WU{constructor(e,t){super(e,t),this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class oV extends WU{constructor(e,t){super(e,t),this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_heads,this.num_layers=this.config.num_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class uV extends WU{constructor(e,t){super(e,t),this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class lV extends WU{constructor(e,t){super(e,t),this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.n_head,this.num_layers=this.config.n_layer,this.dim_kv=this.config.n_embd/this.num_heads}}class cV extends WU{constructor(e,t){super(e,t),this.config.pad_token_id=this.config.eos_token_id,this.num_heads=this.config.num_attention_heads,this.num_layers=this.config.num_hidden_layers,this.dim_kv=this.config.hidden_size/this.num_heads}}class hV extends WU{}class dV extends WU{}class pV extends WU{}class fV extends jU{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class mV extends jU{constructor({logits:e,pred_boxes:t,pred_masks:n}){super(),this.logits=e,this.pred_boxes=t,this.pred_masks=n}}class gV extends WU{}class bV extends gV{async _call(e){return new yV(await super._call(e))}}class yV extends jU{constructor({iou_scores:e,pred_masks:t}){super(),this.iou_scores=e,this.pred_masks=t}}class xV extends WU{}class wV extends WU{}const vV=new Map([["bert",class extends GU{}],["deberta",class extends HU{}],["deberta-v2",class extends qU{}],["mpnet",class extends YU{}],["albert",class extends JU{}],["distilbert",class extends KU{}],["roberta",class extends nV{}],["xlm-roberta",class extends rV{}],["clip",class extends aV{}],["mobilebert",class extends XU{}],["squeezebert",class extends ZU{}],["sam",bV]]),_V=new Map([["t5",class extends QU{async generate(...e){throw Error("The current model class (T5Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'T5ForConditionalGeneration'}")}}],["mt5",class extends eV{async generate(...e){throw Error("The current model class (MT5Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'MT5ForConditionalGeneration'}")}}],["bart",class extends tV{async generate(...e){throw Error("The current model class (BartModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'BartForConditionalGeneration'}")}}],["marian",class extends xV{async generate(...e){throw Error("The current model class (MarianModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'MarianMTModel'}")}}],["whisper",class extends sV{async generate(...e){throw Error("The current model class (WhisperModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'WhisperForConditionalGeneration'}")}}],["m2m_100",class extends wV{async generate(...e){throw Error("The current model class (M2M100Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'M2M100ForConditionalGeneration'}")}}]]),kV=new Map([["gpt2",class extends iV{async generate(...e){throw Error("The current model class (GPT2Model) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'GPT2LMHeadModel'}")}}],["gpt_bigcode",class extends uV{async generate(...e){throw Error("The current model class (GPTBigCodeModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'GPTBigCodeForCausalLM'}")}}],["gpt_neo",class extends oV{async generate(...e){throw Error("The current model class (GPTNeoModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'GPTNeoForCausalLM'}")}}],["codegen",class extends lV{async generate(...e){throw Error("The current model class (CodeGenModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'CodeGenForCausalLM'}")}}],["llama",class extends cV{async generate(...e){throw Error("The current model class (LlamaModel) is not compatible with `.generate()`, as it doesn't have a language model head. Please use one of the following classes instead: {'LlamaForCausalLM'}")}}]]),TV=new Map([["bert",class extends GU{async _call(e){return new MV(await super._call(e))}}],["deberta",class extends HU{async _call(e){return new MV(await super._call(e))}}],["deberta-v2",class extends qU{async _call(e){return new MV(await super._call(e))}}],["mpnet",class extends YU{async _call(e){return new MV(await super._call(e))}}],["albert",class extends JU{async _call(e){return new MV(await super._call(e))}}],["distilbert",class extends KU{async _call(e){return new MV(await super._call(e))}}],["roberta",class extends nV{async _call(e){return new MV(await super._call(e))}}],["xlm-roberta",class extends rV{async _call(e){return new MV(await super._call(e))}}],["bart",class extends tV{async _call(e){return new MV(await super._call(e))}}],["mobilebert",class extends XU{async _call(e){return new MV(await super._call(e))}}],["squeezebert",class extends ZU{async _call(e){return new MV(await super._call(e))}}]]),SV=new Map([["bert",class extends GU{async _call(e){return new LV(await super._call(e))}}],["deberta",class extends HU{async _call(e){return new LV(await super._call(e))}}],["deberta-v2",class extends qU{async _call(e){return new LV(await super._call(e))}}],["mpnet",class extends YU{async _call(e){return new LV(await super._call(e))}}],["distilbert",class extends KU{async _call(e){return new LV(await super._call(e))}}],["roberta",class extends nV{async _call(e){return new LV(await super._call(e))}}],["xlm-roberta",class extends rV{async _call(e){return new LV(await super._call(e))}}]]),IV=new Map([["t5",class extends QU{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}getStartBeams(e,t,...n){return PU(this,e)}async runBeam(e){return await MU(this,e)}updateBeam(e,t){e.output_token_ids=[...e.output_token_ids,t]}async forward(e){return await FU(this,e)}}],["mt5",class extends eV{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.num_decoder_layers,this.num_decoder_heads=this.config.num_heads,this.decoder_dim_kv=this.config.d_kv,this.num_encoder_layers=this.config.num_layers,this.num_encoder_heads=this.config.num_heads,this.encoder_dim_kv=this.config.d_kv}getStartBeams(e,t,...n){return PU(this,e)}async runBeam(e){return await MU(this,e)}updateBeam(e,t){e.output_token_ids=[...e.output_token_ids,t]}async forward(e){return await FU(this,e)}}],["bart",class extends tV{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}getStartBeams(e,t,...n){return PU(this,e)}async runBeam(e){return await MU(this,e)}updateBeam(e,t){e.output_token_ids=[...e.output_token_ids,t]}async forward(e){return await FU(this,e)}}],["whisper",class extends sV{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}async generate(e,t=null,n=null){if(t=this._get_generation_config(t),t.return_timestamps??=!1,t.return_timestamps&&(n=[new pU(t)]),t.return_token_timestamps&&(t.output_attentions=!0,t.return_dict_in_generate=!0,"translate"===t.task&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),!t.alignment_heads))throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");const r=await super.generate(e,t,n);return t.return_token_timestamps&&t.alignment_heads&&(r.token_timestamps=this._extract_token_timestamps(r,t.alignment_heads)),r}getStartBeams(e,t,...n){return PU(this,e,0,!1)}async runBeam(e){return await MU(this,e,{input_name:"input_features"})}updateBeam(e,t){e.output_token_ids=[...e.output_token_ids,t]}async forward(e){return await FU(this,e)}_extract_token_timestamps(e,t,n=.02){if(!e.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");let r=this.config.median_filter_width;void 0===r&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),r=7);const s=e.cross_attentions.map(e=>{let n=Array.from({length:this.config.decoder_layers},(t,n)=>Dz(e.map(e=>e[n]),2)),s=function(e,t=0){return Dz(e.map(e=>e.unsqueeze(t)),t)}(t.map(([e,t])=>n[e].slice(null,t)));s=s.transpose(1,0,2,3);let[a,i]=function(e,t=null,n=1,r=!1){if(null===t){const t=e.data.reduce((e,t)=>e+t,0)/e.data.length,r=Math.sqrt(e.data.reduce((e,n)=>e+(n-t)**2,0)/(e.data.length-n)),s=new Az(e.type,[t],[]);return[new Az(e.type,[r],[]),s]}const s=Fz(e,t=Rz(t,e.dims.length),r),a=e.dims.slice();a[t]=1;const i=new e.data.constructor(e.data.length/e.dims[t]);for(let n=0;n<e.data.length;++n){let r=0;for(let s=e.dims.length-1,i=n,o=1;s>=0;--s){const n=e.dims[s];s!==t&&(r+=i%n*o,o*=a[s]),i=Math.floor(i/n)}i[r]+=(e.data[n]-s.data[r])**2}for(let r=0;r<i.length;++r)i[r]=Math.sqrt(i[r]/(e.dims[t]-n));return r||a.splice(t,1),[new Az(e.type,i,a),s]}(s,-2,0,!0),o=s.clone();for(let e=0;e<o.dims[0];++e){let t=o[e];for(let n=0;n<t.dims[0];++n){let s=t[n];const o=a[e][n][0],u=i[e][n][0];for(let e=0;e<s.dims[0];++e){let t=s[e];for(let e=0;e<t.data.length;++e)t.data[e]=(t.data[e]-u.data[e])/o.data[e];t.data.set(Nz(t.data,r))}}}return Fz(o,1)}),a=[e.sequences.length,e.sequences[0].length],i=new Az("float32",new Float32Array(a[0]*a[1]),a);for(let e=0;e<a[0];++e){const t=s[e].neg().squeeze_(0);let[r,a]=Pz(t),o=GL([1],Array.from({length:r.length-1},(e,t)=>r[t+1]-r[t])).map(e=>!!e),u=[];for(let e=0;e<o.length;++e)o[e]&&u.push(a[e]*n);i[e].data.set(u,1)}return i}}],["marian",class extends xV{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}getStartBeams(e,t,...n){return PU(this,e)}async runBeam(e){return await MU(this,e)}updateBeam(e,t){e.output_token_ids=[...e.output_token_ids,t]}async forward(e){return await FU(this,e)}}],["m2m_100",class extends wV{constructor(e,t,n,r){super(e,t),this.decoder_merged_session=n,this.generation_config=r,this.num_decoder_layers=this.config.decoder_layers,this.num_decoder_heads=this.config.decoder_attention_heads,this.decoder_dim_kv=this.config.d_model/this.num_decoder_heads,this.num_encoder_layers=this.config.encoder_layers,this.num_encoder_heads=this.config.encoder_attention_heads,this.encoder_dim_kv=this.config.d_model/this.num_encoder_heads}getStartBeams(e,t,...n){return PU(this,e)}async runBeam(e){return await MU(this,e)}updateBeam(e,t){e.output_token_ids=[...e.output_token_ids,t]}async forward(e){return await FU(this,e)}}]]),NV=new Map([["gpt2",class extends iV{getStartBeams(e,t,n){return BU(this,e,t,n)}async runBeam(e){return await UU(this,e)}updateBeam(e,t){return VU(e,t)}async forward(e){return await zU(this,e)}}],["gpt_bigcode",class extends uV{getStartBeams(e,t,n){return BU(this,e,t,n)}async runBeam(e){return await UU(this,e)}updateBeam(e,t){return VU(e,t)}async forward(e){return await zU(this,e)}}],["gpt_neo",class extends oV{getStartBeams(e,t,n){return BU(this,e,t,n)}async runBeam(e){return await UU(this,e)}updateBeam(e,t){return VU(e,t)}async forward(e){return await zU(this,e)}}],["codegen",class extends lV{getStartBeams(e,t,n){return BU(this,e,t,n)}async runBeam(e){return await UU(this,e)}updateBeam(e,t){return VU(e,t)}async forward(e){return await zU(this,e)}}],["llama",class extends cV{getStartBeams(e,t,n){return BU(this,e,t,n)}async runBeam(e){return await UU(this,e)}updateBeam(e,t){return VU(e,t)}async forward(e){return await zU(this,e)}}]]),EV=new Map([["bert",class extends GU{async _call(e){return new zV(await super._call(e))}}],["deberta",class extends HU{async _call(e){return new zV(await super._call(e))}}],["deberta-v2",class extends qU{async _call(e){return new zV(await super._call(e))}}],["mpnet",class extends YU{async _call(e){return new zV(await super._call(e))}}],["albert",class extends JU{async _call(e){return new zV(await super._call(e))}}],["distilbert",class extends KU{async _call(e){return new zV(await super._call(e))}}],["roberta",class extends nV{async _call(e){return new zV(await super._call(e))}}],["xlm-roberta",class extends rV{async _call(e){return new zV(await super._call(e))}}],["mobilebert",class extends XU{async _call(e){return new zV(await super._call(e))}}],["squeezebert",class extends ZU{async _call(e){return new zV(await super._call(e))}}]]),$V=new Map([["bert",class extends GU{async _call(e){return new BV(await super._call(e))}}],["deberta",class extends HU{async _call(e){return new BV(await super._call(e))}}],["deberta-v2",class extends qU{async _call(e){return new BV(await super._call(e))}}],["mpnet",class extends YU{async _call(e){return new BV(await super._call(e))}}],["albert",class extends JU{async _call(e){return new BV(await super._call(e))}}],["distilbert",class extends KU{async _call(e){return new BV(await super._call(e))}}],["roberta",class extends nV{async _call(e){return new BV(await super._call(e))}}],["xlm-roberta",class extends rV{async _call(e){return new BV(await super._call(e))}}],["mobilebert",class extends XU{async _call(e){return new BV(await super._call(e))}}],["squeezebert",class extends ZU{async _call(e){return new BV(await super._call(e))}}]]),AV=new Map([["vision-encoder-decoder",class extends WU{constructor(e,t,n){super(e,t),this.decoder_merged_session=n,this.num_layers=this.config.decoder.n_layer,this.num_heads=this.config.decoder.n_head,this.dim_kv=this.config.decoder.n_embd/this.num_heads}getStartBeams(e,t,...n){return PU(this,e)}async runBeam(e){return MU(this,e,{input_name:"pixel_values"})}updateBeam(e,t){e.output_token_ids=[...e.output_token_ids,t]}async forward(e){return await FU(this,e,{add_decoder_pkv:!1})}}]]),CV=new Map([["vit",class extends hV{async _call(e){return new MV(await super._call(e))}}],["mobilevit",class extends dV{async _call(e){return new MV(await super._call(e))}}]]),OV=new Map([["detr",class extends pV{async _call(e){return new fV(await super._call(e))}}]]),RV=new Map([["detr",class extends pV{async _call(e){return new mV(await super._call(e))}}]]),DV=new Map([["sam",bV]]),FV=[[vV,TU],[_V,SU],[kV,NU],[TV,TU],[SV,TU],[IV,IU],[NV,NU],[EV,TU],[$V,TU],[AV,SU],[CV,TU],[RV,TU],[OV,TU],[DV,TU]];for(const[e,t]of FV)for(const n of e.values())EU.set(n.name,t);class PV extends jU{constructor({logits:e,past_key_values:t,encoder_outputs:n,decoder_attentions:r=null,cross_attentions:s=null}){super(),this.logits=e,this.past_key_values=t,this.encoder_outputs=n,this.decoder_attentions=r,this.cross_attentions=s}}class MV extends jU{constructor({logits:e}){super(),this.logits=e}}class LV extends jU{constructor({logits:e}){super(),this.logits=e}}class zV extends jU{constructor({logits:e}){super(),this.logits=e}}class BV extends jU{constructor({start_logits:e,end_logits:t}){super(),this.start_logits=e,this.end_logits=t}}var UV=__webpack_require__(806);const VV="undefined"!=typeof self;let WV,jV,GV;if(VV)WV=(e,t)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(e,t)},GV=self.createImageBitmap,jV=self.ImageData;else{if(!UV)throw new Error("Unable to load image processing library.");GV=async e=>{const t=(await e.metadata()).channels;let{data:n,info:r}=await e.raw().toBuffer({resolveWithObject:!0});const s=new qV(new Uint8ClampedArray(n),r.width,r.height,r.channels);return void 0!==t&&t!==r.channels&&s.convert(t),s}}const HV={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"};class qV{_CONTENT_TYPE_MAP={png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};constructor(e,t,n,r){this._update(e,t,n,r)}static async read(e){if(e instanceof qV)return e;if("string"==typeof(t=e)||t instanceof String||e instanceof URL)return await this.fromURL(e);var t;throw new Error("Unsupported input type: "+typeof e)}static async fromURL(e){let t=await yz(e);if(200!==t.status)throw new Error(`Unable to read image from "${e}" (${t.status} ${t.statusText})`);let n=await t.blob();return this.fromBlob(n)}static async fromBlob(e){if(VV){let t=await GV(e);const n=WV(t.width,t.height).getContext("2d");return n.drawImage(t,0,0),new this(n.getImageData(0,0,t.width,t.height).data,t.width,t.height,4)}{let t=UV(await e.arrayBuffer());return await GV(t)}}grayscale(){if(1===this.channels)return this;let e=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let t=0,n=0;t<this.data.length;t+=this.channels){const r=this.data[t],s=this.data[t+1],a=this.data[t+2];e[n++]=Math.round(.2989*r+.587*s+.114*a)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,1)}rgb(){if(3===this.channels)return this;let e=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let t=0,n=0;t<this.data.length;++t)e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=this.data[t];break;case 4:for(let t=0,n=0;t<this.data.length;t+=4)e[n++]=this.data[t],e[n++]=this.data[t+1],e[n++]=this.data[t+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,3)}rgba(){if(4===this.channels)return this;let e=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let t=0,n=0;t<this.data.length;++t)e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=255;break;case 3:for(let t=0,n=0;t<this.data.length;t+=3)e[n++]=this.data[t],e[n++]=this.data[t+1],e[n++]=this.data[t+2],e[n++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,4)}async resize(e,t,{resample:n=2}={}){let r=HV[n]??n;if(VV){let n=this.channels,r=this.toCanvas();const s=WV(e,t).getContext("2d");return s.drawImage(r,0,0,e,t),new qV(s.getImageData(0,0,e,t).data,e,t,4).convert(n)}{let n=this.toSharp();switch(r){case"box":case"hamming":"box"!==r&&"hamming"!==r||(console.warn(`Resampling method ${r} is not yet supported. Using bilinear instead.`),r="bilinear");case"nearest":case"bilinear":case"bicubic":n=n.affine([e/this.width,0,0,t/this.height],{interpolator:r});break;case"lanczos":n=n.resize({width:e,height:t,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${r} is not supported.`)}return await GV(n)}}async pad([e,t,n,r]){if(e=Math.max(e,0),t=Math.max(t,0),n=Math.max(n,0),r=Math.max(r,0),0===e&&0===t&&0===n&&0===r)return this;if(VV){let s=this.channels,a=this.toCanvas(),i=this.width+e+t,o=this.height+n+r;const u=WV(i,o).getContext("2d");return u.drawImage(a,0,0,this.width,this.height,e,n,i,o),new qV(u.getImageData(0,0,i,o).data,i,o,4).convert(s)}{let s=this.toSharp().extend({left:e,right:t,top:n,bottom:r});return await GV(s)}}async center_crop(e,t){if(this.width===e&&this.height===t)return this;let n=(this.width-e)/2,r=(this.height-t)/2;if(VV){let s=this.channels,a=this.toCanvas();const i=WV(e,t).getContext("2d");let o=0,u=0,l=0,c=0;return n>=0?o=n:l=-n,r>=0?u=r:c=-r,i.drawImage(a,o,u,e,t,l,c,e,t),new qV(i.getImageData(0,0,e,t).data,e,t,4).convert(s)}{let s=this.toSharp();if(n>=0&&r>=0)s=s.extract({left:Math.floor(n),top:Math.floor(r),width:e,height:t});else if(n<=0&&r<=0){let a=Math.floor(-r),i=Math.floor(-n);s=s.extend({top:a,left:i,right:e-this.width-i,bottom:t-this.height-a})}else{let a=[0,0],i=0;r<0?(a[0]=Math.floor(-r),a[1]=t-this.height-a[0]):i=Math.floor(r);let o=[0,0],u=0;n<0?(o[0]=Math.floor(-n),o[1]=e-this.width-o[0]):u=Math.floor(n),s=s.extend({top:a[0],bottom:a[1],left:o[0],right:o[1]}).extract({left:u,top:i,width:e,height:t})}return await GV(s)}}toCanvas(){if(!VV)throw new Error("toCanvas() is only supported in browser environments.");let e=this.clone().rgba(),t=WV(e.width,e.height),n=new jV(e.data,e.width,e.height);return t.getContext("2d").putImageData(n,0,0),t}_update(e,t,n,r=null){return this.data=e,this.width=t,this.height=n,null!==r&&(this.channels=r),this}clone(){return new qV(this.data.slice(),this.width,this.height,this.channels)}convert(e){if(this.channels===e)return this;switch(e){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}save(e){if(VV){const t=e.split(".").pop().toLowerCase(),n=this._CONTENT_TYPE_MAP[t]??"image/png",r=this.toCanvas().toDataURL(n),s=document.createElement("a");s.href=r,s.download=e,s.click(),s.remove()}else{if(!fz.useFS)throw new Error("Unable to save the image because filesystem is disabled in this environment.");this.toSharp().toFile(e)}}toSharp(){if(VV)throw new Error("toSharp() is only supported in server-side environments.");return UV(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}const KV="tpercival/bert-uncased-social_media",XV=`https://huggingface.co/${KV}/resolve/main/model.json`,YV=class{static TOKENIZER_CLASS_MAPPING={T5Tokenizer:UB,DistilBertTokenizer:BB,DebertaTokenizer:LB,DebertaV2Tokenizer:zB,BertTokenizer:DB,MobileBertTokenizer:PB,SqueezeBertTokenizer:MB,AlbertTokenizer:FB,GPT2Tokenizer:VB,BartTokenizer:WB,RobertaTokenizer:jB,WhisperTokenizer:tU,CodeGenTokenizer:nU,CLIPTokenizer:rU,MarianTokenizer:sU,BloomTokenizer:GB,NllbTokenizer:ZB,LlamaTokenizer:HB,XLMRobertaTokenizer:qB,MPNetTokenizer:KB,FalconTokenizer:XB,GPTNeoXTokenizer:YB,PreTrainedTokenizer:OB};static async from_pretrained(e,{quantized:t=!0,progress_callback:n=null,config:r=null,cache_dir:s=null,local_files_only:a=!1,revision:i="main"}={}){let[o,u]=await Vz(e,{quantized:t,progress_callback:n,config:r,cache_dir:s,local_files_only:a,revision:i}),l=u.tokenizer_class.replace(/Fast$/,""),c=this.TOKENIZER_CLASS_MAPPING[l];return c||(console.warn(`Unknown tokenizer class "${l}", attempting to construct from base class.`),c=OB),new c(o,u)}}.from_pretrained(KV),ZV=async function(t,n={},r=e){if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==n&&(n={}),n.fromTFHub&&"string"==typeof t&&(t=function(e){return e.endsWith("/")||(e+="/"),`${e}model.json?tfjs-format=file`}(t));const s=new d_(t,n,r);return await s.load(),s}(XV);let JV;chrome.runtime.onInstalled.addListener(()=>{chrome.storage.local.get("enabled",({enabled:e})=>{void 0===e?(chrome.storage.local.set({enabled:!0}),JV=!0):JV=e})}),chrome.runtime.onStartup.addListener(()=>{chrome.storage.local.get("enabled").then(({enabled:e})=>{JV=e??!0})});let QV={tabID:null,status:"Ready to scan!",startedAt:null,aiPosCount:0,aiSomeCount:0};chrome.storage.local.set({state:QV}),chrome.runtime.onMessage.addListener((e,t,n)=>{switch(e.type){case"PROCESS":return function(e){switch(console.log(e),e){case"Processing":chrome.action.setBadgeText({text:"..."}),chrome.action.setBadgeBackgroundColor({color:"#777777"});break;case"Completed":chrome.action.setBadgeText({text:""})}}("Processing"),QV={tabID:QV.tabID,status:"Processing",startedAt:Date.now(),aiCount:0},chrome.storage.local.set({state:QV}),async function(){try{let t;(async function(e){const t=await YV,n=await ZV,r=[],s=e.text.data.slice(0,20);console.log("PAYLOAD BEFORE PREDICTION: ",s);for(const e of s)try{let s=e.text;const a=await t.encode(s),i=new Array(a.length).fill(1),o=hh([a],[1,a.length],"int32"),u=hh([i],[1,a.length],"int32"),l=n.execute({input_ids:o,attention_mask:u}),c=Array.isArray(l)?l[0]:l,h=Jc(c,-1),[,d]=await h.data();r.push({text_str:s,aiScore:d})}catch(e){console.error("Prediction error:",e),r.push({text_str,error:e.message})}return r})(e.payload).then(e=>{t=e,console.log("PAYLOAD AFTER PREDICTION: ",t)})}catch(e){console.error("error ",e)}}(),!0;case"SCAN_AGAIN":return console.log("Asking content to scan again"),QV={tabID:QV.tabID,status:"Processing",startedAt:Date.now()},chrome.storage.local.set({state:QV}),n(QV),async function(){const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});e?.id&&(await chrome.tabs.sendMessage(e.id,{type:"SCAN_AGAIN",source:"background"}),QV={tabID:e.id,status:"Completed",startedAt:null},chrome.storage.local.set({state:QV}))}(),!0;case"RESET_PAGE_POPUP":return console.log("Resetting page and all contents."),QV={tabID:QV.tabID,status:"Resetting",startedAt:Date.now()},chrome.storage.local.set({state:QV}),n(QV),async function(){const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});e?.id&&await chrome.tabs.sendMessage(e.id,{type:"RESET_PAGE_CONTENT",source:"background"}),QV={tabID:e.id,status:"Ready to scan!",startedAt:null},chrome.storage.local.set({state:QV}),chrome.action.setBadgeText({text:""})}(),!0;case"GET_POPUP_STATE":return console.log("Getting current state"),n(QV),!0}})})()})();